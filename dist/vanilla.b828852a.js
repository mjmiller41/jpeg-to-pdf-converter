// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  externals,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        if (externals[name]) {
          return externals[name];
        }
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  // INSERT_LOAD_HERE

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"5PTPR":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 4000;
var HMR_SECURE = false;
var HMR_ENV_HASH = "439701173a9199ea";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "f3e508fdb828852a";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            // Ignore cloudflare workers error.
            if (err.message && !err.message.includes('Disallowed operation called within global scope')) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"lhpGb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _jspdf = require("jspdf");
var _jspdfDefault = parcelHelpers.interopDefault(_jspdf);
var _pdfjsDist = require("pdfjs-dist");
var _jszip = require("jszip");
var _jszipDefault = parcelHelpers.interopDefault(_jszip);
_pdfjsDist.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${_pdfjsDist.version}/pdf.worker.min.mjs`;
const jpgToPdfModeBtn = document.getElementById('jpgToPdfMode');
const pdfToJpgModeBtn = document.getElementById('pdfToJpgMode');
const fileInput = document.getElementById('file-input');
const fileLabel = document.getElementById('file-label');
const previewArea = document.getElementById('preview-area');
const convertBtn = document.getElementById('convert-btn');
const clearBtn = document.getElementById('clear-btn');
const header = document.querySelector('header');
let selectedFiles = [];
let conversionMode = 'jpgToPdf';
jpgToPdfModeBtn.addEventListener('click', ()=>switchMode('jpgToPdf'));
pdfToJpgModeBtn.addEventListener('click', ()=>switchMode('pdfToJpg'));
fileInput.addEventListener('change', handleFileSelect);
fileLabel.addEventListener('dragover', handleDragOver);
fileLabel.addEventListener('dragleave', handleDragLeave);
fileLabel.addEventListener('drop', handleDrop);
convertBtn.addEventListener('click', convertFiles);
clearBtn.addEventListener('click', clearSelection);
function switchMode(mode) {
    conversionMode = mode;
    jpgToPdfModeBtn.classList.toggle('active', mode === 'jpgToPdf');
    pdfToJpgModeBtn.classList.toggle('active', mode === 'pdfToJpg');
    fileInput.accept = mode === 'jpgToPdf' ? 'image/jpeg' : 'application/pdf';
    header.querySelector('p').textContent = mode === 'jpgToPdf' ? 'Upload JPG file(s) to convert them into a single PDF document.' : 'Upload PDF file(s) to convert each page to a JPG image.';
    clearSelection();
}
function handleFileSelect(event) {
    const files = event.target.files;
    handleFiles(files);
}
function handleDragOver(event) {
    event.preventDefault();
    fileLabel.classList.add('dragging');
}
function handleDragLeave(event) {
    event.preventDefault();
    fileLabel.classList.remove('dragging');
}
function handleDrop(event) {
    event.preventDefault();
    fileLabel.classList.remove('dragging');
    const files = event.dataTransfer.files;
    handleFiles(files);
}
function handleFiles(files) {
    selectedFiles = Array.from(files).filter((file)=>{
        if (conversionMode === 'jpgToPdf') return file.type === 'image/jpeg';
        else return file.type === 'application/pdf';
    });
    renderPreviews();
}
function renderPreviews() {
    previewArea.innerHTML = '';
    selectedFiles.forEach((file)=>{
        const reader = new FileReader();
        reader.onload = (event)=>{
            const previewItem = document.createElement('div');
            previewItem.className = 'preview-item';
            if (conversionMode === 'jpgToPdf') {
                const img = document.createElement('img');
                img.src = event.target.result;
                previewItem.appendChild(img);
            } else previewItem.textContent = file.name;
            previewArea.appendChild(previewItem);
        };
        reader.readAsDataURL(file);
    });
}
function clearSelection() {
    selectedFiles = [];
    previewArea.innerHTML = '';
    fileInput.value = '';
}
async function convertFiles() {
    if (selectedFiles.length === 0) {
        alert('Please select files first.');
        return;
    }
    if (conversionMode === 'jpgToPdf') await convertToPdf();
    else await convertToJpg();
}
async function convertToPdf() {
    const pdf = new (0, _jspdfDefault.default)({
        orientation: 'p',
        unit: 'pt',
        format: 'a4'
    });
    const margin = 40;
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const usableWidth = pageWidth - margin * 2;
    const usableHeight = pageHeight - margin * 2;
    for(let i = 0; i < selectedFiles.length; i++){
        const file = selectedFiles[i];
        const img = await loadImage(URL.createObjectURL(file));
        const imgWidth = img.width;
        const imgHeight = img.height;
        const imgRatio = imgWidth / imgHeight;
        const pageRatio = usableWidth / usableHeight;
        let newWidth, newHeight;
        if (imgRatio > pageRatio) {
            newWidth = usableWidth;
            newHeight = newWidth / imgRatio;
        } else {
            newHeight = usableHeight;
            newWidth = newHeight * imgRatio;
        }
        const x = (pageWidth - newWidth) / 2;
        const y = (pageHeight - newHeight) / 2;
        if (i > 0) pdf.addPage();
        pdf.addImage(img, 'JPEG', x, y, newWidth, newHeight);
    }
    pdf.save('converted.pdf');
}
async function convertToJpg() {
    const zip = new (0, _jszipDefault.default)();
    for (const file of selectedFiles){
        const arrayBuffer = await file.arrayBuffer();
        const pdfDoc = await _pdfjsDist.getDocument({
            data: arrayBuffer
        }).promise;
        for(let i = 1; i <= pdfDoc.numPages; i++){
            const page = await pdfDoc.getPage(i);
            const viewport = page.getViewport({
                scale: 2.0
            });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;
            const imageData = canvas.toDataURL('image/jpeg', 0.9);
            zip.file(`${file.name.replace('.pdf', '')}-page-${i}.jpg`, imageData.split(',')[1], {
                base64: true
            });
        }
    }
    const content = await zip.generateAsync({
        type: 'blob'
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(content);
    link.download = 'converted_images.zip';
    link.click();
    URL.revokeObjectURL(link.href);
}
function loadImage(src) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = reject;
        img.src = src;
    });
}

},{"jspdf":"b6g54","pdfjs-dist":"aVBNV","jszip":"fhdYz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b6g54":[function(require,module,exports,__globalThis) {
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Holl√§nder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AcroForm", ()=>St);
parcelHelpers.export(exports, "AcroFormAppearance", ()=>At);
parcelHelpers.export(exports, "AcroFormButton", ()=>mt);
parcelHelpers.export(exports, "AcroFormCheckBox", ()=>wt);
parcelHelpers.export(exports, "AcroFormChoiceField", ()=>ft);
parcelHelpers.export(exports, "AcroFormComboBox", ()=>pt);
parcelHelpers.export(exports, "AcroFormEditBox", ()=>gt);
parcelHelpers.export(exports, "AcroFormListBox", ()=>dt);
parcelHelpers.export(exports, "AcroFormPasswordField", ()=>Lt);
parcelHelpers.export(exports, "AcroFormPushButton", ()=>vt);
parcelHelpers.export(exports, "AcroFormRadioButton", ()=>bt);
parcelHelpers.export(exports, "AcroFormTextField", ()=>Nt);
parcelHelpers.export(exports, "GState", ()=>j);
parcelHelpers.export(exports, "ShadingPattern", ()=>B);
parcelHelpers.export(exports, "TilingPattern", ()=>M);
parcelHelpers.export(exports, "jsPDF", ()=>E);
var _typeof = require("@babel/runtime/helpers/typeof");
var _typeofDefault = parcelHelpers.interopDefault(_typeof);
var _fflate = require("fflate");
var global = arguments[3];
var n = function() {
    return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
}();
function i() {
    n.console && "function" == typeof n.console.log && n.console.log.apply(n.console, arguments);
}
var a = {
    log: i,
    warn: function(t) {
        n.console && ("function" == typeof n.console.warn ? n.console.warn.apply(n.console, arguments) : i.call(null, arguments));
    },
    error: function(t) {
        n.console && ("function" == typeof n.console.error ? n.console.error.apply(n.console, arguments) : i(t));
    }
};
function o(t, e, r) {
    var n = new XMLHttpRequest;
    n.open("GET", t), n.responseType = "blob", n.onload = function() {
        l(n.response, e, r);
    }, n.onerror = function() {
        a.error("could not download file");
    }, n.send();
}
function s(t) {
    var e = new XMLHttpRequest;
    e.open("HEAD", t, !1);
    try {
        e.send();
    } catch (t) {}
    return e.status >= 200 && e.status <= 299;
}
function c(t) {
    try {
        t.dispatchEvent(new MouseEvent("click"));
    } catch (r) {
        var e = document.createEvent("MouseEvents");
        e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(e);
    }
}
var u, h, l = n.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : (0, _typeofDefault.default)(window)) || window !== n ? function() {} : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t, e, r) {
    var i = n.URL || n.webkitURL, a = document.createElement("a");
    e = e || t.name || "download", a.download = e, a.rel = "noopener", "string" == typeof t ? (a.href = t, a.origin !== location.origin ? s(a.href) ? o(t, e, r) : c(a, a.target = "_blank") : c(a)) : (a.href = i.createObjectURL(t), setTimeout(function() {
        i.revokeObjectURL(a.href);
    }, 4e4), setTimeout(function() {
        c(a);
    }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e, r, n) {
    if (r = r || e.name || "download", "string" == typeof e) {
        if (s(e)) o(e, r, n);
        else {
            var i = document.createElement("a");
            i.href = e, i.target = "_blank", setTimeout(function() {
                c(i);
            });
        }
    } else navigator.msSaveOrOpenBlob(function(e, r) {
        return void 0 === r ? r = {
            autoBom: !1
        } : "object" !== (0, _typeofDefault.default)(r) && (a.warn("Deprecated: Expected third argument to be a object"), r = {
            autoBom: !r
        }), r.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type) ? new Blob([
            String.fromCharCode(65279),
            e
        ], {
            type: e.type
        }) : e;
    }(e, n), r);
} : function(e, r, i, a) {
    if ((a = a || open("", "_blank")) && (a.document.title = a.document.body.innerText = "downloading..."), "string" == typeof e) return o(e, r, i);
    var s = "application/octet-stream" === e.type, c = /constructor/i.test(n.HTMLElement) || n.safari, u = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((u || s && c) && "object" === ("undefined" == typeof FileReader ? "undefined" : (0, _typeofDefault.default)(FileReader))) {
        var h = new FileReader;
        h.onloadend = function() {
            var t = h.result;
            t = u ? t : t.replace(/^data:[^;]*;/, "data:attachment/file;"), a ? a.location.href = t : location = t, a = null;
        }, h.readAsDataURL(e);
    } else {
        var l = n.URL || n.webkitURL, f = l.createObjectURL(e);
        a ? a.location = f : location.href = f, a = null, setTimeout(function() {
            l.revokeObjectURL(f);
        }, 4e4);
    }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */ function f(t) {
    var e;
    t = t || "", this.ok = !1, "#" == t.charAt(0) && (t = t.substr(1, 6));
    t = ({
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
    })[t = (t = t.replace(/ /g, "")).toLowerCase()] || t;
    for(var r = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: [
                "rgb(123, 234, 45)",
                "rgb(255,234,245)"
            ],
            process: function(t) {
                return [
                    parseInt(t[1]),
                    parseInt(t[2]),
                    parseInt(t[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: [
                "#00ff00",
                "336699"
            ],
            process: function(t) {
                return [
                    parseInt(t[1], 16),
                    parseInt(t[2], 16),
                    parseInt(t[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: [
                "#fb0",
                "f0f"
            ],
            process: function(t) {
                return [
                    parseInt(t[1] + t[1], 16),
                    parseInt(t[2] + t[2], 16),
                    parseInt(t[3] + t[3], 16)
                ];
            }
        }
    ], n = 0; n < r.length; n++){
        var i = r[n].re, a = r[n].process, o = i.exec(t);
        o && (e = a(o), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = !0);
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    }, this.toHex = function() {
        var t = this.r.toString(16), e = this.g.toString(16), r = this.b.toString(16);
        return 1 == t.length && (t = "0" + t), 1 == e.length && (e = "0" + e), 1 == r.length && (r = "0" + r), "#" + t + e + r;
    };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */ function d(t, e) {
    var r = t[0], n = t[1], i = t[2], a = t[3];
    r = g(r, n, i, a, e[0], 7, -680876936), a = g(a, r, n, i, e[1], 12, -389564586), i = g(i, a, r, n, e[2], 17, 606105819), n = g(n, i, a, r, e[3], 22, -1044525330), r = g(r, n, i, a, e[4], 7, -176418897), a = g(a, r, n, i, e[5], 12, 1200080426), i = g(i, a, r, n, e[6], 17, -1473231341), n = g(n, i, a, r, e[7], 22, -45705983), r = g(r, n, i, a, e[8], 7, 1770035416), a = g(a, r, n, i, e[9], 12, -1958414417), i = g(i, a, r, n, e[10], 17, -42063), n = g(n, i, a, r, e[11], 22, -1990404162), r = g(r, n, i, a, e[12], 7, 1804603682), a = g(a, r, n, i, e[13], 12, -40341101), i = g(i, a, r, n, e[14], 17, -1502002290), r = m(r, n = g(n, i, a, r, e[15], 22, 1236535329), i, a, e[1], 5, -165796510), a = m(a, r, n, i, e[6], 9, -1069501632), i = m(i, a, r, n, e[11], 14, 643717713), n = m(n, i, a, r, e[0], 20, -373897302), r = m(r, n, i, a, e[5], 5, -701558691), a = m(a, r, n, i, e[10], 9, 38016083), i = m(i, a, r, n, e[15], 14, -660478335), n = m(n, i, a, r, e[4], 20, -405537848), r = m(r, n, i, a, e[9], 5, 568446438), a = m(a, r, n, i, e[14], 9, -1019803690), i = m(i, a, r, n, e[3], 14, -187363961), n = m(n, i, a, r, e[8], 20, 1163531501), r = m(r, n, i, a, e[13], 5, -1444681467), a = m(a, r, n, i, e[2], 9, -51403784), i = m(i, a, r, n, e[7], 14, 1735328473), r = v(r, n = m(n, i, a, r, e[12], 20, -1926607734), i, a, e[5], 4, -378558), a = v(a, r, n, i, e[8], 11, -2022574463), i = v(i, a, r, n, e[11], 16, 1839030562), n = v(n, i, a, r, e[14], 23, -35309556), r = v(r, n, i, a, e[1], 4, -1530992060), a = v(a, r, n, i, e[4], 11, 1272893353), i = v(i, a, r, n, e[7], 16, -155497632), n = v(n, i, a, r, e[10], 23, -1094730640), r = v(r, n, i, a, e[13], 4, 681279174), a = v(a, r, n, i, e[0], 11, -358537222), i = v(i, a, r, n, e[3], 16, -722521979), n = v(n, i, a, r, e[6], 23, 76029189), r = v(r, n, i, a, e[9], 4, -640364487), a = v(a, r, n, i, e[12], 11, -421815835), i = v(i, a, r, n, e[15], 16, 530742520), r = b(r, n = v(n, i, a, r, e[2], 23, -995338651), i, a, e[0], 6, -198630844), a = b(a, r, n, i, e[7], 10, 1126891415), i = b(i, a, r, n, e[14], 15, -1416354905), n = b(n, i, a, r, e[5], 21, -57434055), r = b(r, n, i, a, e[12], 6, 1700485571), a = b(a, r, n, i, e[3], 10, -1894986606), i = b(i, a, r, n, e[10], 15, -1051523), n = b(n, i, a, r, e[1], 21, -2054922799), r = b(r, n, i, a, e[8], 6, 1873313359), a = b(a, r, n, i, e[15], 10, -30611744), i = b(i, a, r, n, e[6], 15, -1560198380), n = b(n, i, a, r, e[13], 21, 1309151649), r = b(r, n, i, a, e[4], 6, -145523070), a = b(a, r, n, i, e[11], 10, -1120210379), i = b(i, a, r, n, e[2], 15, 718787259), n = b(n, i, a, r, e[9], 21, -343485551), t[0] = _(r, t[0]), t[1] = _(n, t[1]), t[2] = _(i, t[2]), t[3] = _(a, t[3]);
}
function p(t, e, r, n, i, a) {
    return e = _(_(e, t), _(n, a)), _(e << i | e >>> 32 - i, r);
}
function g(t, e, r, n, i, a, o) {
    return p(e & r | ~e & n, t, e, i, a, o);
}
function m(t, e, r, n, i, a, o) {
    return p(e & n | r & ~n, t, e, i, a, o);
}
function v(t, e, r, n, i, a, o) {
    return p(e ^ r ^ n, t, e, i, a, o);
}
function b(t, e, r, n, i, a, o) {
    return p(r ^ (e | ~n), t, e, i, a, o);
}
function y(t) {
    var e, r = t.length, n = [
        1732584193,
        -271733879,
        -1732584194,
        271733878
    ];
    for(e = 64; e <= t.length; e += 64)d(n, w(t.substring(e - 64, e)));
    t = t.substring(e - 64);
    var i = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ];
    for(e = 0; e < t.length; e++)i[e >> 2] |= t.charCodeAt(e) << (e % 4 << 3);
    if (i[e >> 2] |= 128 << (e % 4 << 3), e > 55) for(d(n, i), e = 0; e < 16; e++)i[e] = 0;
    return i[14] = 8 * r, d(n, i), n;
}
function w(t) {
    var e, r = [];
    for(e = 0; e < 64; e += 4)r[e >> 2] = t.charCodeAt(e) + (t.charCodeAt(e + 1) << 8) + (t.charCodeAt(e + 2) << 16) + (t.charCodeAt(e + 3) << 24);
    return r;
}
u = n.atob.bind(n), h = n.btoa.bind(n);
var N = "0123456789abcdef".split("");
function L(t) {
    for(var e = "", r = 0; r < 4; r++)e += N[t >> 8 * r + 4 & 15] + N[t >> 8 * r & 15];
    return e;
}
function A(t) {
    return String.fromCharCode((255 & t) >> 0, (65280 & t) >> 8, (16711680 & t) >> 16, (4278190080 & t) >> 24);
}
function x(t) {
    return y(t).map(A).join("");
}
var S = "5d41402abc4b2a76b9719d911017c592" != function(t) {
    for(var e = 0; e < t.length; e++)t[e] = L(t[e]);
    return t.join("");
}(y("hello"));
function _(t, e) {
    if (S) {
        var r = (65535 & t) + (65535 & e);
        return (t >> 16) + (e >> 16) + (r >> 16) << 16 | 65535 & r;
    }
    return t + e & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */ function P(t, e) {
    var r, n, i, a;
    if (t !== r) {
        for(var o = (i = t, a = 1 + (256 / t.length >> 0), new Array(a + 1).join(i)), s = [], c = 0; c < 256; c++)s[c] = c;
        var u = 0;
        for(c = 0; c < 256; c++){
            var h = s[c];
            u = (u + h + o.charCodeAt(c)) % 256, s[c] = s[u], s[u] = h;
        }
        r = t, n = s;
    } else s = n;
    var l = e.length, f = 0, d = 0, p = "";
    for(c = 0; c < l; c++)d = (d + (h = s[f = (f + 1) % 256])) % 256, s[f] = s[d], s[d] = h, o = s[(s[f] + s[d]) % 256], p += String.fromCharCode(e.charCodeAt(c) ^ o);
    return p;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */ var k = {
    print: 4,
    modify: 8,
    copy: 16,
    "annot-forms": 32
};
function I(t, e, r, n) {
    this.v = 1, this.r = 2;
    var i = 192;
    t.forEach(function(t) {
        if (void 0 !== k.perm) throw new Error("Invalid permission: " + t);
        i += k[t];
    }), this.padding = "(\xbfN^Nu\x8aAd\0NV\xff\xfa\x01\b..\0\xb6\xd0h>\x80/\f\xa9\xfedSiz";
    var a = (e + this.padding).substr(0, 32), o = (r + this.padding).substr(0, 32);
    this.O = this.processOwnerPassword(a, o), this.P = -(1 + (255 ^ i)), this.encryptionKey = x(a + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
function F(t) {
    if (/[^\u0000-\u00ff]/.test(t)) throw new Error("Invalid PDF Name Object: " + t + ", Only accept ASCII characters.");
    for(var e = "", r = t.length, n = 0; n < r; n++){
        var i = t.charCodeAt(n);
        if (i < 33 || 35 === i || 37 === i || 40 === i || 41 === i || 47 === i || 60 === i || 62 === i || 91 === i || 93 === i || 123 === i || 125 === i || i > 126) e += "#" + ("0" + i.toString(16)).slice(-2);
        else e += t[n];
    }
    return e;
}
function C(e) {
    if ("object" !== (0, _typeofDefault.default)(e)) throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
    var r = {};
    this.subscribe = function(t, e, n) {
        if (n = n || !1, "string" != typeof t || "function" != typeof e || "boolean" != typeof n) throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
        r.hasOwnProperty(t) || (r[t] = {});
        var i = Math.random().toString(35);
        return r[t][i] = [
            e,
            !!n
        ], i;
    }, this.unsubscribe = function(t) {
        for(var e in r)if (r[e][t]) return delete r[e][t], 0 === Object.keys(r[e]).length && delete r[e], !0;
        return !1;
    }, this.publish = function(t) {
        if (r.hasOwnProperty(t)) {
            var i = Array.prototype.slice.call(arguments, 1), o = [];
            for(var s in r[t]){
                var c = r[t][s];
                try {
                    c[0].apply(e, i);
                } catch (t) {
                    n.console && a.error("jsPDF PubSub Error", t.message, t);
                }
                c[1] && o.push(s);
            }
            o.length && o.forEach(this.unsubscribe);
        }
    }, this.getTopics = function() {
        return r;
    };
}
function j(t) {
    if (!(this instanceof j)) return new j(t);
    var e = "opacity,stroke-opacity".split(",");
    for(var r in t)t.hasOwnProperty(r) && e.indexOf(r) >= 0 && (this[r] = t[r]);
    this.id = "", this.objectNumber = -1;
}
function O(t, e) {
    this.gState = t, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function B(t, e, r, n, i) {
    if (!(this instanceof B)) return new B(t, e, r, n, i);
    this.type = "axial" === t ? 2 : 3, this.coords = e, this.colors = r, O.call(this, n, i);
}
function M(t, e, r, n, i) {
    if (!(this instanceof M)) return new M(t, e, r, n, i);
    this.boundingBox = t, this.xStep = e, this.yStep = r, this.stream = "", this.cloneIndex = 0, O.call(this, n, i);
}
function E(e) {
    var r, i = "string" == typeof arguments[0] ? arguments[0] : "p", o = arguments[1], s = arguments[2], c = arguments[3], u = [], d = 1, p = 16, g = "S", m = null;
    "object" === (0, _typeofDefault.default)(e = e || {}) && (i = e.orientation, o = e.unit || o, s = e.format || s, c = e.compress || e.compressPdf || c, null !== (m = e.encryption || null) && (m.userPassword = m.userPassword || "", m.ownerPassword = m.ownerPassword || "", m.userPermissions = m.userPermissions || []), d = "number" == typeof e.userUnit ? Math.abs(e.userUnit) : 1, void 0 !== e.precision && (r = e.precision), void 0 !== e.floatPrecision && (p = e.floatPrecision), g = e.defaultPathOperation || "S"), u = e.filters || (!0 === c ? [
        "FlateEncode"
    ] : u), o = o || "mm", i = ("" + (i || "P")).toLowerCase();
    var v = e.putOnlyUsedFonts || !1, b = {}, y = {
        internal: {},
        __private__: {}
    };
    y.__private__.PubSub = C;
    var w = "1.3", N = y.__private__.getPdfVersion = function() {
        return w;
    };
    y.__private__.setPdfVersion = function(t) {
        w = t;
    };
    var L = {
        a0: [
            2383.94,
            3370.39
        ],
        a1: [
            1683.78,
            2383.94
        ],
        a2: [
            1190.55,
            1683.78
        ],
        a3: [
            841.89,
            1190.55
        ],
        a4: [
            595.28,
            841.89
        ],
        a5: [
            419.53,
            595.28
        ],
        a6: [
            297.64,
            419.53
        ],
        a7: [
            209.76,
            297.64
        ],
        a8: [
            147.4,
            209.76
        ],
        a9: [
            104.88,
            147.4
        ],
        a10: [
            73.7,
            104.88
        ],
        b0: [
            2834.65,
            4008.19
        ],
        b1: [
            2004.09,
            2834.65
        ],
        b2: [
            1417.32,
            2004.09
        ],
        b3: [
            1000.63,
            1417.32
        ],
        b4: [
            708.66,
            1000.63
        ],
        b5: [
            498.9,
            708.66
        ],
        b6: [
            354.33,
            498.9
        ],
        b7: [
            249.45,
            354.33
        ],
        b8: [
            175.75,
            249.45
        ],
        b9: [
            124.72,
            175.75
        ],
        b10: [
            87.87,
            124.72
        ],
        c0: [
            2599.37,
            3676.54
        ],
        c1: [
            1836.85,
            2599.37
        ],
        c2: [
            1298.27,
            1836.85
        ],
        c3: [
            918.43,
            1298.27
        ],
        c4: [
            649.13,
            918.43
        ],
        c5: [
            459.21,
            649.13
        ],
        c6: [
            323.15,
            459.21
        ],
        c7: [
            229.61,
            323.15
        ],
        c8: [
            161.57,
            229.61
        ],
        c9: [
            113.39,
            161.57
        ],
        c10: [
            79.37,
            113.39
        ],
        dl: [
            311.81,
            623.62
        ],
        letter: [
            612,
            792
        ],
        "government-letter": [
            576,
            756
        ],
        legal: [
            612,
            1008
        ],
        "junior-legal": [
            576,
            360
        ],
        ledger: [
            1224,
            792
        ],
        tabloid: [
            792,
            1224
        ],
        "credit-card": [
            153,
            243
        ]
    };
    y.__private__.getPageFormats = function() {
        return L;
    };
    var A = y.__private__.getPageFormat = function(t) {
        return L[t];
    };
    s = s || "a4";
    var x = {
        COMPAT: "compat",
        ADVANCED: "advanced"
    }, S = x.COMPAT;
    function _() {
        this.saveGraphicsState(), lt(new Vt(_t, 0, 0, -_t, 0, Rr() * _t).toString() + " cm"), this.setFontSize(this.getFontSize() / _t), g = "n", S = x.ADVANCED;
    }
    function P() {
        this.restoreGraphicsState(), g = "S", S = x.COMPAT;
    }
    var k = y.__private__.combineFontStyleAndFontWeight = function(t, e) {
        if ("bold" == t && "normal" == e || "bold" == t && 400 == e || "normal" == t && "italic" == e || "bold" == t && "italic" == e) throw new Error("Invalid Combination of fontweight and fontstyle");
        return e && (t = 400 == e || "normal" === e ? "italic" === t ? "italic" : "normal" : 700 != e && "bold" !== e || "normal" !== t ? (700 == e ? "bold" : e) + "" + t : "bold"), t;
    };
    y.advancedAPI = function(t) {
        var e = S === x.COMPAT;
        return e && _.call(this), "function" != typeof t || (t(this), e && P.call(this)), this;
    }, y.compatAPI = function(t) {
        var e = S === x.ADVANCED;
        return e && P.call(this), "function" != typeof t || (t(this), e && _.call(this)), this;
    }, y.isAdvancedAPI = function() {
        return S === x.ADVANCED;
    };
    var O, q = function(t) {
        if (S !== x.ADVANCED) throw new Error(t + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
    }, D = y.roundToPrecision = y.__private__.roundToPrecision = function(t, e) {
        var n = r || e;
        if (isNaN(t) || isNaN(n)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
        return t.toFixed(n).replace(/0+$/, "");
    };
    O = y.hpf = y.__private__.hpf = "number" == typeof p ? function(t) {
        if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.hpf");
        return D(t, p);
    } : "smart" === p ? function(t) {
        if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.hpf");
        return D(t, t > -1 && t < 1 ? 16 : 5);
    } : function(t) {
        if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.hpf");
        return D(t, 16);
    };
    var R = y.f2 = y.__private__.f2 = function(t) {
        if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.f2");
        return D(t, 2);
    }, T = y.__private__.f3 = function(t) {
        if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.f3");
        return D(t, 3);
    }, U = y.scale = y.__private__.scale = function(t) {
        if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.scale");
        return S === x.COMPAT ? t * _t : S === x.ADVANCED ? t : void 0;
    }, z = function(t) {
        return S === x.COMPAT ? Rr() - t : S === x.ADVANCED ? t : void 0;
    }, H = function(t) {
        return U(z(t));
    };
    y.__private__.setPrecision = y.setPrecision = function(t) {
        "number" == typeof parseInt(t, 10) && (r = parseInt(t, 10));
    };
    var W, V = "00000000000000000000000000000000", G = y.__private__.getFileId = function() {
        return V;
    }, Y = y.__private__.setFileId = function(t) {
        return V = void 0 !== t && /^[a-fA-F0-9]{32}$/.test(t) ? t.toUpperCase() : V.split("").map(function() {
            return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
        }).join(""), null !== m && (Ye = new I(m.userPermissions, m.userPassword, m.ownerPassword, V)), V;
    };
    y.setFileId = function(t) {
        return Y(t), this;
    }, y.getFileId = function() {
        return G();
    };
    var J = y.__private__.convertDateToPDFDate = function(t) {
        var e = t.getTimezoneOffset(), r = e < 0 ? "+" : "-", n = Math.floor(Math.abs(e / 60)), i = Math.abs(e % 60), a = [
            r,
            Q(n),
            "'",
            Q(i),
            "'"
        ].join("");
        return [
            "D:",
            t.getFullYear(),
            Q(t.getMonth() + 1),
            Q(t.getDate()),
            Q(t.getHours()),
            Q(t.getMinutes()),
            Q(t.getSeconds()),
            a
        ].join("");
    }, X = y.__private__.convertPDFDateToDate = function(t) {
        var e = parseInt(t.substr(2, 4), 10), r = parseInt(t.substr(6, 2), 10) - 1, n = parseInt(t.substr(8, 2), 10), i = parseInt(t.substr(10, 2), 10), a = parseInt(t.substr(12, 2), 10), o = parseInt(t.substr(14, 2), 10);
        return new Date(e, r, n, i, a, o, 0);
    }, K = y.__private__.setCreationDate = function(t) {
        var e;
        if (void 0 === t && (t = new Date), t instanceof Date) e = J(t);
        else {
            if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
            e = t;
        }
        return W = e;
    }, Z = y.__private__.getCreationDate = function(t) {
        var e = W;
        return "jsDate" === t && (e = X(W)), e;
    };
    y.setCreationDate = function(t) {
        return K(t), this;
    }, y.getCreationDate = function(t) {
        return Z(t);
    };
    var $, Q = y.__private__.padd2 = function(t) {
        return ("0" + parseInt(t)).slice(-2);
    }, tt = y.__private__.padd2Hex = function(t) {
        return ("00" + (t = t.toString())).substr(t.length);
    }, et = 0, rt = [], nt = [], it = 0, at = [], ot = [], st = !1, ct = nt, ut = function() {
        et = 0, it = 0, nt = [], rt = [], at = [], Qt = Kt(), te = Kt();
    };
    y.__private__.setCustomOutputDestination = function(t) {
        st = !0, ct = t;
    };
    var ht = function(t) {
        st || (ct = t);
    };
    y.__private__.resetCustomOutputDestination = function() {
        st = !1, ct = nt;
    };
    var lt = y.__private__.out = function(t) {
        return t = t.toString(), it += t.length + 1, ct.push(t), ct;
    }, ft = y.__private__.write = function(t) {
        return lt(1 === arguments.length ? t.toString() : Array.prototype.join.call(arguments, " "));
    }, dt = y.__private__.getArrayBuffer = function(t) {
        for(var e = t.length, r = new ArrayBuffer(e), n = new Uint8Array(r); e--;)n[e] = t.charCodeAt(e);
        return r;
    }, pt = [
        [
            "Helvetica",
            "helvetica",
            "normal",
            "WinAnsiEncoding"
        ],
        [
            "Helvetica-Bold",
            "helvetica",
            "bold",
            "WinAnsiEncoding"
        ],
        [
            "Helvetica-Oblique",
            "helvetica",
            "italic",
            "WinAnsiEncoding"
        ],
        [
            "Helvetica-BoldOblique",
            "helvetica",
            "bolditalic",
            "WinAnsiEncoding"
        ],
        [
            "Courier",
            "courier",
            "normal",
            "WinAnsiEncoding"
        ],
        [
            "Courier-Bold",
            "courier",
            "bold",
            "WinAnsiEncoding"
        ],
        [
            "Courier-Oblique",
            "courier",
            "italic",
            "WinAnsiEncoding"
        ],
        [
            "Courier-BoldOblique",
            "courier",
            "bolditalic",
            "WinAnsiEncoding"
        ],
        [
            "Times-Roman",
            "times",
            "normal",
            "WinAnsiEncoding"
        ],
        [
            "Times-Bold",
            "times",
            "bold",
            "WinAnsiEncoding"
        ],
        [
            "Times-Italic",
            "times",
            "italic",
            "WinAnsiEncoding"
        ],
        [
            "Times-BoldItalic",
            "times",
            "bolditalic",
            "WinAnsiEncoding"
        ],
        [
            "ZapfDingbats",
            "zapfdingbats",
            "normal",
            null
        ],
        [
            "Symbol",
            "symbol",
            "normal",
            null
        ]
    ];
    y.__private__.getStandardFonts = function() {
        return pt;
    };
    var gt = e.fontSize || 16;
    y.__private__.setFontSize = y.setFontSize = function(t) {
        return gt = S === x.ADVANCED ? t / _t : t, this;
    };
    var mt, vt = y.__private__.getFontSize = y.getFontSize = function() {
        return S === x.COMPAT ? gt : gt * _t;
    }, bt = e.R2L || !1;
    y.__private__.setR2L = y.setR2L = function(t) {
        return bt = t, this;
    }, y.__private__.getR2L = y.getR2L = function() {
        return bt;
    };
    var yt, wt = y.__private__.setZoomMode = function(t) {
        var e = [
            void 0,
            null,
            "fullwidth",
            "fullheight",
            "fullpage",
            "original"
        ];
        if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t)) mt = t;
        else if (isNaN(t)) {
            if (-1 === e.indexOf(t)) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t + '" is not recognized.');
            mt = t;
        } else mt = parseInt(t, 10);
    };
    y.__private__.getZoomMode = function() {
        return mt;
    };
    var Nt, Lt = y.__private__.setPageMode = function(t) {
        if (-1 == [
            void 0,
            null,
            "UseNone",
            "UseOutlines",
            "UseThumbs",
            "FullScreen"
        ].indexOf(t)) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t + '" is not recognized.');
        yt = t;
    };
    y.__private__.getPageMode = function() {
        return yt;
    };
    var At = y.__private__.setLayoutMode = function(t) {
        if (-1 == [
            void 0,
            null,
            "continuous",
            "single",
            "twoleft",
            "tworight",
            "two"
        ].indexOf(t)) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t + '" is not recognized.');
        Nt = t;
    };
    y.__private__.getLayoutMode = function() {
        return Nt;
    }, y.__private__.setDisplayMode = y.setDisplayMode = function(t, e, r) {
        return wt(t), At(e), Lt(r), this;
    };
    var xt = {
        title: "",
        subject: "",
        author: "",
        keywords: "",
        creator: ""
    };
    y.__private__.getDocumentProperty = function(t) {
        if (-1 === Object.keys(xt).indexOf(t)) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
        return xt[t];
    }, y.__private__.getDocumentProperties = function() {
        return xt;
    }, y.__private__.setDocumentProperties = y.setProperties = y.setDocumentProperties = function(t) {
        for(var e in xt)xt.hasOwnProperty(e) && t[e] && (xt[e] = t[e]);
        return this;
    }, y.__private__.setDocumentProperty = function(t, e) {
        if (-1 === Object.keys(xt).indexOf(t)) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
        return xt[t] = e;
    };
    var St, _t, Pt, kt, It, Ft = {}, Ct = {}, jt = [], Ot = {}, Bt = {}, Mt = {}, Et = {}, qt = null, Dt = 0, Rt = [], Tt = new C(y), Ut = e.hotfixes || [], zt = {}, Ht = {}, Wt = [], Vt = function t(e, r, n, i, a, o) {
        if (!(this instanceof t)) return new t(e, r, n, i, a, o);
        isNaN(e) && (e = 1), isNaN(r) && (r = 0), isNaN(n) && (n = 0), isNaN(i) && (i = 1), isNaN(a) && (a = 0), isNaN(o) && (o = 0), this._matrix = [
            e,
            r,
            n,
            i,
            a,
            o
        ];
    };
    Object.defineProperty(Vt.prototype, "sx", {
        get: function() {
            return this._matrix[0];
        },
        set: function(t) {
            this._matrix[0] = t;
        }
    }), Object.defineProperty(Vt.prototype, "shy", {
        get: function() {
            return this._matrix[1];
        },
        set: function(t) {
            this._matrix[1] = t;
        }
    }), Object.defineProperty(Vt.prototype, "shx", {
        get: function() {
            return this._matrix[2];
        },
        set: function(t) {
            this._matrix[2] = t;
        }
    }), Object.defineProperty(Vt.prototype, "sy", {
        get: function() {
            return this._matrix[3];
        },
        set: function(t) {
            this._matrix[3] = t;
        }
    }), Object.defineProperty(Vt.prototype, "tx", {
        get: function() {
            return this._matrix[4];
        },
        set: function(t) {
            this._matrix[4] = t;
        }
    }), Object.defineProperty(Vt.prototype, "ty", {
        get: function() {
            return this._matrix[5];
        },
        set: function(t) {
            this._matrix[5] = t;
        }
    }), Object.defineProperty(Vt.prototype, "a", {
        get: function() {
            return this._matrix[0];
        },
        set: function(t) {
            this._matrix[0] = t;
        }
    }), Object.defineProperty(Vt.prototype, "b", {
        get: function() {
            return this._matrix[1];
        },
        set: function(t) {
            this._matrix[1] = t;
        }
    }), Object.defineProperty(Vt.prototype, "c", {
        get: function() {
            return this._matrix[2];
        },
        set: function(t) {
            this._matrix[2] = t;
        }
    }), Object.defineProperty(Vt.prototype, "d", {
        get: function() {
            return this._matrix[3];
        },
        set: function(t) {
            this._matrix[3] = t;
        }
    }), Object.defineProperty(Vt.prototype, "e", {
        get: function() {
            return this._matrix[4];
        },
        set: function(t) {
            this._matrix[4] = t;
        }
    }), Object.defineProperty(Vt.prototype, "f", {
        get: function() {
            return this._matrix[5];
        },
        set: function(t) {
            this._matrix[5] = t;
        }
    }), Object.defineProperty(Vt.prototype, "rotation", {
        get: function() {
            return Math.atan2(this.shx, this.sx);
        }
    }), Object.defineProperty(Vt.prototype, "scaleX", {
        get: function() {
            return this.decompose().scale.sx;
        }
    }), Object.defineProperty(Vt.prototype, "scaleY", {
        get: function() {
            return this.decompose().scale.sy;
        }
    }), Object.defineProperty(Vt.prototype, "isIdentity", {
        get: function() {
            return 1 === this.sx && 0 === this.shy && 0 === this.shx && 1 === this.sy && 0 === this.tx && 0 === this.ty;
        }
    }), Vt.prototype.join = function(t) {
        return [
            this.sx,
            this.shy,
            this.shx,
            this.sy,
            this.tx,
            this.ty
        ].map(O).join(t);
    }, Vt.prototype.multiply = function(t) {
        var e = t.sx * this.sx + t.shy * this.shx, r = t.sx * this.shy + t.shy * this.sy, n = t.shx * this.sx + t.sy * this.shx, i = t.shx * this.shy + t.sy * this.sy, a = t.tx * this.sx + t.ty * this.shx + this.tx, o = t.tx * this.shy + t.ty * this.sy + this.ty;
        return new Vt(e, r, n, i, a, o);
    }, Vt.prototype.decompose = function() {
        var t = this.sx, e = this.shy, r = this.shx, n = this.sy, i = this.tx, a = this.ty, o = Math.sqrt(t * t + e * e), s = (t /= o) * r + (e /= o) * n;
        r -= t * s, n -= e * s;
        var c = Math.sqrt(r * r + n * n);
        return s /= c, t * (n /= c) < e * (r /= c) && (t = -t, e = -e, s = -s, o = -o), {
            scale: new Vt(o, 0, 0, c, 0, 0),
            translate: new Vt(1, 0, 0, 1, i, a),
            rotate: new Vt(t, e, -e, t, 0, 0),
            skew: new Vt(1, 0, s, 1, 0, 0)
        };
    }, Vt.prototype.toString = function(t) {
        return this.join(" ");
    }, Vt.prototype.inversed = function() {
        var t = this.sx, e = this.shy, r = this.shx, n = this.sy, i = this.tx, a = this.ty, o = 1 / (t * n - e * r), s = n * o, c = -e * o, u = -r * o, h = t * o;
        return new Vt(s, c, u, h, -s * i - u * a, -c * i - h * a);
    }, Vt.prototype.applyToPoint = function(t) {
        var e = t.x * this.sx + t.y * this.shx + this.tx, r = t.x * this.shy + t.y * this.sy + this.ty;
        return new Cr(e, r);
    }, Vt.prototype.applyToRectangle = function(t) {
        var e = this.applyToPoint(t), r = this.applyToPoint(new Cr(t.x + t.w, t.y + t.h));
        return new jr(e.x, e.y, r.x - e.x, r.y - e.y);
    }, Vt.prototype.clone = function() {
        var t = this.sx, e = this.shy, r = this.shx, n = this.sy, i = this.tx, a = this.ty;
        return new Vt(t, e, r, n, i, a);
    }, y.Matrix = Vt;
    var Gt = y.matrixMult = function(t, e) {
        return e.multiply(t);
    }, Yt = new Vt(1, 0, 0, 1, 0, 0);
    y.unitMatrix = y.identityMatrix = Yt;
    var Jt = function(t, e) {
        if (!Bt[t]) {
            var r = (e instanceof B ? "Sh" : "P") + (Object.keys(Ot).length + 1).toString(10);
            e.id = r, Bt[t] = r, Ot[r] = e, Tt.publish("addPattern", e);
        }
    };
    y.ShadingPattern = B, y.TilingPattern = M, y.addShadingPattern = function(t, e) {
        return q("addShadingPattern()"), Jt(t, e), this;
    }, y.beginTilingPattern = function(t) {
        q("beginTilingPattern()"), Br(t.boundingBox[0], t.boundingBox[1], t.boundingBox[2] - t.boundingBox[0], t.boundingBox[3] - t.boundingBox[1], t.matrix);
    }, y.endTilingPattern = function(t, e) {
        q("endTilingPattern()"), e.stream = ot[$].join("\n"), Jt(t, e), Tt.publish("endTilingPattern", e), Wt.pop().restore();
    };
    var Xt = y.__private__.newObject = function() {
        var t = Kt();
        return Zt(t, !0), t;
    }, Kt = y.__private__.newObjectDeferred = function() {
        return et++, rt[et] = function() {
            return it;
        }, et;
    }, Zt = function(t, e) {
        return e = "boolean" == typeof e && e, rt[t] = it, e && lt(t + " 0 obj"), t;
    }, $t = y.__private__.newAdditionalObject = function() {
        var t = {
            objId: Kt(),
            content: ""
        };
        return at.push(t), t;
    }, Qt = Kt(), te = Kt(), ee = y.__private__.decodeColorString = function(t) {
        var e = t.split(" ");
        if (2 !== e.length || "g" !== e[1] && "G" !== e[1]) {
            if (5 === e.length && ("k" === e[4] || "K" === e[4])) e = [
                (1 - e[0]) * (1 - e[3]),
                (1 - e[1]) * (1 - e[3]),
                (1 - e[2]) * (1 - e[3]),
                "r"
            ];
        } else {
            var r = parseFloat(e[0]);
            e = [
                r,
                r,
                r,
                "r"
            ];
        }
        for(var n = "#", i = 0; i < 3; i++)n += ("0" + Math.floor(255 * parseFloat(e[i])).toString(16)).slice(-2);
        return n;
    }, re = y.__private__.encodeColorString = function(e) {
        var r;
        "string" == typeof e && (e = {
            ch1: e
        });
        var n = e.ch1, i = e.ch2, a = e.ch3, o = e.ch4, s = "draw" === e.pdfColorType ? [
            "G",
            "RG",
            "K"
        ] : [
            "g",
            "rg",
            "k"
        ];
        if ("string" == typeof n && "#" !== n.charAt(0)) {
            var c = new f(n);
            if (c.ok) n = c.toHex();
            else if (!/^\d*\.?\d*$/.test(n)) throw new Error('Invalid color "' + n + '" passed to jsPDF.encodeColorString.');
        }
        if ("string" == typeof n && /^#[0-9A-Fa-f]{3}$/.test(n) && (n = "#" + n[1] + n[1] + n[2] + n[2] + n[3] + n[3]), "string" == typeof n && /^#[0-9A-Fa-f]{6}$/.test(n)) {
            var u = parseInt(n.substr(1), 16);
            n = u >> 16 & 255, i = u >> 8 & 255, a = 255 & u;
        }
        if (void 0 === i || void 0 === o && n === i && i === a) {
            if ("string" == typeof n) r = n + " " + s[0];
            else switch(e.precision){
                case 2:
                    r = R(n / 255) + " " + s[0];
                    break;
                case 3:
                default:
                    r = T(n / 255) + " " + s[0];
            }
        } else if (void 0 === o || "object" === (0, _typeofDefault.default)(o)) {
            if (o && !isNaN(o.a) && 0 === o.a) return r = [
                "1.",
                "1.",
                "1.",
                s[1]
            ].join(" ");
            if ("string" == typeof n) r = [
                n,
                i,
                a,
                s[1]
            ].join(" ");
            else switch(e.precision){
                case 2:
                    r = [
                        R(n / 255),
                        R(i / 255),
                        R(a / 255),
                        s[1]
                    ].join(" ");
                    break;
                default:
                case 3:
                    r = [
                        T(n / 255),
                        T(i / 255),
                        T(a / 255),
                        s[1]
                    ].join(" ");
            }
        } else if ("string" == typeof n) r = [
            n,
            i,
            a,
            o,
            s[2]
        ].join(" ");
        else switch(e.precision){
            case 2:
                r = [
                    R(n),
                    R(i),
                    R(a),
                    R(o),
                    s[2]
                ].join(" ");
                break;
            case 3:
            default:
                r = [
                    T(n),
                    T(i),
                    T(a),
                    T(o),
                    s[2]
                ].join(" ");
        }
        return r;
    }, ne = y.__private__.getFilters = function() {
        return u;
    }, ie = y.__private__.putStream = function(t) {
        var e = (t = t || {}).data || "", r = t.filters || ne(), n = t.alreadyAppliedFilters || [], i = t.addLength1 || !1, a = e.length, o = t.objectId, s = function(t) {
            return t;
        };
        if (null !== m && void 0 === o) throw new Error("ObjectId must be passed to putStream for file encryption");
        null !== m && (s = Ye.encryptor(o, 0));
        var c = {};
        !0 === r && (r = [
            "FlateEncode"
        ]);
        var u = t.additionalKeyValues || [], h = (c = void 0 !== E.API.processDataByFilters ? E.API.processDataByFilters(e, r) : {
            data: e,
            reverseChain: []
        }).reverseChain + (Array.isArray(n) ? n.join(" ") : n.toString());
        if (0 !== c.data.length && (u.push({
            key: "Length",
            value: c.data.length
        }), !0 === i && u.push({
            key: "Length1",
            value: a
        })), 0 != h.length) {
            if (h.split("/").length - 1 == 1) u.push({
                key: "Filter",
                value: h
            });
            else {
                u.push({
                    key: "Filter",
                    value: "[" + h + "]"
                });
                for(var l = 0; l < u.length; l += 1)if ("DecodeParms" === u[l].key) {
                    for(var f = [], d = 0; d < c.reverseChain.split("/").length - 1; d += 1)f.push("null");
                    f.push(u[l].value), u[l].value = "[" + f.join(" ") + "]";
                }
            }
        }
        lt("<<");
        for(var p = 0; p < u.length; p++)lt("/" + u[p].key + " " + u[p].value);
        lt(">>"), 0 !== c.data.length && (lt("stream"), lt(s(c.data)), lt("endstream"));
    }, ae = y.__private__.putPage = function(t) {
        var e = t.number, r = t.data, n = t.objId, i = t.contentsObjId;
        Zt(n, !0), lt("<</Type /Page"), lt("/Parent " + t.rootDictionaryObjId + " 0 R"), lt("/Resources " + t.resourceDictionaryObjId + " 0 R"), lt("/MediaBox [" + parseFloat(O(t.mediaBox.bottomLeftX)) + " " + parseFloat(O(t.mediaBox.bottomLeftY)) + " " + O(t.mediaBox.topRightX) + " " + O(t.mediaBox.topRightY) + "]"), null !== t.cropBox && lt("/CropBox [" + O(t.cropBox.bottomLeftX) + " " + O(t.cropBox.bottomLeftY) + " " + O(t.cropBox.topRightX) + " " + O(t.cropBox.topRightY) + "]"), null !== t.bleedBox && lt("/BleedBox [" + O(t.bleedBox.bottomLeftX) + " " + O(t.bleedBox.bottomLeftY) + " " + O(t.bleedBox.topRightX) + " " + O(t.bleedBox.topRightY) + "]"), null !== t.trimBox && lt("/TrimBox [" + O(t.trimBox.bottomLeftX) + " " + O(t.trimBox.bottomLeftY) + " " + O(t.trimBox.topRightX) + " " + O(t.trimBox.topRightY) + "]"), null !== t.artBox && lt("/ArtBox [" + O(t.artBox.bottomLeftX) + " " + O(t.artBox.bottomLeftY) + " " + O(t.artBox.topRightX) + " " + O(t.artBox.topRightY) + "]"), "number" == typeof t.userUnit && 1 !== t.userUnit && lt("/UserUnit " + t.userUnit), Tt.publish("putPage", {
            objId: n,
            pageContext: Rt[e],
            pageNumber: e,
            page: r
        }), lt("/Contents " + i + " 0 R"), lt(">>"), lt("endobj");
        var a = r.join("\n");
        return S === x.ADVANCED && (a += "\nQ"), Zt(i, !0), ie({
            data: a,
            filters: ne(),
            objectId: i
        }), lt("endobj"), n;
    }, oe = y.__private__.putPages = function() {
        var t, e, r = [];
        for(t = 1; t <= Dt; t++)Rt[t].objId = Kt(), Rt[t].contentsObjId = Kt();
        for(t = 1; t <= Dt; t++)r.push(ae({
            number: t,
            data: ot[t],
            objId: Rt[t].objId,
            contentsObjId: Rt[t].contentsObjId,
            mediaBox: Rt[t].mediaBox,
            cropBox: Rt[t].cropBox,
            bleedBox: Rt[t].bleedBox,
            trimBox: Rt[t].trimBox,
            artBox: Rt[t].artBox,
            userUnit: Rt[t].userUnit,
            rootDictionaryObjId: Qt,
            resourceDictionaryObjId: te
        }));
        Zt(Qt, !0), lt("<</Type /Pages");
        var n = "/Kids [";
        for(e = 0; e < Dt; e++)n += r[e] + " 0 R ";
        lt(n + "]"), lt("/Count " + Dt), lt(">>"), lt("endobj"), Tt.publish("postPutPages");
    }, se = function(t) {
        Tt.publish("putFont", {
            font: t,
            out: lt,
            newObject: Xt,
            putStream: ie
        }), !0 !== t.isAlreadyPutted && (t.objectNumber = Xt(), lt("<<"), lt("/Type /Font"), lt("/BaseFont /" + F(t.postScriptName)), lt("/Subtype /Type1"), "string" == typeof t.encoding && lt("/Encoding /" + t.encoding), lt("/FirstChar 32"), lt("/LastChar 255"), lt(">>"), lt("endobj"));
    }, ce = function() {
        for(var t in Ft)Ft.hasOwnProperty(t) && (!1 === v || !0 === v && b.hasOwnProperty(t)) && se(Ft[t]);
    }, ue = function(t) {
        t.objectNumber = Xt();
        var e = [];
        e.push({
            key: "Type",
            value: "/XObject"
        }), e.push({
            key: "Subtype",
            value: "/Form"
        }), e.push({
            key: "BBox",
            value: "[" + [
                O(t.x),
                O(t.y),
                O(t.x + t.width),
                O(t.y + t.height)
            ].join(" ") + "]"
        }), e.push({
            key: "Matrix",
            value: "[" + t.matrix.toString() + "]"
        });
        var r = t.pages[1].join("\n");
        ie({
            data: r,
            additionalKeyValues: e,
            objectId: t.objectNumber
        }), lt("endobj");
    }, he = function() {
        for(var t in zt)zt.hasOwnProperty(t) && ue(zt[t]);
    }, le = function(t, e) {
        var r, n = [], i = 1 / (e - 1);
        for(r = 0; r < 1; r += i)n.push(r);
        if (n.push(1), 0 != t[0].offset) {
            var a = {
                offset: 0,
                color: t[0].color
            };
            t.unshift(a);
        }
        if (1 != t[t.length - 1].offset) {
            var o = {
                offset: 1,
                color: t[t.length - 1].color
            };
            t.push(o);
        }
        for(var s = "", c = 0, u = 0; u < n.length; u++){
            for(r = n[u]; r > t[c + 1].offset;)c++;
            var h = t[c].offset, l = (r - h) / (t[c + 1].offset - h), f = t[c].color, d = t[c + 1].color;
            s += tt(Math.round((1 - l) * f[0] + l * d[0]).toString(16)) + tt(Math.round((1 - l) * f[1] + l * d[1]).toString(16)) + tt(Math.round((1 - l) * f[2] + l * d[2]).toString(16));
        }
        return s.trim();
    }, fe = function(t, e) {
        e || (e = 21);
        var r = Xt(), n = le(t.colors, e), i = [];
        i.push({
            key: "FunctionType",
            value: "0"
        }), i.push({
            key: "Domain",
            value: "[0.0 1.0]"
        }), i.push({
            key: "Size",
            value: "[" + e + "]"
        }), i.push({
            key: "BitsPerSample",
            value: "8"
        }), i.push({
            key: "Range",
            value: "[0.0 1.0 0.0 1.0 0.0 1.0]"
        }), i.push({
            key: "Decode",
            value: "[0.0 1.0 0.0 1.0 0.0 1.0]"
        }), ie({
            data: n,
            additionalKeyValues: i,
            alreadyAppliedFilters: [
                "/ASCIIHexDecode"
            ],
            objectId: r
        }), lt("endobj"), t.objectNumber = Xt(), lt("<< /ShadingType " + t.type), lt("/ColorSpace /DeviceRGB");
        var a = "/Coords [" + O(parseFloat(t.coords[0])) + " " + O(parseFloat(t.coords[1])) + " ";
        2 === t.type ? a += O(parseFloat(t.coords[2])) + " " + O(parseFloat(t.coords[3])) : a += O(parseFloat(t.coords[2])) + " " + O(parseFloat(t.coords[3])) + " " + O(parseFloat(t.coords[4])) + " " + O(parseFloat(t.coords[5])), lt(a += "]"), t.matrix && lt("/Matrix [" + t.matrix.toString() + "]"), lt("/Function " + r + " 0 R"), lt("/Extend [true true]"), lt(">>"), lt("endobj");
    }, de = function(t, e) {
        var r = Kt(), n = Xt();
        e.push({
            resourcesOid: r,
            objectOid: n
        }), t.objectNumber = n;
        var i = [];
        i.push({
            key: "Type",
            value: "/Pattern"
        }), i.push({
            key: "PatternType",
            value: "1"
        }), i.push({
            key: "PaintType",
            value: "1"
        }), i.push({
            key: "TilingType",
            value: "1"
        }), i.push({
            key: "BBox",
            value: "[" + t.boundingBox.map(O).join(" ") + "]"
        }), i.push({
            key: "XStep",
            value: O(t.xStep)
        }), i.push({
            key: "YStep",
            value: O(t.yStep)
        }), i.push({
            key: "Resources",
            value: r + " 0 R"
        }), t.matrix && i.push({
            key: "Matrix",
            value: "[" + t.matrix.toString() + "]"
        }), ie({
            data: t.stream,
            additionalKeyValues: i,
            objectId: t.objectNumber
        }), lt("endobj");
    }, pe = function(t) {
        var e;
        for(e in Ot)Ot.hasOwnProperty(e) && (Ot[e] instanceof B ? fe(Ot[e]) : Ot[e] instanceof M && de(Ot[e], t));
    }, ge = function(t) {
        for(var e in t.objectNumber = Xt(), lt("<<"), t)switch(e){
            case "opacity":
                lt("/ca " + R(t[e]));
                break;
            case "stroke-opacity":
                lt("/CA " + R(t[e]));
        }
        lt(">>"), lt("endobj");
    }, me = function() {
        var t;
        for(t in Mt)Mt.hasOwnProperty(t) && ge(Mt[t]);
    }, ve = function() {
        for(var t in lt("/XObject <<"), zt)zt.hasOwnProperty(t) && zt[t].objectNumber >= 0 && lt("/" + t + " " + zt[t].objectNumber + " 0 R");
        Tt.publish("putXobjectDict"), lt(">>");
    }, be = function() {
        Ye.oid = Xt(), lt("<<"), lt("/Filter /Standard"), lt("/V " + Ye.v), lt("/R " + Ye.r), lt("/U <" + Ye.toHexString(Ye.U) + ">"), lt("/O <" + Ye.toHexString(Ye.O) + ">"), lt("/P " + Ye.P), lt(">>"), lt("endobj");
    }, ye = function() {
        for(var t in lt("/Font <<"), Ft)Ft.hasOwnProperty(t) && (!1 === v || !0 === v && b.hasOwnProperty(t)) && lt("/" + t + " " + Ft[t].objectNumber + " 0 R");
        lt(">>");
    }, we = function() {
        if (Object.keys(Ot).length > 0) {
            for(var t in lt("/Shading <<"), Ot)Ot.hasOwnProperty(t) && Ot[t] instanceof B && Ot[t].objectNumber >= 0 && lt("/" + t + " " + Ot[t].objectNumber + " 0 R");
            Tt.publish("putShadingPatternDict"), lt(">>");
        }
    }, Ne = function(t) {
        if (Object.keys(Ot).length > 0) {
            for(var e in lt("/Pattern <<"), Ot)Ot.hasOwnProperty(e) && Ot[e] instanceof y.TilingPattern && Ot[e].objectNumber >= 0 && Ot[e].objectNumber < t && lt("/" + e + " " + Ot[e].objectNumber + " 0 R");
            Tt.publish("putTilingPatternDict"), lt(">>");
        }
    }, Le = function() {
        if (Object.keys(Mt).length > 0) {
            var t;
            for(t in lt("/ExtGState <<"), Mt)Mt.hasOwnProperty(t) && Mt[t].objectNumber >= 0 && lt("/" + t + " " + Mt[t].objectNumber + " 0 R");
            Tt.publish("putGStateDict"), lt(">>");
        }
    }, Ae = function(t) {
        Zt(t.resourcesOid, !0), lt("<<"), lt("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye(), we(), Ne(t.objectOid), Le(), ve(), lt(">>"), lt("endobj");
    }, xe = function() {
        var t = [];
        ce(), me(), he(), pe(t), Tt.publish("putResources"), t.forEach(Ae), Ae({
            resourcesOid: te,
            objectOid: Number.MAX_SAFE_INTEGER
        }), Tt.publish("postPutResources");
    }, Se = function() {
        Tt.publish("putAdditionalObjects");
        for(var t = 0; t < at.length; t++){
            var e = at[t];
            Zt(e.objId, !0), lt(e.content), lt("endobj");
        }
        Tt.publish("postPutAdditionalObjects");
    }, _e = function(t) {
        Ct[t.fontName] = Ct[t.fontName] || {}, Ct[t.fontName][t.fontStyle] = t.id;
    }, Pe = function(t, e, r, n, i) {
        var a = {
            id: "F" + (Object.keys(Ft).length + 1).toString(10),
            postScriptName: t,
            fontName: e,
            fontStyle: r,
            encoding: n,
            isStandardFont: i || !1,
            metadata: {}
        };
        return Tt.publish("addFont", {
            font: a,
            instance: this
        }), Ft[a.id] = a, _e(a), a.id;
    }, ke = function(t) {
        for(var e = 0, r = pt.length; e < r; e++){
            var n = Pe.call(this, t[e][0], t[e][1], t[e][2], pt[e][3], !0);
            !1 === v && (b[n] = !0);
            var i = t[e][0].split("-");
            _e({
                id: n,
                fontName: i[0],
                fontStyle: i[1] || ""
            });
        }
        Tt.publish("addFonts", {
            fonts: Ft,
            dictionary: Ct
        });
    }, Ie = function(t) {
        return t.foo = function() {
            try {
                return t.apply(this, arguments);
            } catch (t) {
                var e = t.stack || "";
                ~e.indexOf(" at ") && (e = e.split(" at ")[1]);
                var r = "Error in function " + e.split("\n")[0].split("<")[0] + ": " + t.message;
                if (!n.console) throw new Error(r);
                n.console.error(r, t), n.alert && alert(r);
            }
        }, t.foo.bar = t, t.foo;
    }, Fe = function(t, e) {
        var r, n, i, a, o, s, c, u, h;
        if (i = (e = e || {}).sourceEncoding || "Unicode", o = e.outputEncoding, (e.autoencode || o) && Ft[St].metadata && Ft[St].metadata[i] && Ft[St].metadata[i].encoding && (a = Ft[St].metadata[i].encoding, !o && Ft[St].encoding && (o = Ft[St].encoding), !o && a.codePages && (o = a.codePages[0]), "string" == typeof o && (o = a[o]), o)) {
            for(c = !1, s = [], r = 0, n = t.length; r < n; r++)(u = o[t.charCodeAt(r)]) ? s.push(String.fromCharCode(u)) : s.push(t[r]), s[r].charCodeAt(0) >> 8 && (c = !0);
            t = s.join("");
        }
        for(r = t.length; void 0 === c && 0 !== r;)t.charCodeAt(r - 1) >> 8 && (c = !0), r--;
        if (!c) return t;
        for(s = e.noBOM ? [] : [
            254,
            255
        ], r = 0, n = t.length; r < n; r++){
            if ((h = (u = t.charCodeAt(r)) >> 8) >> 8) throw new Error("Character at position " + r + " of string '" + t + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
            s.push(h), s.push(u - (h << 8));
        }
        return String.fromCharCode.apply(void 0, s);
    }, Ce = y.__private__.pdfEscape = y.pdfEscape = function(t, e) {
        return Fe(t, e).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
    }, je = y.__private__.beginPage = function(t) {
        ot[++Dt] = [], Rt[Dt] = {
            objId: 0,
            contentsObjId: 0,
            userUnit: Number(d),
            artBox: null,
            bleedBox: null,
            cropBox: null,
            trimBox: null,
            mediaBox: {
                bottomLeftX: 0,
                bottomLeftY: 0,
                topRightX: Number(t[0]),
                topRightY: Number(t[1])
            }
        }, Me(Dt), ht(ot[$]);
    }, Oe = function(t, e) {
        var r, n, o;
        switch(i = e || i, "string" == typeof t && (r = A(t.toLowerCase()), Array.isArray(r) && (n = r[0], o = r[1])), Array.isArray(t) && (n = t[0] * _t, o = t[1] * _t), isNaN(n) && (n = s[0], o = s[1]), (n > 14400 || o > 14400) && (a.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n = Math.min(14400, n), o = Math.min(14400, o)), s = [
            n,
            o
        ], i.substr(0, 1)){
            case "l":
                o > n && (s = [
                    o,
                    n
                ]);
                break;
            case "p":
                n > o && (s = [
                    o,
                    n
                ]);
        }
        je(s), pr(fr), lt(Lr), 0 !== kr && lt(kr + " J"), 0 !== Ir && lt(Ir + " j"), Tt.publish("addPage", {
            pageNumber: Dt
        });
    }, Be = function(t) {
        t > 0 && t <= Dt && (ot.splice(t, 1), Rt.splice(t, 1), Dt--, $ > Dt && ($ = Dt), this.setPage($));
    }, Me = function(t) {
        t > 0 && t <= Dt && ($ = t);
    }, Ee = y.__private__.getNumberOfPages = y.getNumberOfPages = function() {
        return ot.length - 1;
    }, qe = function(t, e, r) {
        var n, i = void 0;
        return r = r || {}, t = void 0 !== t ? t : Ft[St].fontName, e = void 0 !== e ? e : Ft[St].fontStyle, n = t.toLowerCase(), void 0 !== Ct[n] && void 0 !== Ct[n][e] ? i = Ct[n][e] : void 0 !== Ct[t] && void 0 !== Ct[t][e] ? i = Ct[t][e] : !1 === r.disableWarning && a.warn("Unable to look up font label for font '" + t + "', '" + e + "'. Refer to getFontList() for available fonts."), i || r.noFallback || null == (i = Ct.times[e]) && (i = Ct.times.normal), i;
    }, De = y.__private__.putInfo = function() {
        var t = Xt(), e = function(t) {
            return t;
        };
        for(var r in null !== m && (e = Ye.encryptor(t, 0)), lt("<<"), lt("/Producer (" + Ce(e("jsPDF " + E.version)) + ")"), xt)xt.hasOwnProperty(r) && xt[r] && lt("/" + r.substr(0, 1).toUpperCase() + r.substr(1) + " (" + Ce(e(xt[r])) + ")");
        lt("/CreationDate (" + Ce(e(W)) + ")"), lt(">>"), lt("endobj");
    }, Re = y.__private__.putCatalog = function(t) {
        var e = (t = t || {}).rootDictionaryObjId || Qt;
        switch(Xt(), lt("<<"), lt("/Type /Catalog"), lt("/Pages " + e + " 0 R"), mt || (mt = "fullwidth"), mt){
            case "fullwidth":
                lt("/OpenAction [3 0 R /FitH null]");
                break;
            case "fullheight":
                lt("/OpenAction [3 0 R /FitV null]");
                break;
            case "fullpage":
                lt("/OpenAction [3 0 R /Fit]");
                break;
            case "original":
                lt("/OpenAction [3 0 R /XYZ null null 1]");
                break;
            default:
                var r = "" + mt;
                "%" === r.substr(r.length - 1) && (mt = parseInt(mt) / 100), "number" == typeof mt && lt("/OpenAction [3 0 R /XYZ null null " + R(mt) + "]");
        }
        switch(Nt || (Nt = "continuous"), Nt){
            case "continuous":
                lt("/PageLayout /OneColumn");
                break;
            case "single":
                lt("/PageLayout /SinglePage");
                break;
            case "two":
            case "twoleft":
                lt("/PageLayout /TwoColumnLeft");
                break;
            case "tworight":
                lt("/PageLayout /TwoColumnRight");
        }
        yt && lt("/PageMode /" + yt), Tt.publish("putCatalog"), lt(">>"), lt("endobj");
    }, Te = y.__private__.putTrailer = function() {
        lt("trailer"), lt("<<"), lt("/Size " + (et + 1)), lt("/Root " + et + " 0 R"), lt("/Info " + (et - 1) + " 0 R"), null !== m && lt("/Encrypt " + Ye.oid + " 0 R"), lt("/ID [ <" + V + "> <" + V + "> ]"), lt(">>");
    }, Ue = y.__private__.putHeader = function() {
        lt("%PDF-" + w), lt("%\xba\xdf\xac\xe0");
    }, ze = y.__private__.putXRef = function() {
        var t = "0000000000";
        lt("xref"), lt("0 " + (et + 1)), lt("0000000000 65535 f ");
        for(var e = 1; e <= et; e++)"function" == typeof rt[e] ? lt((t + rt[e]()).slice(-10) + " 00000 n ") : void 0 !== rt[e] ? lt((t + rt[e]).slice(-10) + " 00000 n ") : lt("0000000000 00000 n ");
    }, He = y.__private__.buildDocument = function() {
        ut(), ht(nt), Tt.publish("buildDocument"), Ue(), oe(), Se(), xe(), null !== m && be(), De(), Re();
        var t = it;
        return ze(), Te(), lt("startxref"), lt("" + t), lt("%%EOF"), ht(ot[$]), nt.join("\n");
    }, We = y.__private__.getBlob = function(t) {
        return new Blob([
            dt(t)
        ], {
            type: "application/pdf"
        });
    }, Ve = y.output = y.__private__.output = Ie(function(t, e) {
        switch("string" == typeof (e = e || {}) ? e = {
            filename: e
        } : e.filename = e.filename || "generated.pdf", t){
            case void 0:
                return He();
            case "save":
                y.save(e.filename);
                break;
            case "arraybuffer":
                return dt(He());
            case "blob":
                return We(He());
            case "bloburi":
            case "bloburl":
                if (void 0 !== n.URL && "function" == typeof n.URL.createObjectURL) return n.URL && n.URL.createObjectURL(We(He())) || void 0;
                a.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
                break;
            case "datauristring":
            case "dataurlstring":
                var r = "", i = He();
                try {
                    r = h(i);
                } catch (t) {
                    r = h(unescape(encodeURIComponent(i)));
                }
                return "data:application/pdf;filename=" + e.filename + ";base64," + r;
            case "pdfobjectnewwindow":
                if ("[object Window]" === Object.prototype.toString.call(n)) {
                    var o = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
                    e.pdfObjectUrl && (o = e.pdfObjectUrl, s = "");
                    var c = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o + '"' + s + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e) + ");<\/script></body></html>", u = n.open();
                    return null !== u && u.document.write(c), u;
                }
                throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
            case "pdfjsnewwindow":
                if ("[object Window]" === Object.prototype.toString.call(n)) {
                    var l = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e.filename + '" width="500px" height="400px" /></body></html>', f = n.open();
                    if (null !== f) {
                        f.document.write(l);
                        var d = this;
                        f.document.documentElement.querySelector("#pdfViewer").onload = function() {
                            f.document.title = e.filename, f.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d.output("bloburl"));
                        };
                    }
                    return f;
                }
                throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
            case "dataurlnewwindow":
                if ("[object Window]" !== Object.prototype.toString.call(n)) throw new Error("The option dataurlnewwindow just works in a browser-environment.");
                var p = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e) + '"></iframe></body></html>', g = n.open();
                if (null !== g && (g.document.write(p), g.document.title = e.filename), g || "undefined" == typeof safari) return g;
                break;
            case "datauri":
            case "dataurl":
                return n.document.location.href = this.output("datauristring", e);
            default:
                return null;
        }
    }), Ge = function(t) {
        return !0 === Array.isArray(Ut) && Ut.indexOf(t) > -1;
    };
    switch(o){
        case "pt":
            _t = 1;
            break;
        case "mm":
            _t = 72 / 25.4;
            break;
        case "cm":
            _t = 72 / 2.54;
            break;
        case "in":
            _t = 72;
            break;
        case "px":
            _t = 1 == Ge("px_scaling") ? .75 : 96 / 72;
            break;
        case "pc":
        case "em":
            _t = 12;
            break;
        case "ex":
            _t = 6;
            break;
        default:
            if ("number" != typeof o) throw new Error("Invalid unit: " + o);
            _t = o;
    }
    var Ye = null;
    K(), Y();
    var Je = function(t) {
        return null !== m ? Ye.encryptor(t, 0) : function(t) {
            return t;
        };
    }, Xe = y.__private__.getPageInfo = y.getPageInfo = function(t) {
        if (isNaN(t) || t % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
        return {
            objId: Rt[t].objId,
            pageNumber: t,
            pageContext: Rt[t]
        };
    }, Ke = y.__private__.getPageInfoByObjId = function(t) {
        if (isNaN(t) || t % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
        for(var e in Rt)if (Rt[e].objId === t) break;
        return Xe(e);
    }, Ze = y.__private__.getCurrentPageInfo = y.getCurrentPageInfo = function() {
        return {
            objId: Rt[$].objId,
            pageNumber: $,
            pageContext: Rt[$]
        };
    };
    y.addPage = function() {
        return Oe.apply(this, arguments), this;
    }, y.setPage = function() {
        return Me.apply(this, arguments), ht.call(this, ot[$]), this;
    }, y.insertPage = function(t) {
        return this.addPage(), this.movePage($, t), this;
    }, y.movePage = function(t, e) {
        var r, n;
        if (t > e) {
            r = ot[t], n = Rt[t];
            for(var i = t; i > e; i--)ot[i] = ot[i - 1], Rt[i] = Rt[i - 1];
            ot[e] = r, Rt[e] = n, this.setPage(e);
        } else if (t < e) {
            r = ot[t], n = Rt[t];
            for(var a = t; a < e; a++)ot[a] = ot[a + 1], Rt[a] = Rt[a + 1];
            ot[e] = r, Rt[e] = n, this.setPage(e);
        }
        return this;
    }, y.deletePage = function() {
        return Be.apply(this, arguments), this;
    }, y.__private__.text = y.text = function(e, r, n, i, a) {
        var o, s, c, u, h, l, f, d, p, g = (i = i || {}).scope || this;
        if ("number" == typeof e && "number" == typeof r && ("string" == typeof n || Array.isArray(n))) {
            var m = n;
            n = r, r = e, e = m;
        }
        if (arguments[3] instanceof Vt == !1 ? (c = arguments[4], u = arguments[5], "object" === (0, _typeofDefault.default)(f = arguments[3]) && null !== f || ("string" == typeof c && (u = c, c = null), "string" == typeof f && (u = f, f = null), "number" == typeof f && (c = f, f = null), i = {
            flags: f,
            angle: c,
            align: u
        })) : (q("The transform parameter of text() with a Matrix value"), p = a), isNaN(r) || isNaN(n) || null == e) throw new Error("Invalid arguments passed to jsPDF.text");
        if (0 === e.length) return g;
        var v = "", y = !1, w = "number" == typeof i.lineHeightFactor ? i.lineHeightFactor : lr, N = g.internal.scaleFactor;
        function L(t) {
            return t = t.split("\t").join(Array(i.TabLen || 9).join(" ")), Ce(t, f);
        }
        function A(t) {
            for(var e, r = t.concat(), n = [], i = r.length; i--;)"string" == typeof (e = r.shift()) ? n.push(e) : Array.isArray(t) && (1 === e.length || void 0 === e[1] && void 0 === e[2]) ? n.push(e[0]) : n.push([
                e[0],
                e[1],
                e[2]
            ]);
            return n;
        }
        function _(t, e) {
            var r;
            if ("string" == typeof t) r = e(t)[0];
            else if (Array.isArray(t)) {
                for(var n, i, a = t.concat(), o = [], s = a.length; s--;)"string" == typeof (n = a.shift()) ? o.push(e(n)[0]) : Array.isArray(n) && "string" == typeof n[0] && (i = e(n[0], n[1], n[2]), o.push([
                    i[0],
                    i[1],
                    i[2]
                ]));
                r = o;
            }
            return r;
        }
        var P = !1, k = !0;
        if ("string" == typeof e) P = !0;
        else if (Array.isArray(e)) {
            var I = e.concat();
            s = [];
            for(var F, C = I.length; C--;)("string" != typeof (F = I.shift()) || Array.isArray(F) && "string" != typeof F[0]) && (k = !1);
            P = k;
        }
        if (!1 === P) throw new Error('Type of text must be string or Array. "' + e + '" is not recognized.');
        "string" == typeof e && (e = e.match(/[\r?\n]/) ? e.split(/\r\n|\r|\n/g) : [
            e
        ]);
        var j = gt / g.internal.scaleFactor, B = j * (w - 1);
        switch(i.baseline){
            case "bottom":
                n -= B;
                break;
            case "top":
                n += j - B;
                break;
            case "hanging":
                n += j - 2 * B;
                break;
            case "middle":
                n += j / 2 - B;
        }
        if ((l = i.maxWidth || 0) > 0 && ("string" == typeof e ? e = g.splitTextToSize(e, l) : "[object Array]" === Object.prototype.toString.call(e) && (e = e.reduce(function(t, e) {
            return t.concat(g.splitTextToSize(e, l));
        }, []))), o = {
            text: e,
            x: r,
            y: n,
            options: i,
            mutex: {
                pdfEscape: Ce,
                activeFontKey: St,
                fonts: Ft,
                activeFontSize: gt
            }
        }, Tt.publish("preProcessText", o), e = o.text, c = (i = o.options).angle, p instanceof Vt == !1 && c && "number" == typeof c) {
            c *= Math.PI / 180, 0 === i.rotationDirection && (c = -c), S === x.ADVANCED && (c = -c);
            var M = Math.cos(c), E = Math.sin(c);
            p = new Vt(M, E, -E, M, 0, 0);
        } else c && c instanceof Vt && (p = c);
        S !== x.ADVANCED || p || (p = Yt), void 0 !== (h = i.charSpace || _r) && (v += O(U(h)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d = i.horizontalScale) && (v += O(100 * d) + " Tz\n");
        i.lang;
        var D = -1, R = void 0 !== i.renderingMode ? i.renderingMode : i.stroke, T = g.internal.getCurrentPageInfo().pageContext;
        switch(R){
            case 0:
            case !1:
            case "fill":
                D = 0;
                break;
            case 1:
            case !0:
            case "stroke":
                D = 1;
                break;
            case 2:
            case "fillThenStroke":
                D = 2;
                break;
            case 3:
            case "invisible":
                D = 3;
                break;
            case 4:
            case "fillAndAddForClipping":
                D = 4;
                break;
            case 5:
            case "strokeAndAddPathForClipping":
                D = 5;
                break;
            case 6:
            case "fillThenStrokeAndAddToPathForClipping":
                D = 6;
                break;
            case 7:
            case "addToPathForClipping":
                D = 7;
        }
        var z = void 0 !== T.usedRenderingMode ? T.usedRenderingMode : -1;
        -1 !== D ? v += D + " Tr\n" : -1 !== z && (v += "0 Tr\n"), -1 !== D && (T.usedRenderingMode = D), u = i.align || "left";
        var H, W = gt * w, V = g.internal.pageSize.getWidth(), G = Ft[St];
        h = i.charSpace || _r, l = i.maxWidth || 0, f = Object.assign({
            autoencode: !0,
            noBOM: !0
        }, i.flags);
        var Y = [], J = function(t) {
            return g.getStringUnitWidth(t, {
                font: G,
                charSpace: h,
                fontSize: gt,
                doKerning: !1
            }) * gt / N;
        };
        if ("[object Array]" === Object.prototype.toString.call(e)) {
            var X;
            s = A(e), "left" !== u && (H = s.map(J));
            var K, Z = 0;
            if ("right" === u) {
                r -= H[0], e = [], C = s.length;
                for(var $ = 0; $ < C; $++)0 === $ ? (K = br(r), X = yr(n)) : (K = U(Z - H[$]), X = -W), e.push([
                    s[$],
                    K,
                    X
                ]), Z = H[$];
            } else if ("center" === u) {
                r -= H[0] / 2, e = [], C = s.length;
                for(var Q = 0; Q < C; Q++)0 === Q ? (K = br(r), X = yr(n)) : (K = U((Z - H[Q]) / 2), X = -W), e.push([
                    s[Q],
                    K,
                    X
                ]), Z = H[Q];
            } else if ("left" === u) {
                e = [], C = s.length;
                for(var tt = 0; tt < C; tt++)e.push(s[tt]);
            } else if ("justify" === u && "Identity-H" === G.encoding) {
                e = [], C = s.length, l = 0 !== l ? l : V;
                for(var et = 0, rt = 0; rt < C; rt++)if (X = 0 === rt ? yr(n) : -W, K = 0 === rt ? br(r) : et, rt < C - 1) {
                    var nt = U((l - H[rt]) / (s[rt].split(" ").length - 1)), it = s[rt].split(" ");
                    e.push([
                        it[0] + " ",
                        K,
                        X
                    ]), et = 0;
                    for(var at = 1; at < it.length; at++){
                        var ot = (J(it[at - 1] + " " + it[at]) - J(it[at])) * N + nt;
                        at == it.length - 1 ? e.push([
                            it[at],
                            ot,
                            0
                        ]) : e.push([
                            it[at] + " ",
                            ot,
                            0
                        ]), et -= ot;
                    }
                } else e.push([
                    s[rt],
                    K,
                    X
                ]);
                e.push([
                    "",
                    et,
                    0
                ]);
            } else {
                if ("justify" !== u) throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
                e = [], C = s.length, l = 0 !== l ? l : V;
                for(rt = 0; rt < C; rt++)X = 0 === rt ? yr(n) : -W, K = 0 === rt ? br(r) : 0, rt < C - 1 ? Y.push(O(U((l - H[rt]) / (s[rt].split(" ").length - 1)))) : Y.push(0), e.push([
                    s[rt],
                    K,
                    X
                ]);
            }
        }
        var st = "boolean" == typeof i.R2L ? i.R2L : bt;
        !0 === st && (e = _(e, function(t, e, r) {
            return [
                t.split("").reverse().join(""),
                e,
                r
            ];
        })), o = {
            text: e,
            x: r,
            y: n,
            options: i,
            mutex: {
                pdfEscape: Ce,
                activeFontKey: St,
                fonts: Ft,
                activeFontSize: gt
            }
        }, Tt.publish("postProcessText", o), e = o.text, y = o.mutex.isHex || !1;
        var ct = Ft[St].encoding;
        "WinAnsiEncoding" !== ct && "StandardEncoding" !== ct || (e = _(e, function(t, e, r) {
            return [
                L(t),
                e,
                r
            ];
        })), s = A(e), e = [];
        for(var ut, ht, ft, dt = 0, pt = 1, mt = Array.isArray(s[0]) ? pt : dt, vt = "", yt = function(t, e, r) {
            var n = "";
            return r instanceof Vt ? (r = "number" == typeof i.angle ? Gt(r, new Vt(1, 0, 0, 1, t, e)) : Gt(new Vt(1, 0, 0, 1, t, e), r), S === x.ADVANCED && (r = Gt(new Vt(1, 0, 0, -1, 0, 0), r)), n = r.join(" ") + " Tm\n") : n = O(t) + " " + O(e) + " Td\n", n;
        }, wt = 0; wt < s.length; wt++){
            switch(vt = "", mt){
                case pt:
                    ft = (y ? "<" : "(") + s[wt][0] + (y ? ">" : ")"), ut = parseFloat(s[wt][1]), ht = parseFloat(s[wt][2]);
                    break;
                case dt:
                    ft = (y ? "<" : "(") + s[wt] + (y ? ">" : ")"), ut = br(r), ht = yr(n);
            }
            void 0 !== Y && void 0 !== Y[wt] && (vt = Y[wt] + " Tw\n"), 0 === wt ? e.push(vt + yt(ut, ht, p) + ft) : mt === dt ? e.push(vt + ft) : mt === pt && e.push(vt + yt(ut, ht, p) + ft);
        }
        e = mt === dt ? e.join(" Tj\nT* ") : e.join(" Tj\n"), e += " Tj\n";
        var Nt = "BT\n/";
        return Nt += St + " " + gt + " Tf\n", Nt += O(gt * w) + " TL\n", Nt += xr + "\n", Nt += v, Nt += e, lt(Nt += "ET"), b[St] = !0, g;
    };
    var $e = y.__private__.clip = y.clip = function(t) {
        return lt("evenodd" === t ? "W*" : "W"), this;
    };
    y.clipEvenOdd = function() {
        return $e("evenodd");
    }, y.__private__.discardPath = y.discardPath = function() {
        return lt("n"), this;
    };
    var Qe = y.__private__.isValidStyle = function(t) {
        var e = !1;
        return -1 !== [
            void 0,
            null,
            "S",
            "D",
            "F",
            "DF",
            "FD",
            "f",
            "f*",
            "B",
            "B*",
            "n"
        ].indexOf(t) && (e = !0), e;
    };
    y.__private__.setDefaultPathOperation = y.setDefaultPathOperation = function(t) {
        return Qe(t) && (g = t), this;
    };
    var tr = y.__private__.getStyle = y.getStyle = function(t) {
        var e = g;
        switch(t){
            case "D":
            case "S":
                e = "S";
                break;
            case "F":
                e = "f";
                break;
            case "FD":
            case "DF":
                e = "B";
                break;
            case "f":
            case "f*":
            case "B":
            case "B*":
                e = t;
        }
        return e;
    }, er = y.close = function() {
        return lt("h"), this;
    };
    y.stroke = function() {
        return lt("S"), this;
    }, y.fill = function(t) {
        return rr("f", t), this;
    }, y.fillEvenOdd = function(t) {
        return rr("f*", t), this;
    }, y.fillStroke = function(t) {
        return rr("B", t), this;
    }, y.fillStrokeEvenOdd = function(t) {
        return rr("B*", t), this;
    };
    var rr = function(e, r) {
        "object" === (0, _typeofDefault.default)(r) ? ar(r, e) : lt(e);
    }, nr = function(t) {
        null === t || S === x.ADVANCED && void 0 === t || (t = tr(t), lt(t));
    };
    function ir(t, e, r, n, i) {
        var a = new M(e || this.boundingBox, r || this.xStep, n || this.yStep, this.gState, i || this.matrix);
        a.stream = this.stream;
        var o = t + "$$" + this.cloneIndex++ + "$$";
        return Jt(o, a), a;
    }
    var ar = function(t, e) {
        var r = Bt[t.key], n = Ot[r];
        if (n instanceof B) lt("q"), lt(or(e)), n.gState && y.setGState(n.gState), lt(t.matrix.toString() + " cm"), lt("/" + r + " sh"), lt("Q");
        else if (n instanceof M) {
            var i = new Vt(1, 0, 0, -1, 0, Rr());
            t.matrix && (i = i.multiply(t.matrix || Yt), r = ir.call(n, t.key, t.boundingBox, t.xStep, t.yStep, i).id), lt("q"), lt("/Pattern cs"), lt("/" + r + " scn"), n.gState && y.setGState(n.gState), lt(e), lt("Q");
        }
    }, or = function(t) {
        switch(t){
            case "f":
            case "F":
                return "W n";
            case "f*":
                return "W* n";
            case "B":
                return "W S";
            case "B*":
                return "W* S";
            case "S":
                return "W S";
            case "n":
                return "W n";
        }
    }, sr = y.moveTo = function(t, e) {
        return lt(O(U(t)) + " " + O(H(e)) + " m"), this;
    }, cr = y.lineTo = function(t, e) {
        return lt(O(U(t)) + " " + O(H(e)) + " l"), this;
    }, ur = y.curveTo = function(t, e, r, n, i, a) {
        return lt([
            O(U(t)),
            O(H(e)),
            O(U(r)),
            O(H(n)),
            O(U(i)),
            O(H(a)),
            "c"
        ].join(" ")), this;
    };
    y.__private__.line = y.line = function(t, e, r, n, i) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n) || !Qe(i)) throw new Error("Invalid arguments passed to jsPDF.line");
        return S === x.COMPAT ? this.lines([
            [
                r - t,
                n - e
            ]
        ], t, e, [
            1,
            1
        ], i || "S") : this.lines([
            [
                r - t,
                n - e
            ]
        ], t, e, [
            1,
            1
        ]).stroke();
    }, y.__private__.lines = y.lines = function(t, e, r, n, i, a) {
        var o, s, c, u, h, l, f, d, p, g, m, v;
        if ("number" == typeof t && (v = r, r = e, e = t, t = v), n = n || [
            1,
            1
        ], a = a || !1, isNaN(e) || isNaN(r) || !Array.isArray(t) || !Array.isArray(n) || !Qe(i) || "boolean" != typeof a) throw new Error("Invalid arguments passed to jsPDF.lines");
        for(sr(e, r), o = n[0], s = n[1], u = t.length, g = e, m = r, c = 0; c < u; c++)2 === (h = t[c]).length ? (g = h[0] * o + g, m = h[1] * s + m, cr(g, m)) : (l = h[0] * o + g, f = h[1] * s + m, d = h[2] * o + g, p = h[3] * s + m, g = h[4] * o + g, m = h[5] * s + m, ur(l, f, d, p, g, m));
        return a && er(), nr(i), this;
    }, y.path = function(t) {
        for(var e = 0; e < t.length; e++){
            var r = t[e], n = r.c;
            switch(r.op){
                case "m":
                    sr(n[0], n[1]);
                    break;
                case "l":
                    cr(n[0], n[1]);
                    break;
                case "c":
                    ur.apply(this, n);
                    break;
                case "h":
                    er();
            }
        }
        return this;
    }, y.__private__.rect = y.rect = function(t, e, r, n, i) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n) || !Qe(i)) throw new Error("Invalid arguments passed to jsPDF.rect");
        return S === x.COMPAT && (n = -n), lt([
            O(U(t)),
            O(H(e)),
            O(U(r)),
            O(U(n)),
            "re"
        ].join(" ")), nr(i), this;
    }, y.__private__.triangle = y.triangle = function(t, e, r, n, i, a, o) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n) || isNaN(i) || isNaN(a) || !Qe(o)) throw new Error("Invalid arguments passed to jsPDF.triangle");
        return this.lines([
            [
                r - t,
                n - e
            ],
            [
                i - r,
                a - n
            ],
            [
                t - i,
                e - a
            ]
        ], t, e, [
            1,
            1
        ], o, !0), this;
    }, y.__private__.roundedRect = y.roundedRect = function(t, e, r, n, i, a, o) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n) || isNaN(i) || isNaN(a) || !Qe(o)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
        var s = 4 / 3 * (Math.SQRT2 - 1);
        return i = Math.min(i, .5 * r), a = Math.min(a, .5 * n), this.lines([
            [
                r - 2 * i,
                0
            ],
            [
                i * s,
                0,
                i,
                a - a * s,
                i,
                a
            ],
            [
                0,
                n - 2 * a
            ],
            [
                0,
                a * s,
                -i * s,
                a,
                -i,
                a
            ],
            [
                2 * i - r,
                0
            ],
            [
                -i * s,
                0,
                -i,
                -a * s,
                -i,
                -a
            ],
            [
                0,
                2 * a - n
            ],
            [
                0,
                -a * s,
                i * s,
                -a,
                i,
                -a
            ]
        ], t + i, e, [
            1,
            1
        ], o, !0), this;
    }, y.__private__.ellipse = y.ellipse = function(t, e, r, n, i) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n) || !Qe(i)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
        var a = 4 / 3 * (Math.SQRT2 - 1) * r, o = 4 / 3 * (Math.SQRT2 - 1) * n;
        return sr(t + r, e), ur(t + r, e - o, t + a, e - n, t, e - n), ur(t - a, e - n, t - r, e - o, t - r, e), ur(t - r, e + o, t - a, e + n, t, e + n), ur(t + a, e + n, t + r, e + o, t + r, e), nr(i), this;
    }, y.__private__.circle = y.circle = function(t, e, r, n) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || !Qe(n)) throw new Error("Invalid arguments passed to jsPDF.circle");
        return this.ellipse(t, e, r, r, n);
    }, y.setFont = function(t, e, r) {
        return r && (e = k(e, r)), St = qe(t, e, {
            disableWarning: !1
        }), this;
    };
    var hr = y.__private__.getFont = y.getFont = function() {
        return Ft[qe.apply(y, arguments)];
    };
    y.__private__.getFontList = y.getFontList = function() {
        var t, e, r = {};
        for(t in Ct)if (Ct.hasOwnProperty(t)) for(e in r[t] = [], Ct[t])Ct[t].hasOwnProperty(e) && r[t].push(e);
        return r;
    }, y.addFont = function(t, e, r, n, i) {
        var a = [
            "StandardEncoding",
            "MacRomanEncoding",
            "Identity-H",
            "WinAnsiEncoding"
        ];
        return arguments[3] && -1 !== a.indexOf(arguments[3]) ? i = arguments[3] : arguments[3] && -1 == a.indexOf(arguments[3]) && (r = k(r, n)), i = i || "Identity-H", Pe.call(this, t, e, r, i);
    };
    var lr, fr = e.lineWidth || .200025, dr = y.__private__.getLineWidth = y.getLineWidth = function() {
        return fr;
    }, pr = y.__private__.setLineWidth = y.setLineWidth = function(t) {
        return fr = t, lt(O(U(t)) + " w"), this;
    };
    y.__private__.setLineDash = E.API.setLineDash = E.API.setLineDashPattern = function(t, e) {
        if (t = t || [], e = e || 0, isNaN(e) || !Array.isArray(t)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
        return t = t.map(function(t) {
            return O(U(t));
        }).join(" "), e = O(U(e)), lt("[" + t + "] " + e + " d"), this;
    };
    var gr = y.__private__.getLineHeight = y.getLineHeight = function() {
        return gt * lr;
    };
    y.__private__.getLineHeight = y.getLineHeight = function() {
        return gt * lr;
    };
    var mr = y.__private__.setLineHeightFactor = y.setLineHeightFactor = function(t) {
        return "number" == typeof (t = t || 1.15) && (lr = t), this;
    }, vr = y.__private__.getLineHeightFactor = y.getLineHeightFactor = function() {
        return lr;
    };
    mr(e.lineHeight);
    var br = y.__private__.getHorizontalCoordinate = function(t) {
        return U(t);
    }, yr = y.__private__.getVerticalCoordinate = function(t) {
        return S === x.ADVANCED ? t : Rt[$].mediaBox.topRightY - Rt[$].mediaBox.bottomLeftY - U(t);
    }, wr = y.__private__.getHorizontalCoordinateString = y.getHorizontalCoordinateString = function(t) {
        return O(br(t));
    }, Nr = y.__private__.getVerticalCoordinateString = y.getVerticalCoordinateString = function(t) {
        return O(yr(t));
    }, Lr = e.strokeColor || "0 G";
    y.__private__.getStrokeColor = y.getDrawColor = function() {
        return ee(Lr);
    }, y.__private__.setStrokeColor = y.setDrawColor = function(t, e, r, n) {
        return Lr = re({
            ch1: t,
            ch2: e,
            ch3: r,
            ch4: n,
            pdfColorType: "draw",
            precision: 2
        }), lt(Lr), this;
    };
    var Ar = e.fillColor || "0 g";
    y.__private__.getFillColor = y.getFillColor = function() {
        return ee(Ar);
    }, y.__private__.setFillColor = y.setFillColor = function(t, e, r, n) {
        return Ar = re({
            ch1: t,
            ch2: e,
            ch3: r,
            ch4: n,
            pdfColorType: "fill",
            precision: 2
        }), lt(Ar), this;
    };
    var xr = e.textColor || "0 g", Sr = y.__private__.getTextColor = y.getTextColor = function() {
        return ee(xr);
    };
    y.__private__.setTextColor = y.setTextColor = function(t, e, r, n) {
        return xr = re({
            ch1: t,
            ch2: e,
            ch3: r,
            ch4: n,
            pdfColorType: "text",
            precision: 3
        }), this;
    };
    var _r = e.charSpace, Pr = y.__private__.getCharSpace = y.getCharSpace = function() {
        return parseFloat(_r || 0);
    };
    y.__private__.setCharSpace = y.setCharSpace = function(t) {
        if (isNaN(t)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
        return _r = t, this;
    };
    var kr = 0;
    y.CapJoinStyles = {
        0: 0,
        butt: 0,
        but: 0,
        miter: 0,
        1: 1,
        round: 1,
        rounded: 1,
        circle: 1,
        2: 2,
        projecting: 2,
        project: 2,
        square: 2,
        bevel: 2
    }, y.__private__.setLineCap = y.setLineCap = function(t) {
        var e = y.CapJoinStyles[t];
        if (void 0 === e) throw new Error("Line cap style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
        return kr = e, lt(e + " J"), this;
    };
    var Ir = 0;
    y.__private__.setLineJoin = y.setLineJoin = function(t) {
        var e = y.CapJoinStyles[t];
        if (void 0 === e) throw new Error("Line join style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
        return Ir = e, lt(e + " j"), this;
    }, y.__private__.setLineMiterLimit = y.__private__.setMiterLimit = y.setLineMiterLimit = y.setMiterLimit = function(t) {
        if (t = t || 0, isNaN(t)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
        return lt(O(U(t)) + " M"), this;
    }, y.GState = j, y.setGState = function(t) {
        (t = "string" == typeof t ? Mt[Et[t]] : Fr(null, t)).equals(qt) || (lt("/" + t.id + " gs"), qt = t);
    };
    var Fr = function(t, e) {
        if (!t || !Et[t]) {
            var r = !1;
            for(var n in Mt)if (Mt.hasOwnProperty(n) && Mt[n].equals(e)) {
                r = !0;
                break;
            }
            if (r) e = Mt[n];
            else {
                var i = "GS" + (Object.keys(Mt).length + 1).toString(10);
                Mt[i] = e, e.id = i;
            }
            return t && (Et[t] = e.id), Tt.publish("addGState", e), e;
        }
    };
    y.addGState = function(t, e) {
        return Fr(t, e), this;
    }, y.saveGraphicsState = function() {
        return lt("q"), jt.push({
            key: St,
            size: gt,
            color: xr
        }), this;
    }, y.restoreGraphicsState = function() {
        lt("Q");
        var t = jt.pop();
        return St = t.key, gt = t.size, xr = t.color, qt = null, this;
    }, y.setCurrentTransformationMatrix = function(t) {
        return lt(t.toString() + " cm"), this;
    }, y.comment = function(t) {
        return lt("#" + t), this;
    };
    var Cr = function(t, e) {
        var r = t || 0;
        Object.defineProperty(this, "x", {
            enumerable: !0,
            get: function() {
                return r;
            },
            set: function(t) {
                isNaN(t) || (r = parseFloat(t));
            }
        });
        var n = e || 0;
        Object.defineProperty(this, "y", {
            enumerable: !0,
            get: function() {
                return n;
            },
            set: function(t) {
                isNaN(t) || (n = parseFloat(t));
            }
        });
        var i = "pt";
        return Object.defineProperty(this, "type", {
            enumerable: !0,
            get: function() {
                return i;
            },
            set: function(t) {
                i = t.toString();
            }
        }), this;
    }, jr = function(t, e, r, n) {
        Cr.call(this, t, e), this.type = "rect";
        var i = r || 0;
        Object.defineProperty(this, "w", {
            enumerable: !0,
            get: function() {
                return i;
            },
            set: function(t) {
                isNaN(t) || (i = parseFloat(t));
            }
        });
        var a = n || 0;
        return Object.defineProperty(this, "h", {
            enumerable: !0,
            get: function() {
                return a;
            },
            set: function(t) {
                isNaN(t) || (a = parseFloat(t));
            }
        }), this;
    }, Or = function() {
        this.page = Dt, this.currentPage = $, this.pages = ot.slice(0), this.pagesContext = Rt.slice(0), this.x = Pt, this.y = kt, this.matrix = It, this.width = qr($), this.height = Rr($), this.outputDestination = ct, this.id = "", this.objectNumber = -1;
    };
    Or.prototype.restore = function() {
        Dt = this.page, $ = this.currentPage, Rt = this.pagesContext, ot = this.pages, Pt = this.x, kt = this.y, It = this.matrix, Dr($, this.width), Tr($, this.height), ct = this.outputDestination;
    };
    var Br = function(t, e, r, n, i) {
        Wt.push(new Or), Dt = $ = 0, ot = [], Pt = t, kt = e, It = i, je([
            r,
            n
        ]);
    }, Mr = function(t) {
        if (Ht[t]) Wt.pop().restore();
        else {
            var e = new Or, r = "Xo" + (Object.keys(zt).length + 1).toString(10);
            e.id = r, Ht[t] = r, zt[r] = e, Tt.publish("addFormObject", e), Wt.pop().restore();
        }
    };
    for(var Er in y.beginFormObject = function(t, e, r, n, i) {
        return Br(t, e, r, n, i), this;
    }, y.endFormObject = function(t) {
        return Mr(t), this;
    }, y.doFormObject = function(t, e) {
        var r = zt[Ht[t]];
        return lt("q"), lt(e.toString() + " cm"), lt("/" + r.id + " Do"), lt("Q"), this;
    }, y.getFormObject = function(t) {
        var e = zt[Ht[t]];
        return {
            x: e.x,
            y: e.y,
            width: e.width,
            height: e.height,
            matrix: e.matrix
        };
    }, y.save = function(t, e) {
        return t = t || "generated.pdf", (e = e || {}).returnPromise = e.returnPromise || !1, !1 === e.returnPromise ? (l(We(He()), t), "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), this) : new Promise(function(e, r) {
            try {
                var i = l(We(He()), t);
                "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), e(i);
            } catch (t) {
                r(t.message);
            }
        });
    }, E.API)E.API.hasOwnProperty(Er) && ("events" === Er && E.API.events.length ? function(t, e) {
        var r, n, i;
        for(i = e.length - 1; -1 !== i; i--)r = e[i][0], n = e[i][1], t.subscribe.apply(t, [
            r
        ].concat("function" == typeof n ? [
            n
        ] : n));
    }(Tt, E.API.events) : y[Er] = E.API[Er]);
    var qr = y.getPageWidth = function(t) {
        return (Rt[t = t || $].mediaBox.topRightX - Rt[t].mediaBox.bottomLeftX) / _t;
    }, Dr = y.setPageWidth = function(t, e) {
        Rt[t].mediaBox.topRightX = e * _t + Rt[t].mediaBox.bottomLeftX;
    }, Rr = y.getPageHeight = function(t) {
        return (Rt[t = t || $].mediaBox.topRightY - Rt[t].mediaBox.bottomLeftY) / _t;
    }, Tr = y.setPageHeight = function(t, e) {
        Rt[t].mediaBox.topRightY = e * _t + Rt[t].mediaBox.bottomLeftY;
    };
    return y.internal = {
        pdfEscape: Ce,
        getStyle: tr,
        getFont: hr,
        getFontSize: vt,
        getCharSpace: Pr,
        getTextColor: Sr,
        getLineHeight: gr,
        getLineHeightFactor: vr,
        getLineWidth: dr,
        write: ft,
        getHorizontalCoordinate: br,
        getVerticalCoordinate: yr,
        getCoordinateString: wr,
        getVerticalCoordinateString: Nr,
        collections: {},
        newObject: Xt,
        newAdditionalObject: $t,
        newObjectDeferred: Kt,
        newObjectDeferredBegin: Zt,
        getFilters: ne,
        putStream: ie,
        events: Tt,
        scaleFactor: _t,
        pageSize: {
            getWidth: function() {
                return qr($);
            },
            setWidth: function(t) {
                Dr($, t);
            },
            getHeight: function() {
                return Rr($);
            },
            setHeight: function(t) {
                Tr($, t);
            }
        },
        encryptionOptions: m,
        encryption: Ye,
        getEncryptor: Je,
        output: Ve,
        getNumberOfPages: Ee,
        pages: ot,
        out: lt,
        f2: R,
        f3: T,
        getPageInfo: Xe,
        getPageInfoByObjId: Ke,
        getCurrentPageInfo: Ze,
        getPDFVersion: N,
        Point: Cr,
        Rectangle: jr,
        Matrix: Vt,
        hasHotfix: Ge
    }, Object.defineProperty(y.internal.pageSize, "width", {
        get: function() {
            return qr($);
        },
        set: function(t) {
            Dr($, t);
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(y.internal.pageSize, "height", {
        get: function() {
            return Rr($);
        },
        set: function(t) {
            Tr($, t);
        },
        enumerable: !0,
        configurable: !0
    }), ke.call(y, pt), St = "F1", Oe(s, i), Tt.publish("initialized"), y;
}
I.prototype.lsbFirstWord = function(t) {
    return String.fromCharCode(t >> 0 & 255, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255);
}, I.prototype.toHexString = function(t) {
    return t.split("").map(function(t) {
        return ("0" + (255 & t.charCodeAt(0)).toString(16)).slice(-2);
    }).join("");
}, I.prototype.hexToBytes = function(t) {
    for(var e = [], r = 0; r < t.length; r += 2)e.push(String.fromCharCode(parseInt(t.substr(r, 2), 16)));
    return e.join("");
}, I.prototype.processOwnerPassword = function(t, e) {
    return P(x(e).substr(0, 5), t);
}, I.prototype.encryptor = function(t, e) {
    var r = x(this.encryptionKey + String.fromCharCode(255 & t, t >> 8 & 255, t >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
    return function(t) {
        return P(r, t);
    };
}, j.prototype.equals = function(e) {
    var r, n = "id,objectNumber,equals";
    if (!e || (0, _typeofDefault.default)(e) !== (0, _typeofDefault.default)(this)) return !1;
    var i = 0;
    for(r in this)if (!(n.indexOf(r) >= 0)) {
        if (this.hasOwnProperty(r) && !e.hasOwnProperty(r)) return !1;
        if (this[r] !== e[r]) return !1;
        i++;
    }
    for(r in e)e.hasOwnProperty(r) && n.indexOf(r) < 0 && i--;
    return 0 === i;
}, E.API = {
    events: []
}, E.version = "2.5.2";
var q = E.API, D = 1, R = function(t) {
    return t.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, T = function(t) {
    return t.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, U = function(t) {
    return t.toFixed(2);
}, z = function(t) {
    return t.toFixed(5);
};
q.__acroform__ = {};
var H = function(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t;
}, W = function(t) {
    return t * D;
}, V = function(t) {
    var e = new ut, r = At.internal.getHeight(t) || 0, n = At.internal.getWidth(t) || 0;
    return e.BBox = [
        0,
        0,
        Number(U(n)),
        Number(U(r))
    ], e;
}, G = q.__acroform__.setBit = function(t, e) {
    if (t = t || 0, e = e || 0, isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
    return t |= 1 << e;
}, Y = q.__acroform__.clearBit = function(t, e) {
    if (t = t || 0, e = e || 0, isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
    return t &= ~(1 << e);
}, J = q.__acroform__.getBit = function(t, e) {
    if (isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
    return 0 == (t & 1 << e) ? 0 : 1;
}, X = q.__acroform__.getBitForPdf = function(t, e) {
    if (isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
    return J(t, e - 1);
}, K = q.__acroform__.setBitForPdf = function(t, e) {
    if (isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
    return G(t, e - 1);
}, Z = q.__acroform__.clearBitForPdf = function(t, e) {
    if (isNaN(t) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
    return Y(t, e - 1);
}, $ = q.__acroform__.calculateCoordinates = function(t, e) {
    var r = e.internal.getHorizontalCoordinate, n = e.internal.getVerticalCoordinate, i = t[0], a = t[1], o = t[2], s = t[3], c = {};
    return c.lowerLeft_X = r(i) || 0, c.lowerLeft_Y = n(a + s) || 0, c.upperRight_X = r(i + o) || 0, c.upperRight_Y = n(a) || 0, [
        Number(U(c.lowerLeft_X)),
        Number(U(c.lowerLeft_Y)),
        Number(U(c.upperRight_X)),
        Number(U(c.upperRight_Y))
    ];
}, Q = function(t) {
    if (t.appearanceStreamContent) return t.appearanceStreamContent;
    if (t.V || t.DV) {
        var e = [], r = t._V || t.DV, n = tt(t, r), i = t.scope.internal.getFont(t.fontName, t.fontStyle).id;
        e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(t.scope.__private__.encodeColorString(t.color)), e.push("/" + i + " " + U(n.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(n.text), e.push("ET"), e.push("Q"), e.push("EMC");
        var a = V(t);
        return a.scope = t.scope, a.stream = e.join("\n"), a;
    }
}, tt = function(t, e) {
    var r = 0 === t.fontSize ? t.maxFontSize : t.fontSize, n = {
        text: "",
        fontSize: ""
    }, i = (e = ")" == (e = "(" == e.substr(0, 1) ? e.substr(1) : e).substr(e.length - 1) ? e.substr(0, e.length - 1) : e).split(" ");
    i = t.multiline ? i.map(function(t) {
        return t.split("\n");
    }) : i.map(function(t) {
        return [
            t
        ];
    });
    var a = r, o = At.internal.getHeight(t) || 0;
    o = o < 0 ? -o : o;
    var s = At.internal.getWidth(t) || 0;
    s = s < 0 ? -s : s;
    var c = function(e, r, n) {
        if (e + 1 < i.length) {
            var a = r + " " + i[e + 1][0];
            return et(a, t, n).width <= s - 4;
        }
        return !1;
    };
    a++;
    t: for(; a > 0;){
        e = "", a--;
        var u, h, l = et("3", t, a).height, f = t.multiline ? o - a : (o - l) / 2, d = f += 2, p = 0, g = 0, m = 0;
        if (a <= 0) {
            e = "(...) Tj\n", e += "% Width of Text: " + et(e, t, a = 12).width + ", FieldWidth:" + s + "\n";
            break;
        }
        for(var v = "", b = 0, y = 0; y < i.length; y++)if (i.hasOwnProperty(y)) {
            var w = !1;
            if (1 !== i[y].length && m !== i[y].length - 1) {
                if ((l + 2) * (b + 2) + 2 > o) continue t;
                v += i[y][m], w = !0, g = y, y--;
            } else {
                v = " " == (v += i[y][m] + " ").substr(v.length - 1) ? v.substr(0, v.length - 1) : v;
                var N = parseInt(y), L = c(N, v, a), A = y >= i.length - 1;
                if (L && !A) {
                    v += " ", m = 0;
                    continue;
                }
                if (L || A) {
                    if (A) g = N;
                    else if (t.multiline && (l + 2) * (b + 2) + 2 > o) continue t;
                } else {
                    if (!t.multiline) continue t;
                    if ((l + 2) * (b + 2) + 2 > o) continue t;
                    g = N;
                }
            }
            for(var x = "", S = p; S <= g; S++){
                var _ = i[S];
                if (t.multiline) {
                    if (S === g) {
                        x += _[m] + " ", m = (m + 1) % _.length;
                        continue;
                    }
                    if (S === p) {
                        x += _[_.length - 1] + " ";
                        continue;
                    }
                }
                x += _[0] + " ";
            }
            switch(x = " " == x.substr(x.length - 1) ? x.substr(0, x.length - 1) : x, h = et(x, t, a).width, t.textAlign){
                case "right":
                    u = s - h - 2;
                    break;
                case "center":
                    u = (s - h) / 2;
                    break;
                case "left":
                default:
                    u = 2;
            }
            e += U(u) + " " + U(d) + " Td\n", e += "(" + R(x) + ") Tj\n", e += -U(u) + " 0 Td\n", d = -(a + 2), h = 0, p = w ? g : g + 1, b++, v = "";
        }
        break;
    }
    return n.text = e, n.fontSize = a, n;
}, et = function(t, e, r) {
    var n = e.scope.internal.getFont(e.fontName, e.fontStyle), i = e.scope.getStringUnitWidth(t, {
        font: n,
        fontSize: parseFloat(r),
        charSpace: 0
    }) * parseFloat(r);
    return {
        height: e.scope.getStringUnitWidth("3", {
            font: n,
            fontSize: parseFloat(r),
            charSpace: 0
        }) * parseFloat(r) * 1.5,
        width: i
    };
}, rt = {
    fields: [],
    xForms: [],
    acroFormDictionaryRoot: null,
    printedOut: !1,
    internal: null,
    isInitialized: !1
}, nt = function(t, e) {
    var r = {
        type: "reference",
        object: t
    };
    void 0 === e.internal.getPageInfo(t.page).pageContext.annotations.find(function(t) {
        return t.type === r.type && t.object === r.object;
    }) && e.internal.getPageInfo(t.page).pageContext.annotations.push(r);
}, it = function(e, r) {
    for(var n in e)if (e.hasOwnProperty(n)) {
        var i = n, a = e[n];
        r.internal.newObjectDeferredBegin(a.objId, !0), "object" === (0, _typeofDefault.default)(a) && "function" == typeof a.putStream && a.putStream(), delete e[i];
    }
}, at = function(e, r) {
    if (r.scope = e, void 0 !== e.internal && (void 0 === e.internal.acroformPlugin || !1 === e.internal.acroformPlugin.isInitialized)) {
        if (lt.FieldNum = 0, e.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
        D = e.internal.scaleFactor, e.internal.acroformPlugin.acroFormDictionaryRoot = new ht, e.internal.acroformPlugin.acroFormDictionaryRoot.scope = e, e.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e.internal.events.subscribe("postPutResources", function() {
            !function(t) {
                t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = !0;
            }(e);
        }), e.internal.events.subscribe("buildDocument", function() {
            !function(t) {
                t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
                var e = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
                for(var r in e)if (e.hasOwnProperty(r)) {
                    var n = e[r];
                    n.objId = void 0, n.hasAnnotation && nt(n, t);
                }
            }(e);
        }), e.internal.events.subscribe("putCatalog", function() {
            !function(t) {
                if (void 0 === t.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("putCatalogCallback: Root missing.");
                t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
            }(e);
        }), e.internal.events.subscribe("postPutPages", function(r) {
            !function(e, r) {
                var n = !e;
                for(var i in e || (r.internal.newObjectDeferredBegin(r.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), r.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e = e || r.internal.acroformPlugin.acroFormDictionaryRoot.Kids)if (e.hasOwnProperty(i)) {
                    var a = e[i], o = [], s = a.Rect;
                    if (a.Rect && (a.Rect = $(a.Rect, r)), r.internal.newObjectDeferredBegin(a.objId, !0), a.DA = At.createDefaultAppearanceStream(a), "object" === (0, _typeofDefault.default)(a) && "function" == typeof a.getKeyValueListForStream && (o = a.getKeyValueListForStream()), a.Rect = s, a.hasAppearanceStream && !a.appearanceStreamContent) {
                        var c = Q(a);
                        o.push({
                            key: "AP",
                            value: "<</N " + c + ">>"
                        }), r.internal.acroformPlugin.xForms.push(c);
                    }
                    if (a.appearanceStreamContent) {
                        var u = "";
                        for(var h in a.appearanceStreamContent)if (a.appearanceStreamContent.hasOwnProperty(h)) {
                            var l = a.appearanceStreamContent[h];
                            if (u += "/" + h + " ", u += "<<", Object.keys(l).length >= 1 || Array.isArray(l)) {
                                for(var i in l)if (l.hasOwnProperty(i)) {
                                    var f = l[i];
                                    "function" == typeof f && (f = f.call(r, a)), u += "/" + i + " " + f + " ", r.internal.acroformPlugin.xForms.indexOf(f) >= 0 || r.internal.acroformPlugin.xForms.push(f);
                                }
                            } else "function" == typeof (f = l) && (f = f.call(r, a)), u += "/" + i + " " + f, r.internal.acroformPlugin.xForms.indexOf(f) >= 0 || r.internal.acroformPlugin.xForms.push(f);
                            u += ">>";
                        }
                        o.push({
                            key: "AP",
                            value: "<<\n" + u + ">>"
                        });
                    }
                    r.internal.putStream({
                        additionalKeyValues: o,
                        objectId: a.objId
                    }), r.internal.out("endobj");
                }
                n && it(r.internal.acroformPlugin.xForms, r);
            }(r, e);
        }), e.internal.acroformPlugin.isInitialized = !0;
    }
}, ot = q.__acroform__.arrayToPdfArray = function(e, r, n) {
    var i = function(t) {
        return t;
    };
    if (Array.isArray(e)) {
        for(var a = "[", o = 0; o < e.length; o++)switch(0 !== o && (a += " "), (0, _typeofDefault.default)(e[o])){
            case "boolean":
            case "number":
            case "object":
                a += e[o].toString();
                break;
            case "string":
                "/" !== e[o].substr(0, 1) ? (void 0 !== r && n && (i = n.internal.getEncryptor(r)), a += "(" + R(i(e[o].toString())) + ")") : a += e[o].toString();
        }
        return a += "]";
    }
    throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var st = function(t, e, r) {
    var n = function(t) {
        return t;
    };
    return void 0 !== e && r && (n = r.internal.getEncryptor(e)), (t = t || "").toString(), t = "(" + R(n(t)) + ")";
}, ct = function() {
    this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", {
        get: function() {
            if (void 0 === this._objId) {
                if (void 0 === this.scope) return;
                this._objId = this.scope.internal.newObjectDeferred();
            }
            return this._objId;
        },
        set: function(t) {
            this._objId = t;
        }
    }), Object.defineProperty(this, "scope", {
        value: this._scope,
        writable: !0
    });
};
ct.prototype.toString = function() {
    return this.objId + " 0 R";
}, ct.prototype.putStream = function() {
    var t = this.getKeyValueListForStream();
    this.scope.internal.putStream({
        data: this.stream,
        additionalKeyValues: t,
        objectId: this.objId
    }), this.scope.internal.out("endobj");
}, ct.prototype.getKeyValueListForStream = function() {
    var t = [], e = Object.getOwnPropertyNames(this).filter(function(t) {
        return "content" != t && "appearanceStreamContent" != t && "scope" != t && "objId" != t && "_" != t.substring(0, 1);
    });
    for(var r in e)if (!1 === Object.getOwnPropertyDescriptor(this, e[r]).configurable) {
        var n = e[r], i = this[n];
        i && (Array.isArray(i) ? t.push({
            key: n,
            value: ot(i, this.objId, this.scope)
        }) : i instanceof ct ? (i.scope = this.scope, t.push({
            key: n,
            value: i.objId + " 0 R"
        })) : "function" != typeof i && t.push({
            key: n,
            value: i
        }));
    }
    return t;
};
var ut = function() {
    ct.call(this), Object.defineProperty(this, "Type", {
        value: "/XObject",
        configurable: !1,
        writable: !0
    }), Object.defineProperty(this, "Subtype", {
        value: "/Form",
        configurable: !1,
        writable: !0
    }), Object.defineProperty(this, "FormType", {
        value: 1,
        configurable: !1,
        writable: !0
    });
    var t, e = [];
    Object.defineProperty(this, "BBox", {
        configurable: !1,
        get: function() {
            return e;
        },
        set: function(t) {
            e = t;
        }
    }), Object.defineProperty(this, "Resources", {
        value: "2 0 R",
        configurable: !1,
        writable: !0
    }), Object.defineProperty(this, "stream", {
        enumerable: !1,
        configurable: !0,
        set: function(e) {
            t = e.trim();
        },
        get: function() {
            return t || null;
        }
    });
};
H(ut, ct);
var ht = function() {
    ct.call(this);
    var t, e = [];
    Object.defineProperty(this, "Kids", {
        enumerable: !1,
        configurable: !0,
        get: function() {
            return e.length > 0 ? e : void 0;
        }
    }), Object.defineProperty(this, "Fields", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            return e;
        }
    }), Object.defineProperty(this, "DA", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            if (t) {
                var e = function(t) {
                    return t;
                };
                return this.scope && (e = this.scope.internal.getEncryptor(this.objId)), "(" + R(e(t)) + ")";
            }
        },
        set: function(e) {
            t = e;
        }
    });
};
H(ht, ct);
var lt = function t() {
    ct.call(this);
    var e = 4;
    Object.defineProperty(this, "F", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            return e;
        },
        set: function(t) {
            if (isNaN(t)) throw new Error('Invalid value "' + t + '" for attribute F supplied.');
            e = t;
        }
    }), Object.defineProperty(this, "showWhenPrinted", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(e, 3));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.F = K(e, 3) : this.F = Z(e, 3);
        }
    });
    var r = 0;
    Object.defineProperty(this, "Ff", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            return r;
        },
        set: function(t) {
            if (isNaN(t)) throw new Error('Invalid value "' + t + '" for attribute Ff supplied.');
            r = t;
        }
    });
    var n = [];
    Object.defineProperty(this, "Rect", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            if (0 !== n.length) return n;
        },
        set: function(t) {
            n = void 0 !== t ? t : [];
        }
    }), Object.defineProperty(this, "x", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return !n || isNaN(n[0]) ? 0 : n[0];
        },
        set: function(t) {
            n[0] = t;
        }
    }), Object.defineProperty(this, "y", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return !n || isNaN(n[1]) ? 0 : n[1];
        },
        set: function(t) {
            n[1] = t;
        }
    }), Object.defineProperty(this, "width", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return !n || isNaN(n[2]) ? 0 : n[2];
        },
        set: function(t) {
            n[2] = t;
        }
    }), Object.defineProperty(this, "height", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return !n || isNaN(n[3]) ? 0 : n[3];
        },
        set: function(t) {
            n[3] = t;
        }
    });
    var i = "";
    Object.defineProperty(this, "FT", {
        enumerable: !0,
        configurable: !1,
        get: function() {
            return i;
        },
        set: function(t) {
            switch(t){
                case "/Btn":
                case "/Tx":
                case "/Ch":
                case "/Sig":
                    i = t;
                    break;
                default:
                    throw new Error('Invalid value "' + t + '" for attribute FT supplied.');
            }
        }
    });
    var a = null;
    Object.defineProperty(this, "T", {
        enumerable: !0,
        configurable: !1,
        get: function() {
            if (!a || a.length < 1) {
                if (this instanceof yt) return;
                a = "FieldObject" + t.FieldNum++;
            }
            var e = function(t) {
                return t;
            };
            return this.scope && (e = this.scope.internal.getEncryptor(this.objId)), "(" + R(e(a)) + ")";
        },
        set: function(t) {
            a = t.toString();
        }
    }), Object.defineProperty(this, "fieldName", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            return a;
        },
        set: function(t) {
            a = t;
        }
    });
    var o = "helvetica";
    Object.defineProperty(this, "fontName", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return o;
        },
        set: function(t) {
            o = t;
        }
    });
    var s = "normal";
    Object.defineProperty(this, "fontStyle", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return s;
        },
        set: function(t) {
            s = t;
        }
    });
    var c = 0;
    Object.defineProperty(this, "fontSize", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return c;
        },
        set: function(t) {
            c = t;
        }
    });
    var u = void 0;
    Object.defineProperty(this, "maxFontSize", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return void 0 === u ? 50 / D : u;
        },
        set: function(t) {
            u = t;
        }
    });
    var h = "black";
    Object.defineProperty(this, "color", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return h;
        },
        set: function(t) {
            h = t;
        }
    });
    var l = "/F1 0 Tf 0 g";
    Object.defineProperty(this, "DA", {
        enumerable: !0,
        configurable: !1,
        get: function() {
            if (!(!l || this instanceof yt || this instanceof Nt)) return st(l, this.objId, this.scope);
        },
        set: function(t) {
            t = t.toString(), l = t;
        }
    });
    var f = null;
    Object.defineProperty(this, "DV", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            if (f) return this instanceof mt == !1 ? st(f, this.objId, this.scope) : f;
        },
        set: function(t) {
            t = t.toString(), f = this instanceof mt == !1 ? "(" === t.substr(0, 1) ? T(t.substr(1, t.length - 2)) : T(t) : t;
        }
    }), Object.defineProperty(this, "defaultValue", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return this instanceof mt == !0 ? T(f.substr(1, f.length - 1)) : f;
        },
        set: function(t) {
            t = t.toString(), f = this instanceof mt == !0 ? "/" + t : t;
        }
    });
    var d = null;
    Object.defineProperty(this, "_V", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            if (d) return d;
        },
        set: function(t) {
            this.V = t;
        }
    }), Object.defineProperty(this, "V", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            if (d) return this instanceof mt == !1 ? st(d, this.objId, this.scope) : d;
        },
        set: function(t) {
            t = t.toString(), d = this instanceof mt == !1 ? "(" === t.substr(0, 1) ? T(t.substr(1, t.length - 2)) : T(t) : t;
        }
    }), Object.defineProperty(this, "value", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return this instanceof mt == !0 ? T(d.substr(1, d.length - 1)) : d;
        },
        set: function(t) {
            t = t.toString(), d = this instanceof mt == !0 ? "/" + t : t;
        }
    }), Object.defineProperty(this, "hasAnnotation", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return this.Rect;
        }
    }), Object.defineProperty(this, "Type", {
        enumerable: !0,
        configurable: !1,
        get: function() {
            return this.hasAnnotation ? "/Annot" : null;
        }
    }), Object.defineProperty(this, "Subtype", {
        enumerable: !0,
        configurable: !1,
        get: function() {
            return this.hasAnnotation ? "/Widget" : null;
        }
    });
    var p, g = !1;
    Object.defineProperty(this, "hasAppearanceStream", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return g;
        },
        set: function(t) {
            t = Boolean(t), g = t;
        }
    }), Object.defineProperty(this, "page", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            if (p) return p;
        },
        set: function(t) {
            p = t;
        }
    }), Object.defineProperty(this, "readOnly", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 1));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 1) : this.Ff = Z(this.Ff, 1);
        }
    }), Object.defineProperty(this, "required", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 2));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 2) : this.Ff = Z(this.Ff, 2);
        }
    }), Object.defineProperty(this, "noExport", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 3));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 3) : this.Ff = Z(this.Ff, 3);
        }
    });
    var m = null;
    Object.defineProperty(this, "Q", {
        enumerable: !0,
        configurable: !1,
        get: function() {
            if (null !== m) return m;
        },
        set: function(t) {
            if (-1 === [
                0,
                1,
                2
            ].indexOf(t)) throw new Error('Invalid value "' + t + '" for attribute Q supplied.');
            m = t;
        }
    }), Object.defineProperty(this, "textAlign", {
        get: function() {
            var t;
            switch(m){
                case 0:
                default:
                    t = "left";
                    break;
                case 1:
                    t = "center";
                    break;
                case 2:
                    t = "right";
            }
            return t;
        },
        configurable: !0,
        enumerable: !0,
        set: function(t) {
            switch(t){
                case "right":
                case 2:
                    m = 2;
                    break;
                case "center":
                case 1:
                    m = 1;
                    break;
                case "left":
                case 0:
                default:
                    m = 0;
            }
        }
    });
};
H(lt, ct);
var ft = function() {
    lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
    var t = 0;
    Object.defineProperty(this, "TI", {
        enumerable: !0,
        configurable: !1,
        get: function() {
            return t;
        },
        set: function(e) {
            t = e;
        }
    }), Object.defineProperty(this, "topIndex", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return t;
        },
        set: function(e) {
            t = e;
        }
    });
    var e = [];
    Object.defineProperty(this, "Opt", {
        enumerable: !0,
        configurable: !1,
        get: function() {
            return ot(e, this.objId, this.scope);
        },
        set: function(t) {
            var r, n;
            n = [], "string" == typeof (r = t) && (n = function(t, e, r) {
                r || (r = 1);
                for(var n, i = []; n = e.exec(t);)i.push(n[r]);
                return i;
            }(r, /\((.*?)\)/g)), e = n;
        }
    }), this.getOptions = function() {
        return e;
    }, this.setOptions = function(t) {
        e = t, this.sort && e.sort();
    }, this.addOption = function(t) {
        t = (t = t || "").toString(), e.push(t), this.sort && e.sort();
    }, this.removeOption = function(t, r) {
        for(r = r || !1, t = (t = t || "").toString(); -1 !== e.indexOf(t) && (e.splice(e.indexOf(t), 1), !1 !== r););
    }, Object.defineProperty(this, "combo", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 18));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 18) : this.Ff = Z(this.Ff, 18);
        }
    }), Object.defineProperty(this, "edit", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 19));
        },
        set: function(t) {
            !0 === this.combo && (!0 === Boolean(t) ? this.Ff = K(this.Ff, 19) : this.Ff = Z(this.Ff, 19));
        }
    }), Object.defineProperty(this, "sort", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 20));
        },
        set: function(t) {
            !0 === Boolean(t) ? (this.Ff = K(this.Ff, 20), e.sort()) : this.Ff = Z(this.Ff, 20);
        }
    }), Object.defineProperty(this, "multiSelect", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 22));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 22) : this.Ff = Z(this.Ff, 22);
        }
    }), Object.defineProperty(this, "doNotSpellCheck", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 23));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
        }
    }), Object.defineProperty(this, "commitOnSelChange", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 27));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 27) : this.Ff = Z(this.Ff, 27);
        }
    }), this.hasAppearanceStream = !1;
};
H(ft, lt);
var dt = function() {
    ft.call(this), this.fontName = "helvetica", this.combo = !1;
};
H(dt, ft);
var pt = function() {
    dt.call(this), this.combo = !0;
};
H(pt, dt);
var gt = function() {
    pt.call(this), this.edit = !0;
};
H(gt, pt);
var mt = function() {
    lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 15));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 15) : this.Ff = Z(this.Ff, 15);
        }
    }), Object.defineProperty(this, "radio", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 16));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 16) : this.Ff = Z(this.Ff, 16);
        }
    }), Object.defineProperty(this, "pushButton", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 17));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 17) : this.Ff = Z(this.Ff, 17);
        }
    }), Object.defineProperty(this, "radioIsUnison", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 26));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
        }
    });
    var e, r = {};
    Object.defineProperty(this, "MK", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            var t = function(t) {
                return t;
            };
            if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(r).length) {
                var e, n = [];
                for(e in n.push("<<"), r)n.push("/" + e + " (" + R(t(r[e])) + ")");
                return n.push(">>"), n.join("\n");
            }
        },
        set: function(e) {
            "object" === (0, _typeofDefault.default)(e) && (r = e);
        }
    }), Object.defineProperty(this, "caption", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return r.CA || "";
        },
        set: function(t) {
            "string" == typeof t && (r.CA = t);
        }
    }), Object.defineProperty(this, "AS", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            return e;
        },
        set: function(t) {
            e = t;
        }
    }), Object.defineProperty(this, "appearanceState", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return e.substr(1, e.length - 1);
        },
        set: function(t) {
            e = "/" + t;
        }
    });
};
H(mt, lt);
var vt = function() {
    mt.call(this), this.pushButton = !0;
};
H(vt, mt);
var bt = function() {
    mt.call(this), this.radio = !0, this.pushButton = !1;
    var t = [];
    Object.defineProperty(this, "Kids", {
        enumerable: !0,
        configurable: !1,
        get: function() {
            return t;
        },
        set: function(e) {
            t = void 0 !== e ? e : [];
        }
    });
};
H(bt, mt);
var yt = function() {
    var e, r;
    lt.call(this), Object.defineProperty(this, "Parent", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            return e;
        },
        set: function(t) {
            e = t;
        }
    }), Object.defineProperty(this, "optionName", {
        enumerable: !1,
        configurable: !0,
        get: function() {
            return r;
        },
        set: function(t) {
            r = t;
        }
    });
    var n, i = {};
    Object.defineProperty(this, "MK", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            var t = function(t) {
                return t;
            };
            this.scope && (t = this.scope.internal.getEncryptor(this.objId));
            var e, r = [];
            for(e in r.push("<<"), i)r.push("/" + e + " (" + R(t(i[e])) + ")");
            return r.push(">>"), r.join("\n");
        },
        set: function(e) {
            "object" === (0, _typeofDefault.default)(e) && (i = e);
        }
    }), Object.defineProperty(this, "caption", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return i.CA || "";
        },
        set: function(t) {
            "string" == typeof t && (i.CA = t);
        }
    }), Object.defineProperty(this, "AS", {
        enumerable: !1,
        configurable: !1,
        get: function() {
            return n;
        },
        set: function(t) {
            n = t;
        }
    }), Object.defineProperty(this, "appearanceState", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return n.substr(1, n.length - 1);
        },
        set: function(t) {
            n = "/" + t;
        }
    }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
H(yt, lt), bt.prototype.setAppearance = function(t) {
    if (!("createAppearanceStream" in t) || !("getCA" in t)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
    for(var e in this.Kids)if (this.Kids.hasOwnProperty(e)) {
        var r = this.Kids[e];
        r.appearanceStreamContent = t.createAppearanceStream(r.optionName), r.caption = t.getCA();
    }
}, bt.prototype.createOption = function(t) {
    var e = new yt;
    return e.Parent = this, e.optionName = t, this.Kids.push(e), xt.call(this.scope, e), e;
};
var wt = function() {
    mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
};
H(wt, mt);
var Nt = function() {
    lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 13));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 13) : this.Ff = Z(this.Ff, 13);
        }
    }), Object.defineProperty(this, "fileSelect", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 21));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 21) : this.Ff = Z(this.Ff, 21);
        }
    }), Object.defineProperty(this, "doNotSpellCheck", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 23));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
        }
    }), Object.defineProperty(this, "doNotScroll", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 24));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 24) : this.Ff = Z(this.Ff, 24);
        }
    }), Object.defineProperty(this, "comb", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 25));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 25) : this.Ff = Z(this.Ff, 25);
        }
    }), Object.defineProperty(this, "richText", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 26));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
        }
    });
    var t = null;
    Object.defineProperty(this, "MaxLen", {
        enumerable: !0,
        configurable: !1,
        get: function() {
            return t;
        },
        set: function(e) {
            t = e;
        }
    }), Object.defineProperty(this, "maxLength", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return t;
        },
        set: function(e) {
            Number.isInteger(e) && (t = e);
        }
    }), Object.defineProperty(this, "hasAppearanceStream", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return this.V || this.DV;
        }
    });
};
H(Nt, lt);
var Lt = function() {
    Nt.call(this), Object.defineProperty(this, "password", {
        enumerable: !0,
        configurable: !0,
        get: function() {
            return Boolean(X(this.Ff, 14));
        },
        set: function(t) {
            !0 === Boolean(t) ? this.Ff = K(this.Ff, 14) : this.Ff = Z(this.Ff, 14);
        }
    }), this.password = !0;
};
H(Lt, Nt);
var At = {
    CheckBox: {
        createAppearanceStream: function() {
            return {
                N: {
                    On: At.CheckBox.YesNormal
                },
                D: {
                    On: At.CheckBox.YesPushDown,
                    Off: At.CheckBox.OffPushDown
                }
            };
        },
        YesPushDown: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = [], n = t.scope.internal.getFont(t.fontName, t.fontStyle).id, i = t.scope.__private__.encodeColorString(t.color), a = tt(t, t.caption);
            return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t)) + " " + U(At.internal.getHeight(t)) + " re"), r.push("f"), r.push("BMC"), r.push("q"), r.push("0 0 1 rg"), r.push("/" + n + " " + U(a.fontSize) + " Tf " + i), r.push("BT"), r.push(a.text), r.push("ET"), r.push("Q"), r.push("EMC"), e.stream = r.join("\n"), e;
        },
        YesNormal: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = t.scope.internal.getFont(t.fontName, t.fontStyle).id, n = t.scope.__private__.encodeColorString(t.color), i = [], a = At.internal.getHeight(t), o = At.internal.getWidth(t), s = tt(t, t.caption);
            return i.push("1 g"), i.push("0 0 " + U(o) + " " + U(a) + " re"), i.push("f"), i.push("q"), i.push("0 0 1 rg"), i.push("0 0 " + U(o - 1) + " " + U(a - 1) + " re"), i.push("W"), i.push("n"), i.push("0 g"), i.push("BT"), i.push("/" + r + " " + U(s.fontSize) + " Tf " + n), i.push(s.text), i.push("ET"), i.push("Q"), e.stream = i.join("\n"), e;
        },
        OffPushDown: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = [];
            return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t)) + " " + U(At.internal.getHeight(t)) + " re"), r.push("f"), e.stream = r.join("\n"), e;
        }
    },
    RadioButton: {
        Circle: {
            createAppearanceStream: function(t) {
                var e = {
                    D: {
                        Off: At.RadioButton.Circle.OffPushDown
                    },
                    N: {}
                };
                return e.N[t] = At.RadioButton.Circle.YesNormal, e.D[t] = At.RadioButton.Circle.YesPushDown, e;
            },
            getCA: function() {
                return "l";
            },
            YesNormal: function(t) {
                var e = V(t);
                e.scope = t.scope;
                var r = [], n = At.internal.getWidth(t) <= At.internal.getHeight(t) ? At.internal.getWidth(t) / 4 : At.internal.getHeight(t) / 4;
                n = Number((.9 * n).toFixed(5));
                var i = At.internal.Bezier_C, a = Number((n * i).toFixed(5));
                return r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t) / 2) + " " + z(At.internal.getHeight(t) / 2) + " cm"), r.push(n + " 0 m"), r.push(n + " " + a + " " + a + " " + n + " 0 " + n + " c"), r.push("-" + a + " " + n + " -" + n + " " + a + " -" + n + " 0 c"), r.push("-" + n + " -" + a + " -" + a + " -" + n + " 0 -" + n + " c"), r.push(a + " -" + n + " " + n + " -" + a + " " + n + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
            },
            YesPushDown: function(t) {
                var e = V(t);
                e.scope = t.scope;
                var r = [], n = At.internal.getWidth(t) <= At.internal.getHeight(t) ? At.internal.getWidth(t) / 4 : At.internal.getHeight(t) / 4;
                n = Number((.9 * n).toFixed(5));
                var i = Number((2 * n).toFixed(5)), a = Number((i * At.internal.Bezier_C).toFixed(5)), o = Number((n * At.internal.Bezier_C).toFixed(5));
                return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t) / 2) + " " + z(At.internal.getHeight(t) / 2) + " cm"), r.push(i + " 0 m"), r.push(i + " " + a + " " + a + " " + i + " 0 " + i + " c"), r.push("-" + a + " " + i + " -" + i + " " + a + " -" + i + " 0 c"), r.push("-" + i + " -" + a + " -" + a + " -" + i + " 0 -" + i + " c"), r.push(a + " -" + i + " " + i + " -" + a + " " + i + " 0 c"), r.push("f"), r.push("Q"), r.push("0 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t) / 2) + " " + z(At.internal.getHeight(t) / 2) + " cm"), r.push(n + " 0 m"), r.push(n + " " + o + " " + o + " " + n + " 0 " + n + " c"), r.push("-" + o + " " + n + " -" + n + " " + o + " -" + n + " 0 c"), r.push("-" + n + " -" + o + " -" + o + " -" + n + " 0 -" + n + " c"), r.push(o + " -" + n + " " + n + " -" + o + " " + n + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
            },
            OffPushDown: function(t) {
                var e = V(t);
                e.scope = t.scope;
                var r = [], n = At.internal.getWidth(t) <= At.internal.getHeight(t) ? At.internal.getWidth(t) / 4 : At.internal.getHeight(t) / 4;
                n = Number((.9 * n).toFixed(5));
                var i = Number((2 * n).toFixed(5)), a = Number((i * At.internal.Bezier_C).toFixed(5));
                return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t) / 2) + " " + z(At.internal.getHeight(t) / 2) + " cm"), r.push(i + " 0 m"), r.push(i + " " + a + " " + a + " " + i + " 0 " + i + " c"), r.push("-" + a + " " + i + " -" + i + " " + a + " -" + i + " 0 c"), r.push("-" + i + " -" + a + " -" + a + " -" + i + " 0 -" + i + " c"), r.push(a + " -" + i + " " + i + " -" + a + " " + i + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
            }
        },
        Cross: {
            createAppearanceStream: function(t) {
                var e = {
                    D: {
                        Off: At.RadioButton.Cross.OffPushDown
                    },
                    N: {}
                };
                return e.N[t] = At.RadioButton.Cross.YesNormal, e.D[t] = At.RadioButton.Cross.YesPushDown, e;
            },
            getCA: function() {
                return "8";
            },
            YesNormal: function(t) {
                var e = V(t);
                e.scope = t.scope;
                var r = [], n = At.internal.calculateCross(t);
                return r.push("q"), r.push("1 1 " + U(At.internal.getWidth(t) - 2) + " " + U(At.internal.getHeight(t) - 2) + " re"), r.push("W"), r.push("n"), r.push(U(n.x1.x) + " " + U(n.x1.y) + " m"), r.push(U(n.x2.x) + " " + U(n.x2.y) + " l"), r.push(U(n.x4.x) + " " + U(n.x4.y) + " m"), r.push(U(n.x3.x) + " " + U(n.x3.y) + " l"), r.push("s"), r.push("Q"), e.stream = r.join("\n"), e;
            },
            YesPushDown: function(t) {
                var e = V(t);
                e.scope = t.scope;
                var r = At.internal.calculateCross(t), n = [];
                return n.push("0.749023 g"), n.push("0 0 " + U(At.internal.getWidth(t)) + " " + U(At.internal.getHeight(t)) + " re"), n.push("f"), n.push("q"), n.push("1 1 " + U(At.internal.getWidth(t) - 2) + " " + U(At.internal.getHeight(t) - 2) + " re"), n.push("W"), n.push("n"), n.push(U(r.x1.x) + " " + U(r.x1.y) + " m"), n.push(U(r.x2.x) + " " + U(r.x2.y) + " l"), n.push(U(r.x4.x) + " " + U(r.x4.y) + " m"), n.push(U(r.x3.x) + " " + U(r.x3.y) + " l"), n.push("s"), n.push("Q"), e.stream = n.join("\n"), e;
            },
            OffPushDown: function(t) {
                var e = V(t);
                e.scope = t.scope;
                var r = [];
                return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t)) + " " + U(At.internal.getHeight(t)) + " re"), r.push("f"), e.stream = r.join("\n"), e;
            }
        }
    },
    createDefaultAppearanceStream: function(t) {
        var e = t.scope.internal.getFont(t.fontName, t.fontStyle).id, r = t.scope.__private__.encodeColorString(t.color);
        return "/" + e + " " + t.fontSize + " Tf " + r;
    }
};
At.internal = {
    Bezier_C: .551915024494,
    calculateCross: function(t) {
        var e = At.internal.getWidth(t), r = At.internal.getHeight(t), n = Math.min(e, r);
        return {
            x1: {
                x: (e - n) / 2,
                y: (r - n) / 2 + n
            },
            x2: {
                x: (e - n) / 2 + n,
                y: (r - n) / 2
            },
            x3: {
                x: (e - n) / 2,
                y: (r - n) / 2
            },
            x4: {
                x: (e - n) / 2 + n,
                y: (r - n) / 2 + n
            }
        };
    }
}, At.internal.getWidth = function(e) {
    var r = 0;
    return "object" === (0, _typeofDefault.default)(e) && (r = W(e.Rect[2])), r;
}, At.internal.getHeight = function(e) {
    var r = 0;
    return "object" === (0, _typeofDefault.default)(e) && (r = W(e.Rect[3])), r;
};
var xt = q.addField = function(t) {
    if (at(this, t), !(t instanceof lt)) throw new Error("Invalid argument passed to jsPDF.addField.");
    var e;
    return (e = t).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = !1, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), t.page = t.scope.internal.getCurrentPageInfo().pageNumber, this;
};
q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = {
    ChoiceField: ft,
    ListBox: dt,
    ComboBox: pt,
    EditBox: gt,
    Button: mt,
    PushButton: vt,
    RadioButton: bt,
    CheckBox: wt,
    TextField: Nt,
    PasswordField: Lt,
    Appearance: At
}, E.AcroForm = {
    ChoiceField: ft,
    ListBox: dt,
    ComboBox: pt,
    EditBox: gt,
    Button: mt,
    PushButton: vt,
    RadioButton: bt,
    CheckBox: wt,
    TextField: Nt,
    PasswordField: Lt,
    Appearance: At
};
var St = E.AcroForm;
function _t(t) {
    return t.reduce(function(t, e, r) {
        return t[e] = r, t;
    }, {});
}
!function(e) {
    e.__addimage__ = {};
    var r = "UNKNOWN", n = {
        PNG: [
            [
                137,
                80,
                78,
                71
            ]
        ],
        TIFF: [
            [
                77,
                77,
                0,
                42
            ],
            [
                73,
                73,
                42,
                0
            ]
        ],
        JPEG: [
            [
                255,
                216,
                255,
                224,
                void 0,
                void 0,
                74,
                70,
                73,
                70,
                0
            ],
            [
                255,
                216,
                255,
                225,
                void 0,
                void 0,
                69,
                120,
                105,
                102,
                0,
                0
            ],
            [
                255,
                216,
                255,
                219
            ],
            [
                255,
                216,
                255,
                238
            ]
        ],
        JPEG2000: [
            [
                0,
                0,
                0,
                12,
                106,
                80,
                32,
                32
            ]
        ],
        GIF87a: [
            [
                71,
                73,
                70,
                56,
                55,
                97
            ]
        ],
        GIF89a: [
            [
                71,
                73,
                70,
                56,
                57,
                97
            ]
        ],
        WEBP: [
            [
                82,
                73,
                70,
                70,
                void 0,
                void 0,
                void 0,
                void 0,
                87,
                69,
                66,
                80
            ]
        ],
        BMP: [
            [
                66,
                77
            ],
            [
                66,
                65
            ],
            [
                67,
                73
            ],
            [
                67,
                80
            ],
            [
                73,
                67
            ],
            [
                80,
                84
            ]
        ]
    }, i = e.__addimage__.getImageFileTypeByImageData = function(t, e) {
        var i, a, o, s, c, u = r;
        if ("RGBA" === (e = e || r) || void 0 !== t.data && t.data instanceof Uint8ClampedArray && "height" in t && "width" in t) return "RGBA";
        if (x(t)) for(c in n)for(o = n[c], i = 0; i < o.length; i += 1){
            for(s = !0, a = 0; a < o[i].length; a += 1)if (void 0 !== o[i][a] && o[i][a] !== t[a]) {
                s = !1;
                break;
            }
            if (!0 === s) {
                u = c;
                break;
            }
        }
        else for(c in n)for(o = n[c], i = 0; i < o.length; i += 1){
            for(s = !0, a = 0; a < o[i].length; a += 1)if (void 0 !== o[i][a] && o[i][a] !== t.charCodeAt(a)) {
                s = !1;
                break;
            }
            if (!0 === s) {
                u = c;
                break;
            }
        }
        return u === r && e !== r && (u = e), u;
    }, a = function t(e) {
        for(var r = this.internal.write, n = this.internal.putStream, i = (0, this.internal.getFilters)(); -1 !== i.indexOf("FlateEncode");)i.splice(i.indexOf("FlateEncode"), 1);
        e.objectId = this.internal.newObject();
        var a = [];
        if (a.push({
            key: "Type",
            value: "/XObject"
        }), a.push({
            key: "Subtype",
            value: "/Image"
        }), a.push({
            key: "Width",
            value: e.width
        }), a.push({
            key: "Height",
            value: e.height
        }), e.colorSpace === b.INDEXED ? a.push({
            key: "ColorSpace",
            value: "[/Indexed /DeviceRGB " + (e.palette.length / 3 - 1) + " " + ("sMask" in e && void 0 !== e.sMask ? e.objectId + 2 : e.objectId + 1) + " 0 R]"
        }) : (a.push({
            key: "ColorSpace",
            value: "/" + e.colorSpace
        }), e.colorSpace === b.DEVICE_CMYK && a.push({
            key: "Decode",
            value: "[1 0 1 0 1 0 1 0]"
        })), a.push({
            key: "BitsPerComponent",
            value: e.bitsPerComponent
        }), "decodeParameters" in e && void 0 !== e.decodeParameters && a.push({
            key: "DecodeParms",
            value: "<<" + e.decodeParameters + ">>"
        }), "transparency" in e && Array.isArray(e.transparency)) {
            for(var o = "", s = 0, c = e.transparency.length; s < c; s++)o += e.transparency[s] + " " + e.transparency[s] + " ";
            a.push({
                key: "Mask",
                value: "[" + o + "]"
            });
        }
        void 0 !== e.sMask && a.push({
            key: "SMask",
            value: e.objectId + 1 + " 0 R"
        });
        var u = void 0 !== e.filter ? [
            "/" + e.filter
        ] : void 0;
        if (n({
            data: e.data,
            additionalKeyValues: a,
            alreadyAppliedFilters: u,
            objectId: e.objectId
        }), r("endobj"), "sMask" in e && void 0 !== e.sMask) {
            var h = "/Predictor " + e.predictor + " /Colors 1 /BitsPerComponent " + e.bitsPerComponent + " /Columns " + e.width, l = {
                width: e.width,
                height: e.height,
                colorSpace: "DeviceGray",
                bitsPerComponent: e.bitsPerComponent,
                decodeParameters: h,
                data: e.sMask
            };
            "filter" in e && (l.filter = e.filter), t.call(this, l);
        }
        if (e.colorSpace === b.INDEXED) {
            var f = this.internal.newObject();
            n({
                data: _(new Uint8Array(e.palette)),
                objectId: f
            }), r("endobj");
        }
    }, o = function() {
        var t = this.internal.collections.addImage_images;
        for(var e in t)a.call(this, t[e]);
    }, s = function() {
        var t, e = this.internal.collections.addImage_images, r = this.internal.write;
        for(var n in e)r("/I" + (t = e[n]).index, t.objectId, "0", "R");
    }, c = function() {
        this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o), this.internal.events.subscribe("putXobjectDict", s));
    }, h = function() {
        var t = this.internal.collections.addImage_images;
        return c.call(this), t;
    }, l = function() {
        return Object.keys(this.internal.collections.addImage_images).length;
    }, f = function(t) {
        return "function" == typeof e["process" + t.toUpperCase()];
    }, d = function(e) {
        return "object" === (0, _typeofDefault.default)(e) && 1 === e.nodeType;
    }, p = function(t, r) {
        if ("IMG" === t.nodeName && t.hasAttribute("src")) {
            var n = "" + t.getAttribute("src");
            if (0 === n.indexOf("data:image/")) return u(unescape(n).split("base64,").pop());
            var i = e.loadFile(n, !0);
            if (void 0 !== i) return i;
        }
        if ("CANVAS" === t.nodeName) {
            if (0 === t.width || 0 === t.height) throw new Error("Given canvas must have data. Canvas width: " + t.width + ", height: " + t.height);
            var a;
            switch(r){
                case "PNG":
                    a = "image/png";
                    break;
                case "WEBP":
                    a = "image/webp";
                    break;
                case "JPEG":
                case "JPG":
                default:
                    a = "image/jpeg";
            }
            return u(t.toDataURL(a, 1).split("base64,").pop());
        }
    }, g = function(t) {
        var e = this.internal.collections.addImage_images;
        if (e) {
            for(var r in e)if (t === e[r].alias) return e[r];
        }
    }, m = function(t, e, r) {
        return t || e || (t = -96, e = -96), t < 0 && (t = -1 * r.width * 72 / t / this.internal.scaleFactor), e < 0 && (e = -1 * r.height * 72 / e / this.internal.scaleFactor), 0 === t && (t = e * r.width / r.height), 0 === e && (e = t * r.height / r.width), [
            t,
            e
        ];
    }, v = function(t, e, r, n, i, a) {
        var o = m.call(this, r, n, i), s = this.internal.getCoordinateString, c = this.internal.getVerticalCoordinateString, u = h.call(this);
        if (r = o[0], n = o[1], u[i.index] = i, a) {
            a *= Math.PI / 180;
            var l = Math.cos(a), f = Math.sin(a), d = function(t) {
                return t.toFixed(4);
            }, p = [
                d(l),
                d(f),
                d(-1 * f),
                d(l),
                0,
                0,
                "cm"
            ];
        }
        this.internal.write("q"), a ? (this.internal.write([
            1,
            "0",
            "0",
            1,
            s(t),
            c(e + n),
            "cm"
        ].join(" ")), this.internal.write(p.join(" ")), this.internal.write([
            s(r),
            "0",
            "0",
            s(n),
            "0",
            "0",
            "cm"
        ].join(" "))) : this.internal.write([
            s(r),
            "0",
            "0",
            s(n),
            s(t),
            c(e + n),
            "cm"
        ].join(" ")), this.isAdvancedAPI() && this.internal.write([
            1,
            0,
            0,
            -1,
            0,
            0,
            "cm"
        ].join(" ")), this.internal.write("/I" + i.index + " Do"), this.internal.write("Q");
    }, b = e.color_spaces = {
        DEVICE_RGB: "DeviceRGB",
        DEVICE_GRAY: "DeviceGray",
        DEVICE_CMYK: "DeviceCMYK",
        CAL_GREY: "CalGray",
        CAL_RGB: "CalRGB",
        LAB: "Lab",
        ICC_BASED: "ICCBased",
        INDEXED: "Indexed",
        PATTERN: "Pattern",
        SEPARATION: "Separation",
        DEVICE_N: "DeviceN"
    };
    e.decode = {
        DCT_DECODE: "DCTDecode",
        FLATE_DECODE: "FlateDecode",
        LZW_DECODE: "LZWDecode",
        JPX_DECODE: "JPXDecode",
        JBIG2_DECODE: "JBIG2Decode",
        ASCII85_DECODE: "ASCII85Decode",
        ASCII_HEX_DECODE: "ASCIIHexDecode",
        RUN_LENGTH_DECODE: "RunLengthDecode",
        CCITT_FAX_DECODE: "CCITTFaxDecode"
    };
    var y = e.image_compression = {
        NONE: "NONE",
        FAST: "FAST",
        MEDIUM: "MEDIUM",
        SLOW: "SLOW"
    }, w = e.__addimage__.sHashCode = function(t) {
        var e, r, n = 0;
        if ("string" == typeof t) for(r = t.length, e = 0; e < r; e++)n = (n << 5) - n + t.charCodeAt(e), n |= 0;
        else if (x(t)) for(r = t.byteLength / 2, e = 0; e < r; e++)n = (n << 5) - n + t[e], n |= 0;
        return n;
    }, N = e.__addimage__.validateStringAsBase64 = function(t) {
        (t = t || "").toString().trim();
        var e = !0;
        return 0 === t.length && (e = !1), t.length % 4 != 0 && (e = !1), !1 === /^[A-Za-z0-9+/]+$/.test(t.substr(0, t.length - 2)) && (e = !1), !1 === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t.substr(-2)) && (e = !1), e;
    }, L = e.__addimage__.extractImageFromDataUrl = function(t) {
        var e = (t = t || "").split("base64,"), r = null;
        if (2 === e.length) {
            var n = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e[0]);
            Array.isArray(n) && (r = {
                mimeType: n[1],
                charset: n[2],
                data: e[1]
            });
        }
        return r;
    }, A = e.__addimage__.supportsArrayBuffer = function() {
        return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
    };
    e.__addimage__.isArrayBuffer = function(t) {
        return A() && t instanceof ArrayBuffer;
    };
    var x = e.__addimage__.isArrayBufferView = function(t) {
        return A() && "undefined" != typeof Uint32Array && (t instanceof Int8Array || t instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array);
    }, S = e.__addimage__.binaryStringToUint8Array = function(t) {
        for(var e = t.length, r = new Uint8Array(e), n = 0; n < e; n++)r[n] = t.charCodeAt(n);
        return r;
    }, _ = e.__addimage__.arrayBufferToBinaryString = function(t) {
        for(var e = "", r = x(t) ? t : new Uint8Array(t), n = 0; n < r.length; n += 8192)e += String.fromCharCode.apply(null, r.subarray(n, n + 8192));
        return e;
    };
    e.addImage = function() {
        var e, n, i, a, o, s, u, h, l;
        if ("number" == typeof arguments[1] ? (n = r, i = arguments[1], a = arguments[2], o = arguments[3], s = arguments[4], u = arguments[5], h = arguments[6], l = arguments[7]) : (n = arguments[1], i = arguments[2], a = arguments[3], o = arguments[4], s = arguments[5], u = arguments[6], h = arguments[7], l = arguments[8]), "object" === (0, _typeofDefault.default)(e = arguments[0]) && !d(e) && "imageData" in e) {
            var f = e;
            e = f.imageData, n = f.format || n || r, i = f.x || i || 0, a = f.y || a || 0, o = f.w || f.width || o, s = f.h || f.height || s, u = f.alias || u, h = f.compression || h, l = f.rotation || f.angle || l;
        }
        var p = this.internal.getFilters();
        if (void 0 === h && -1 !== p.indexOf("FlateEncode") && (h = "SLOW"), isNaN(i) || isNaN(a)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
        c.call(this);
        var g = P.call(this, e, n, u, h);
        return v.call(this, i, a, o, s, g, l), this;
    };
    var P = function(t, n, a, o) {
        var s, c, u;
        if ("string" == typeof t && i(t) === r) {
            t = unescape(t);
            var h = k(t, !1);
            ("" !== h || void 0 !== (h = e.loadFile(t, !0))) && (t = h);
        }
        if (d(t) && (t = p(t, n)), n = i(t, n), !f(n)) throw new Error("addImage does not support files of type '" + n + "', please ensure that a plugin for '" + n + "' support is added.");
        if ((null == (u = a) || 0 === u.length) && (a = function(t) {
            return "string" == typeof t || x(t) ? w(t) : x(t.data) ? w(t.data) : null;
        }(t)), (s = g.call(this, a)) || (A() && (t instanceof Uint8Array || "RGBA" === n || (c = t, t = S(t))), s = this["process" + n.toUpperCase()](t, l.call(this), a, function(t) {
            return t && "string" == typeof t && (t = t.toUpperCase()), t in e.image_compression ? t : y.NONE;
        }(o), c)), !s) throw new Error("An unknown error occurred whilst processing the image.");
        return s;
    }, k = e.__addimage__.convertBase64ToBinaryString = function(t, e) {
        var r;
        e = "boolean" != typeof e || e;
        var n, i = "";
        if ("string" == typeof t) {
            n = null !== (r = L(t)) ? r.data : t;
            try {
                i = u(n);
            } catch (t) {
                if (e) throw N(n) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
            }
        }
        return i;
    };
    e.getImageProperties = function(t) {
        var n, a, o = "";
        if (d(t) && (t = p(t)), "string" == typeof t && i(t) === r && ("" === (o = k(t, !1)) && (o = e.loadFile(t) || ""), t = o), a = i(t), !f(a)) throw new Error("addImage does not support files of type '" + a + "', please ensure that a plugin for '" + a + "' support is added.");
        if (!A() || t instanceof Uint8Array || (t = S(t)), !(n = this["process" + a.toUpperCase()](t))) throw new Error("An unknown error occurred whilst processing the image");
        return n.fileType = a, n;
    };
}(E.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    var e = function(t) {
        if (void 0 !== t && "" != t) return !0;
    };
    E.API.events.push([
        "addPage",
        function(t) {
            this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
        }
    ]), t.events.push([
        "putPage",
        function(t) {
            for(var r, n, i, a = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, s = this.internal.getPageInfoByObjId(t.objId), c = t.pageContext.annotations, u = !1, h = 0; h < c.length && !u; h++)switch((r = c[h]).type){
                case "link":
                    (e(r.options.url) || e(r.options.pageNumber)) && (u = !0);
                    break;
                case "reference":
                case "text":
                case "freetext":
                    u = !0;
            }
            if (0 != u) {
                this.internal.write("/Annots [");
                for(var l = 0; l < c.length; l++){
                    r = c[l];
                    var f = this.internal.pdfEscape, d = this.internal.getEncryptor(t.objId);
                    switch(r.type){
                        case "reference":
                            this.internal.write(" " + r.object.objId + " 0 R ");
                            break;
                        case "text":
                            var p = this.internal.newAdditionalObject(), g = this.internal.newAdditionalObject(), m = this.internal.getEncryptor(p.objId), v = r.title || "Note";
                            i = "<</Type /Annot /Subtype /Text " + (n = "/Rect [" + a(r.bounds.x) + " " + o(r.bounds.y + r.bounds.h) + " " + a(r.bounds.x + r.bounds.w) + " " + o(r.bounds.y) + "] ") + "/Contents (" + f(m(r.contents)) + ")", i += " /Popup " + g.objId + " 0 R", i += " /P " + s.objId + " 0 R", i += " /T (" + f(m(v)) + ") >>", p.content = i;
                            var b = p.objId + " 0 R";
                            i = "<</Type /Annot /Subtype /Popup " + (n = "/Rect [" + a(r.bounds.x + 30) + " " + o(r.bounds.y + r.bounds.h) + " " + a(r.bounds.x + r.bounds.w + 30) + " " + o(r.bounds.y) + "] ") + " /Parent " + b, r.open && (i += " /Open true"), i += " >>", g.content = i, this.internal.write(p.objId, "0 R", g.objId, "0 R");
                            break;
                        case "freetext":
                            n = "/Rect [" + a(r.bounds.x) + " " + o(r.bounds.y) + " " + a(r.bounds.x + r.bounds.w) + " " + o(r.bounds.y + r.bounds.h) + "] ";
                            var y = r.color || "#000000";
                            i = "<</Type /Annot /Subtype /FreeText " + n + "/Contents (" + f(d(r.contents)) + ")", i += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y + ")", i += " /Border [0 0 0]", i += " >>", this.internal.write(i);
                            break;
                        case "link":
                            if (r.options.name) {
                                var w = this.annotations._nameMap[r.options.name];
                                r.options.pageNumber = w.page, r.options.top = w.y;
                            } else r.options.top || (r.options.top = 0);
                            if (n = "/Rect [" + r.finalBounds.x + " " + r.finalBounds.y + " " + r.finalBounds.w + " " + r.finalBounds.h + "] ", i = "", r.options.url) i = "<</Type /Annot /Subtype /Link " + n + "/Border [0 0 0] /A <</S /URI /URI (" + f(d(r.options.url)) + ") >>";
                            else if (r.options.pageNumber) switch(i = "<</Type /Annot /Subtype /Link " + n + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r.options.pageNumber).objId + " 0 R", r.options.magFactor = r.options.magFactor || "XYZ", r.options.magFactor){
                                case "Fit":
                                    i += " /Fit]";
                                    break;
                                case "FitH":
                                    i += " /FitH " + r.options.top + "]";
                                    break;
                                case "FitV":
                                    r.options.left = r.options.left || 0, i += " /FitV " + r.options.left + "]";
                                    break;
                                case "XYZ":
                                default:
                                    var N = o(r.options.top);
                                    r.options.left = r.options.left || 0, void 0 === r.options.zoom && (r.options.zoom = 0), i += " /XYZ " + r.options.left + " " + N + " " + r.options.zoom + "]";
                            }
                            "" != i && (i += " >>", this.internal.write(i));
                    }
                }
                this.internal.write("]");
            }
        }
    ]), t.createAnnotation = function(t) {
        var e = this.internal.getCurrentPageInfo();
        switch(t.type){
            case "link":
                this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
                break;
            case "text":
            case "freetext":
                e.pageContext.annotations.push(t);
        }
    }, t.link = function(t, e, r, n, i) {
        var a = this.internal.getCurrentPageInfo(), o = this.internal.getCoordinateString, s = this.internal.getVerticalCoordinateString;
        a.pageContext.annotations.push({
            finalBounds: {
                x: o(t),
                y: s(e),
                w: o(t + r),
                h: s(e + n)
            },
            options: i,
            type: "link"
        });
    }, t.textWithLink = function(t, e, r, n) {
        var i, a, o = this.getTextWidth(t), s = this.internal.getLineHeight() / this.internal.scaleFactor;
        if (void 0 !== n.maxWidth) {
            a = n.maxWidth;
            var c = this.splitTextToSize(t, a).length;
            i = Math.ceil(s * c);
        } else a = o, i = s;
        return this.text(t, e, r, n), r += .2 * s, "center" === n.align && (e -= o / 2), "right" === n.align && (e -= o), this.link(e, r - s, a, i, n), o;
    }, t.getTextWidth = function(t) {
        var e = this.internal.getFontSize();
        return this.getStringUnitWidth(t) * e / this.internal.scaleFactor;
    };
}(E.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    var e = {
        1569: [
            65152
        ],
        1570: [
            65153,
            65154
        ],
        1571: [
            65155,
            65156
        ],
        1572: [
            65157,
            65158
        ],
        1573: [
            65159,
            65160
        ],
        1574: [
            65161,
            65162,
            65163,
            65164
        ],
        1575: [
            65165,
            65166
        ],
        1576: [
            65167,
            65168,
            65169,
            65170
        ],
        1577: [
            65171,
            65172
        ],
        1578: [
            65173,
            65174,
            65175,
            65176
        ],
        1579: [
            65177,
            65178,
            65179,
            65180
        ],
        1580: [
            65181,
            65182,
            65183,
            65184
        ],
        1581: [
            65185,
            65186,
            65187,
            65188
        ],
        1582: [
            65189,
            65190,
            65191,
            65192
        ],
        1583: [
            65193,
            65194
        ],
        1584: [
            65195,
            65196
        ],
        1585: [
            65197,
            65198
        ],
        1586: [
            65199,
            65200
        ],
        1587: [
            65201,
            65202,
            65203,
            65204
        ],
        1588: [
            65205,
            65206,
            65207,
            65208
        ],
        1589: [
            65209,
            65210,
            65211,
            65212
        ],
        1590: [
            65213,
            65214,
            65215,
            65216
        ],
        1591: [
            65217,
            65218,
            65219,
            65220
        ],
        1592: [
            65221,
            65222,
            65223,
            65224
        ],
        1593: [
            65225,
            65226,
            65227,
            65228
        ],
        1594: [
            65229,
            65230,
            65231,
            65232
        ],
        1601: [
            65233,
            65234,
            65235,
            65236
        ],
        1602: [
            65237,
            65238,
            65239,
            65240
        ],
        1603: [
            65241,
            65242,
            65243,
            65244
        ],
        1604: [
            65245,
            65246,
            65247,
            65248
        ],
        1605: [
            65249,
            65250,
            65251,
            65252
        ],
        1606: [
            65253,
            65254,
            65255,
            65256
        ],
        1607: [
            65257,
            65258,
            65259,
            65260
        ],
        1608: [
            65261,
            65262
        ],
        1609: [
            65263,
            65264,
            64488,
            64489
        ],
        1610: [
            65265,
            65266,
            65267,
            65268
        ],
        1649: [
            64336,
            64337
        ],
        1655: [
            64477
        ],
        1657: [
            64358,
            64359,
            64360,
            64361
        ],
        1658: [
            64350,
            64351,
            64352,
            64353
        ],
        1659: [
            64338,
            64339,
            64340,
            64341
        ],
        1662: [
            64342,
            64343,
            64344,
            64345
        ],
        1663: [
            64354,
            64355,
            64356,
            64357
        ],
        1664: [
            64346,
            64347,
            64348,
            64349
        ],
        1667: [
            64374,
            64375,
            64376,
            64377
        ],
        1668: [
            64370,
            64371,
            64372,
            64373
        ],
        1670: [
            64378,
            64379,
            64380,
            64381
        ],
        1671: [
            64382,
            64383,
            64384,
            64385
        ],
        1672: [
            64392,
            64393
        ],
        1676: [
            64388,
            64389
        ],
        1677: [
            64386,
            64387
        ],
        1678: [
            64390,
            64391
        ],
        1681: [
            64396,
            64397
        ],
        1688: [
            64394,
            64395
        ],
        1700: [
            64362,
            64363,
            64364,
            64365
        ],
        1702: [
            64366,
            64367,
            64368,
            64369
        ],
        1705: [
            64398,
            64399,
            64400,
            64401
        ],
        1709: [
            64467,
            64468,
            64469,
            64470
        ],
        1711: [
            64402,
            64403,
            64404,
            64405
        ],
        1713: [
            64410,
            64411,
            64412,
            64413
        ],
        1715: [
            64406,
            64407,
            64408,
            64409
        ],
        1722: [
            64414,
            64415
        ],
        1723: [
            64416,
            64417,
            64418,
            64419
        ],
        1726: [
            64426,
            64427,
            64428,
            64429
        ],
        1728: [
            64420,
            64421
        ],
        1729: [
            64422,
            64423,
            64424,
            64425
        ],
        1733: [
            64480,
            64481
        ],
        1734: [
            64473,
            64474
        ],
        1735: [
            64471,
            64472
        ],
        1736: [
            64475,
            64476
        ],
        1737: [
            64482,
            64483
        ],
        1739: [
            64478,
            64479
        ],
        1740: [
            64508,
            64509,
            64510,
            64511
        ],
        1744: [
            64484,
            64485,
            64486,
            64487
        ],
        1746: [
            64430,
            64431
        ],
        1747: [
            64432,
            64433
        ]
    }, r = {
        65247: {
            65154: 65269,
            65156: 65271,
            65160: 65273,
            65166: 65275
        },
        65248: {
            65154: 65270,
            65156: 65272,
            65160: 65274,
            65166: 65276
        },
        65165: {
            65247: {
                65248: {
                    65258: 65010
                }
            }
        },
        1617: {
            1612: 64606,
            1613: 64607,
            1614: 64608,
            1615: 64609,
            1616: 64610
        }
    }, n = {
        1612: 64606,
        1613: 64607,
        1614: 64608,
        1615: 64609,
        1616: 64610
    }, i = [
        1570,
        1571,
        1573,
        1575
    ];
    t.__arabicParser__ = {};
    var a = t.__arabicParser__.isInArabicSubstitutionA = function(t) {
        return void 0 !== e[t.charCodeAt(0)];
    }, o = t.__arabicParser__.isArabicLetter = function(t) {
        return "string" == typeof t && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t);
    }, s = t.__arabicParser__.isArabicEndLetter = function(t) {
        return o(t) && a(t) && e[t.charCodeAt(0)].length <= 2;
    }, c = t.__arabicParser__.isArabicAlfLetter = function(t) {
        return o(t) && i.indexOf(t.charCodeAt(0)) >= 0;
    };
    t.__arabicParser__.arabicLetterHasIsolatedForm = function(t) {
        return o(t) && a(t) && e[t.charCodeAt(0)].length >= 1;
    };
    var u = t.__arabicParser__.arabicLetterHasFinalForm = function(t) {
        return o(t) && a(t) && e[t.charCodeAt(0)].length >= 2;
    };
    t.__arabicParser__.arabicLetterHasInitialForm = function(t) {
        return o(t) && a(t) && e[t.charCodeAt(0)].length >= 3;
    };
    var h = t.__arabicParser__.arabicLetterHasMedialForm = function(t) {
        return o(t) && a(t) && 4 == e[t.charCodeAt(0)].length;
    }, l = t.__arabicParser__.resolveLigatures = function(t) {
        var e = 0, n = r, i = "", a = 0;
        for(e = 0; e < t.length; e += 1)void 0 !== n[t.charCodeAt(e)] ? (a++, "number" == typeof (n = n[t.charCodeAt(e)]) && (i += String.fromCharCode(n), n = r, a = 0), e === t.length - 1 && (n = r, i += t.charAt(e - (a - 1)), e -= a - 1, a = 0)) : (n = r, i += t.charAt(e - a), e -= a, a = 0);
        return i;
    };
    t.__arabicParser__.isArabicDiacritic = function(t) {
        return void 0 !== t && void 0 !== n[t.charCodeAt(0)];
    };
    var f = t.__arabicParser__.getCorrectForm = function(t, e, r) {
        return o(t) ? !1 === a(t) ? -1 : !u(t) || !o(e) && !o(r) || !o(r) && s(e) || s(t) && !o(e) || s(t) && c(e) || s(t) && s(e) ? 0 : h(t) && o(e) && !s(e) && o(r) && u(r) ? 3 : s(t) || !o(r) ? 1 : 2 : -1;
    }, d = function(t) {
        var r = 0, n = 0, i = 0, a = "", s = "", c = "", u = (t = t || "").split("\\s+"), h = [];
        for(r = 0; r < u.length; r += 1){
            for(h.push(""), n = 0; n < u[r].length; n += 1)a = u[r][n], s = u[r][n - 1], c = u[r][n + 1], o(a) ? (i = f(a, s, c), h[r] += -1 !== i ? String.fromCharCode(e[a.charCodeAt(0)][i]) : a) : h[r] += a;
            h[r] = l(h[r]);
        }
        return h.join(" ");
    }, p = t.__arabicParser__.processArabic = t.processArabic = function() {
        var t, e = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, r = [];
        if (Array.isArray(e)) {
            var n = 0;
            for(r = [], n = 0; n < e.length; n += 1)Array.isArray(e[n]) ? r.push([
                d(e[n][0]),
                e[n][1],
                e[n][2]
            ]) : r.push([
                d(e[n])
            ]);
            t = r;
        } else t = d(e);
        return "string" == typeof arguments[0] ? t : (arguments[0].text = t, arguments[0]);
    };
    t.events.push([
        "preProcessText",
        p
    ]);
}(E.API), E.API.autoPrint = function(t) {
    var e;
    switch((t = t || {}).variant = t.variant || "non-conform", t.variant){
        case "javascript":
            this.addJS("print({});");
            break;
        case "non-conform":
        default:
            this.internal.events.subscribe("postPutResources", function() {
                e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
            }), this.internal.events.subscribe("putCatalog", function() {
                this.internal.out("/OpenAction " + e + " 0 R");
            });
    }
    return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    var e = function() {
        var t = void 0;
        Object.defineProperty(this, "pdf", {
            get: function() {
                return t;
            },
            set: function(e) {
                t = e;
            }
        });
        var e = 150;
        Object.defineProperty(this, "width", {
            get: function() {
                return e;
            },
            set: function(t) {
                e = isNaN(t) || !1 === Number.isInteger(t) || t < 0 ? 150 : t, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e + 1);
            }
        });
        var r = 300;
        Object.defineProperty(this, "height", {
            get: function() {
                return r;
            },
            set: function(t) {
                r = isNaN(t) || !1 === Number.isInteger(t) || t < 0 ? 300 : t, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
            }
        });
        var n = [];
        Object.defineProperty(this, "childNodes", {
            get: function() {
                return n;
            },
            set: function(t) {
                n = t;
            }
        });
        var i = {};
        Object.defineProperty(this, "style", {
            get: function() {
                return i;
            },
            set: function(t) {
                i = t;
            }
        }), Object.defineProperty(this, "parentNode", {});
    };
    e.prototype.getContext = function(t, e) {
        var r;
        if ("2d" !== (t = t || "2d")) return null;
        for(r in e)this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = e[r]);
        return this.pdf.context2d._canvas = this, this.pdf.context2d;
    }, e.prototype.toDataURL = function() {
        throw new Error("toDataURL is not implemented.");
    }, t.events.push([
        "initialized",
        function() {
            this.canvas = new e, this.canvas.pdf = this;
        }
    ]);
}(E.API), function(e) {
    var r = {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0
    }, n = !1, i = function() {
        void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r), this.internal.__cell__.margins.width = this.getPageWidth(), a.call(this));
    }, a = function() {
        this.internal.__cell__.lastCell = new o, this.internal.__cell__.pages = 1;
    }, o = function() {
        var t = arguments[0];
        Object.defineProperty(this, "x", {
            enumerable: !0,
            get: function() {
                return t;
            },
            set: function(e) {
                t = e;
            }
        });
        var e = arguments[1];
        Object.defineProperty(this, "y", {
            enumerable: !0,
            get: function() {
                return e;
            },
            set: function(t) {
                e = t;
            }
        });
        var r = arguments[2];
        Object.defineProperty(this, "width", {
            enumerable: !0,
            get: function() {
                return r;
            },
            set: function(t) {
                r = t;
            }
        });
        var n = arguments[3];
        Object.defineProperty(this, "height", {
            enumerable: !0,
            get: function() {
                return n;
            },
            set: function(t) {
                n = t;
            }
        });
        var i = arguments[4];
        Object.defineProperty(this, "text", {
            enumerable: !0,
            get: function() {
                return i;
            },
            set: function(t) {
                i = t;
            }
        });
        var a = arguments[5];
        Object.defineProperty(this, "lineNumber", {
            enumerable: !0,
            get: function() {
                return a;
            },
            set: function(t) {
                a = t;
            }
        });
        var o = arguments[6];
        return Object.defineProperty(this, "align", {
            enumerable: !0,
            get: function() {
                return o;
            },
            set: function(t) {
                o = t;
            }
        }), this;
    };
    o.prototype.clone = function() {
        return new o(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
    }, o.prototype.toArray = function() {
        return [
            this.x,
            this.y,
            this.width,
            this.height,
            this.text,
            this.lineNumber,
            this.align
        ];
    }, e.setHeaderFunction = function(t) {
        return i.call(this), this.internal.__cell__.headerFunction = "function" == typeof t ? t : void 0, this;
    }, e.getTextDimensions = function(t, e) {
        i.call(this);
        var r = (e = e || {}).fontSize || this.getFontSize(), n = e.font || this.getFont(), a = e.scaleFactor || this.internal.scaleFactor, o = 0, s = 0, c = 0, u = this;
        if (!Array.isArray(t) && "string" != typeof t) {
            if ("number" != typeof t) throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
            t = String(t);
        }
        var h = e.maxWidth;
        h > 0 ? "string" == typeof t ? t = this.splitTextToSize(t, h) : "[object Array]" === Object.prototype.toString.call(t) && (t = t.reduce(function(t, e) {
            return t.concat(u.splitTextToSize(e, h));
        }, [])) : t = Array.isArray(t) ? t : [
            t
        ];
        for(var l = 0; l < t.length; l++)o < (c = this.getStringUnitWidth(t[l], {
            font: n
        }) * r) && (o = c);
        return 0 !== o && (s = t.length), {
            w: o /= a,
            h: Math.max((s * r * this.getLineHeightFactor() - r * (this.getLineHeightFactor() - 1)) / a, 0)
        };
    }, e.cellAddPage = function() {
        i.call(this), this.addPage();
        var t = this.internal.__cell__.margins || r;
        return this.internal.__cell__.lastCell = new o(t.left, t.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
    };
    var s = e.cell = function() {
        var t;
        t = arguments[0] instanceof o ? arguments[0] : new o(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i.call(this);
        var e = this.internal.__cell__.lastCell, a = this.internal.__cell__.padding, s = this.internal.__cell__.margins || r, c = this.internal.__cell__.tableHeaderRow, u = this.internal.__cell__.printHeaders;
        return void 0 !== e.lineNumber && (e.lineNumber === t.lineNumber ? (t.x = (e.x || 0) + (e.width || 0), t.y = e.y || 0) : e.y + e.height + t.height + s.bottom > this.getPageHeight() ? (this.cellAddPage(), t.y = s.top, u && c && (this.printHeaderRow(t.lineNumber, !0), t.y += c[0].height)) : t.y = e.y + e.height || t.y), void 0 !== t.text[0] && (this.rect(t.x, t.y, t.width, t.height, !0 === n ? "FD" : void 0), "right" === t.align ? this.text(t.text, t.x + t.width - a, t.y + a, {
            align: "right",
            baseline: "top"
        }) : "center" === t.align ? this.text(t.text, t.x + t.width / 2, t.y + a, {
            align: "center",
            baseline: "top",
            maxWidth: t.width - a - a
        }) : this.text(t.text, t.x + a, t.y + a, {
            align: "left",
            baseline: "top",
            maxWidth: t.width - a - a
        })), this.internal.__cell__.lastCell = t, this;
    };
    e.table = function(e, n, u, h, l) {
        if (i.call(this), !u) throw new Error("No data for PDF table.");
        var f, d, p, g, m = [], v = [], b = [], y = {}, w = {}, N = [], L = [], A = (l = l || {}).autoSize || !1, x = !1 !== l.printHeaders, S = l.css && void 0 !== l.css["font-size"] ? 16 * l.css["font-size"] : l.fontSize || 12, _ = l.margins || Object.assign({
            width: this.getPageWidth()
        }, r), P = "number" == typeof l.padding ? l.padding : 3, k = l.headerBackgroundColor || "#c8c8c8", I = l.headerTextColor || "#000";
        if (a.call(this), this.internal.__cell__.printHeaders = x, this.internal.__cell__.margins = _, this.internal.__cell__.table_font_size = S, this.internal.__cell__.padding = P, this.internal.__cell__.headerBackgroundColor = k, this.internal.__cell__.headerTextColor = I, this.setFontSize(S), null == h) v = m = Object.keys(u[0]), b = m.map(function() {
            return "left";
        });
        else if (Array.isArray(h) && "object" === (0, _typeofDefault.default)(h[0])) for(m = h.map(function(t) {
            return t.name;
        }), v = h.map(function(t) {
            return t.prompt || t.name || "";
        }), b = h.map(function(t) {
            return t.align || "left";
        }), f = 0; f < h.length; f += 1)w[h[f].name] = h[f].width * (19.049976 / 25.4);
        else Array.isArray(h) && "string" == typeof h[0] && (v = m = h, b = m.map(function() {
            return "left";
        }));
        if (A || Array.isArray(h) && "string" == typeof h[0]) for(f = 0; f < m.length; f += 1){
            for(y[g = m[f]] = u.map(function(t) {
                return t[g];
            }), this.setFont(void 0, "bold"), N.push(this.getTextDimensions(v[f], {
                fontSize: this.internal.__cell__.table_font_size,
                scaleFactor: this.internal.scaleFactor
            }).w), d = y[g], this.setFont(void 0, "normal"), p = 0; p < d.length; p += 1)N.push(this.getTextDimensions(d[p], {
                fontSize: this.internal.__cell__.table_font_size,
                scaleFactor: this.internal.scaleFactor
            }).w);
            w[g] = Math.max.apply(null, N) + P + P, N = [];
        }
        if (x) {
            var F = {};
            for(f = 0; f < m.length; f += 1)F[m[f]] = {}, F[m[f]].text = v[f], F[m[f]].align = b[f];
            var C = c.call(this, F, w);
            L = m.map(function(t) {
                return new o(e, n, w[t], C, F[t].text, void 0, F[t].align);
            }), this.setTableHeaderRow(L), this.printHeaderRow(1, !1);
        }
        var j = h.reduce(function(t, e) {
            return t[e.name] = e.align, t;
        }, {});
        for(f = 0; f < u.length; f += 1){
            "rowStart" in l && l.rowStart instanceof Function && l.rowStart({
                row: f,
                data: u[f]
            }, this);
            var O = c.call(this, u[f], w);
            for(p = 0; p < m.length; p += 1){
                var B = u[f][m[p]];
                "cellStart" in l && l.cellStart instanceof Function && l.cellStart({
                    row: f,
                    col: p,
                    data: B
                }, this), s.call(this, new o(e, n, w[m[p]], O, B, f + 2, j[m[p]]));
            }
        }
        return this.internal.__cell__.table_x = e, this.internal.__cell__.table_y = n, this;
    };
    var c = function(t, e) {
        var r = this.internal.__cell__.padding, n = this.internal.__cell__.table_font_size, i = this.internal.scaleFactor;
        return Object.keys(t).map(function(n) {
            var i = t[n];
            return this.splitTextToSize(i.hasOwnProperty("text") ? i.text : i, e[n] - r - r);
        }, this).map(function(t) {
            return this.getLineHeightFactor() * t.length * n / i + r + r;
        }, this).reduce(function(t, e) {
            return Math.max(t, e);
        }, 0);
    };
    e.setTableHeaderRow = function(t) {
        i.call(this), this.internal.__cell__.tableHeaderRow = t;
    }, e.printHeaderRow = function(t, e) {
        if (i.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
        var r;
        if (n = !0, "function" == typeof this.internal.__cell__.headerFunction) {
            var a = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
            this.internal.__cell__.lastCell = new o(a[0], a[1], a[2], a[3], void 0, -1);
        }
        this.setFont(void 0, "bold");
        for(var c = [], u = 0; u < this.internal.__cell__.tableHeaderRow.length; u += 1){
            r = this.internal.__cell__.tableHeaderRow[u].clone(), e && (r.y = this.internal.__cell__.margins.top || 0, c.push(r)), r.lineNumber = t;
            var h = this.getTextColor();
            this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s.call(this, r), this.setTextColor(h);
        }
        c.length > 0 && this.setTableHeaderRow(c), this.setFont(void 0, "normal"), n = !1;
    };
}(E.API);
var Pt = {
    italic: [
        "italic",
        "oblique",
        "normal"
    ],
    oblique: [
        "oblique",
        "italic",
        "normal"
    ],
    normal: [
        "normal",
        "oblique",
        "italic"
    ]
}, kt = [
    "ultra-condensed",
    "extra-condensed",
    "condensed",
    "semi-condensed",
    "normal",
    "semi-expanded",
    "expanded",
    "extra-expanded",
    "ultra-expanded"
], It = _t(kt), Ft = [
    100,
    200,
    300,
    400,
    500,
    600,
    700,
    800,
    900
], Ct = _t(Ft);
function jt(t) {
    var e = t.family.replace(/"|'/g, "").toLowerCase(), r = function(t) {
        return Pt[t = t || "normal"] ? t : "normal";
    }(t.style), n = function(t) {
        if (!t) return 400;
        if ("number" == typeof t) return t >= 100 && t <= 900 && t % 100 == 0 ? t : 400;
        if (/^\d00$/.test(t)) return parseInt(t);
        switch(t){
            case "bold":
                return 700;
            case "normal":
            default:
                return 400;
        }
    }(t.weight), i = function(t) {
        return "number" == typeof It[t = t || "normal"] ? t : "normal";
    }(t.stretch);
    return {
        family: e,
        style: r,
        weight: n,
        stretch: i,
        src: t.src || [],
        ref: t.ref || {
            name: e,
            style: [
                i,
                r,
                n
            ].join(" ")
        }
    };
}
function Ot(t, e, r, n) {
    var i;
    for(i = r; i >= 0 && i < e.length; i += n)if (t[e[i]]) return t[e[i]];
    for(i = r; i >= 0 && i < e.length; i -= n)if (t[e[i]]) return t[e[i]];
}
var Bt = {
    "sans-serif": "helvetica",
    fixed: "courier",
    monospace: "courier",
    terminal: "courier",
    cursive: "times",
    fantasy: "times",
    serif: "times"
}, Mt = {
    caption: "times",
    icon: "times",
    menu: "times",
    "message-box": "times",
    "small-caption": "times",
    "status-bar": "times"
};
function Et(t) {
    return [
        t.stretch,
        t.style,
        t.weight,
        t.family
    ].join(" ");
}
function qt(t, e, r) {
    for(var n = (r = r || {}).defaultFontFamily || "times", i = Object.assign({}, Bt, r.genericFontFamilies || {}), a = null, o = null, s = 0; s < e.length; ++s)if (i[(a = jt(e[s])).family] && (a.family = i[a.family]), t.hasOwnProperty(a.family)) {
        o = t[a.family];
        break;
    }
    if (!(o = o || t[n])) throw new Error("Could not find a font-family for the rule '" + Et(a) + "' and default family '" + n + "'.");
    if (o = function(t, e) {
        if (e[t]) return e[t];
        var r = It[t], n = r <= It.normal ? -1 : 1, i = Ot(e, kt, r, n);
        if (!i) throw new Error("Could not find a matching font-stretch value for " + t);
        return i;
    }(a.stretch, o), o = function(t, e) {
        if (e[t]) return e[t];
        for(var r = Pt[t], n = 0; n < r.length; ++n)if (e[r[n]]) return e[r[n]];
        throw new Error("Could not find a matching font-style for " + t);
    }(a.style, o), !(o = function(t, e) {
        if (e[t]) return e[t];
        if (400 === t && e[500]) return e[500];
        if (500 === t && e[400]) return e[400];
        var r = Ct[t], n = Ot(e, Ft, r, t < 400 ? -1 : 1);
        if (!n) throw new Error("Could not find a matching font-weight for value " + t);
        return n;
    }(a.weight, o))) throw new Error("Failed to resolve a font for the rule '" + Et(a) + "'.");
    return o;
}
function Dt(t) {
    return t.trimLeft();
}
function Rt(t, e) {
    for(var r = 0; r < t.length;){
        if (t.charAt(r) === e) return [
            t.substring(0, r),
            t.substring(r + 1)
        ];
        r += 1;
    }
    return null;
}
function Tt(t) {
    var e = t.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
    return null === e ? null : [
        e[0],
        t.substring(e[0].length)
    ];
}
var Ut, zt, Ht, Wt = [
    "times"
];
!function(e) {
    var r, n, i, o, s, c, u, h, l, d = function(t) {
        return t = t || {}, this.isStrokeTransparent = t.isStrokeTransparent || !1, this.strokeOpacity = t.strokeOpacity || 1, this.strokeStyle = t.strokeStyle || "#000000", this.fillStyle = t.fillStyle || "#000000", this.isFillTransparent = t.isFillTransparent || !1, this.fillOpacity = t.fillOpacity || 1, this.font = t.font || "10px sans-serif", this.textBaseline = t.textBaseline || "alphabetic", this.textAlign = t.textAlign || "left", this.lineWidth = t.lineWidth || 1, this.lineJoin = t.lineJoin || "miter", this.lineCap = t.lineCap || "butt", this.path = t.path || [], this.transform = void 0 !== t.transform ? t.transform.clone() : new h, this.globalCompositeOperation = t.globalCompositeOperation || "normal", this.globalAlpha = t.globalAlpha || 1, this.clip_path = t.clip_path || [], this.currentPoint = t.currentPoint || new c, this.miterLimit = t.miterLimit || 10, this.lastPoint = t.lastPoint || new c, this.lineDashOffset = t.lineDashOffset || 0, this.lineDash = t.lineDash || [], this.margin = t.margin || [
            0,
            0,
            0,
            0
        ], this.prevPageLastElemOffset = t.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t.ignoreClearRect || t.ignoreClearRect, this;
    };
    e.events.push([
        "initialized",
        function() {
            this.context2d = new p(this), r = this.internal.f2, n = this.internal.getCoordinateString, i = this.internal.getVerticalCoordinateString, o = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, c = this.internal.Point, u = this.internal.Rectangle, h = this.internal.Matrix, l = new d;
        }
    ]);
    var p = function(t) {
        Object.defineProperty(this, "canvas", {
            get: function() {
                return {
                    parentNode: !1,
                    style: !1
                };
            }
        });
        var e = t;
        Object.defineProperty(this, "pdf", {
            get: function() {
                return e;
            }
        });
        var r = !1;
        Object.defineProperty(this, "pageWrapXEnabled", {
            get: function() {
                return r;
            },
            set: function(t) {
                r = Boolean(t);
            }
        });
        var n = !1;
        Object.defineProperty(this, "pageWrapYEnabled", {
            get: function() {
                return n;
            },
            set: function(t) {
                n = Boolean(t);
            }
        });
        var i = 0;
        Object.defineProperty(this, "posX", {
            get: function() {
                return i;
            },
            set: function(t) {
                isNaN(t) || (i = t);
            }
        });
        var a = 0;
        Object.defineProperty(this, "posY", {
            get: function() {
                return a;
            },
            set: function(t) {
                isNaN(t) || (a = t);
            }
        }), Object.defineProperty(this, "margin", {
            get: function() {
                return l.margin;
            },
            set: function(t) {
                var e;
                "number" == typeof t ? e = [
                    t,
                    t,
                    t,
                    t
                ] : ((e = new Array(4))[0] = t[0], e[1] = t.length >= 2 ? t[1] : e[0], e[2] = t.length >= 3 ? t[2] : e[0], e[3] = t.length >= 4 ? t[3] : e[1]), l.margin = e;
            }
        });
        var o = !1;
        Object.defineProperty(this, "autoPaging", {
            get: function() {
                return o;
            },
            set: function(t) {
                o = t;
            }
        });
        var s = 0;
        Object.defineProperty(this, "lastBreak", {
            get: function() {
                return s;
            },
            set: function(t) {
                s = t;
            }
        });
        var c = [];
        Object.defineProperty(this, "pageBreaks", {
            get: function() {
                return c;
            },
            set: function(t) {
                c = t;
            }
        }), Object.defineProperty(this, "ctx", {
            get: function() {
                return l;
            },
            set: function(t) {
                t instanceof d && (l = t);
            }
        }), Object.defineProperty(this, "path", {
            get: function() {
                return l.path;
            },
            set: function(t) {
                l.path = t;
            }
        });
        var u = [];
        Object.defineProperty(this, "ctxStack", {
            get: function() {
                return u;
            },
            set: function(t) {
                u = t;
            }
        }), Object.defineProperty(this, "fillStyle", {
            get: function() {
                return this.ctx.fillStyle;
            },
            set: function(t) {
                var e;
                e = g(t), this.ctx.fillStyle = e.style, this.ctx.isFillTransparent = 0 === e.a, this.ctx.fillOpacity = e.a, this.pdf.setFillColor(e.r, e.g, e.b, {
                    a: e.a
                }), this.pdf.setTextColor(e.r, e.g, e.b, {
                    a: e.a
                });
            }
        }), Object.defineProperty(this, "strokeStyle", {
            get: function() {
                return this.ctx.strokeStyle;
            },
            set: function(t) {
                var e = g(t);
                this.ctx.strokeStyle = e.style, this.ctx.isStrokeTransparent = 0 === e.a, this.ctx.strokeOpacity = e.a, 0 === e.a ? this.pdf.setDrawColor(255, 255, 255) : (e.a, this.pdf.setDrawColor(e.r, e.g, e.b));
            }
        }), Object.defineProperty(this, "lineCap", {
            get: function() {
                return this.ctx.lineCap;
            },
            set: function(t) {
                -1 !== [
                    "butt",
                    "round",
                    "square"
                ].indexOf(t) && (this.ctx.lineCap = t, this.pdf.setLineCap(t));
            }
        }), Object.defineProperty(this, "lineWidth", {
            get: function() {
                return this.ctx.lineWidth;
            },
            set: function(t) {
                isNaN(t) || (this.ctx.lineWidth = t, this.pdf.setLineWidth(t));
            }
        }), Object.defineProperty(this, "lineJoin", {
            get: function() {
                return this.ctx.lineJoin;
            },
            set: function(t) {
                -1 !== [
                    "bevel",
                    "round",
                    "miter"
                ].indexOf(t) && (this.ctx.lineJoin = t, this.pdf.setLineJoin(t));
            }
        }), Object.defineProperty(this, "miterLimit", {
            get: function() {
                return this.ctx.miterLimit;
            },
            set: function(t) {
                isNaN(t) || (this.ctx.miterLimit = t, this.pdf.setMiterLimit(t));
            }
        }), Object.defineProperty(this, "textBaseline", {
            get: function() {
                return this.ctx.textBaseline;
            },
            set: function(t) {
                this.ctx.textBaseline = t;
            }
        }), Object.defineProperty(this, "textAlign", {
            get: function() {
                return this.ctx.textAlign;
            },
            set: function(t) {
                -1 !== [
                    "right",
                    "end",
                    "center",
                    "left",
                    "start"
                ].indexOf(t) && (this.ctx.textAlign = t);
            }
        });
        var h = null;
        function f(t, e) {
            if (null === h) {
                var r = function(t) {
                    var e = [];
                    return Object.keys(t).forEach(function(r) {
                        t[r].forEach(function(t) {
                            var n = null;
                            switch(t){
                                case "bold":
                                    n = {
                                        family: r,
                                        weight: "bold"
                                    };
                                    break;
                                case "italic":
                                    n = {
                                        family: r,
                                        style: "italic"
                                    };
                                    break;
                                case "bolditalic":
                                    n = {
                                        family: r,
                                        weight: "bold",
                                        style: "italic"
                                    };
                                    break;
                                case "":
                                case "normal":
                                    n = {
                                        family: r
                                    };
                            }
                            null !== n && (n.ref = {
                                name: r,
                                style: t
                            }, e.push(n));
                        });
                    }), e;
                }(t.getFontList());
                h = function(t) {
                    for(var e = {}, r = 0; r < t.length; ++r){
                        var n = jt(t[r]), i = n.family, a = n.stretch, o = n.style, s = n.weight;
                        e[i] = e[i] || {}, e[i][a] = e[i][a] || {}, e[i][a][o] = e[i][a][o] || {}, e[i][a][o][s] = n;
                    }
                    return e;
                }(r.concat(e));
            }
            return h;
        }
        var p = null;
        Object.defineProperty(this, "fontFaces", {
            get: function() {
                return p;
            },
            set: function(t) {
                h = null, p = t;
            }
        }), Object.defineProperty(this, "font", {
            get: function() {
                return this.ctx.font;
            },
            set: function(t) {
                var e;
                if (this.ctx.font = t, null !== (e = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t))) {
                    var r = e[1], n = (e[2], e[3]), i = e[4], a = (e[5], e[6]), o = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i)[2];
                    i = "px" === o ? Math.floor(parseFloat(i) * this.pdf.internal.scaleFactor) : "em" === o ? Math.floor(parseFloat(i) * this.pdf.getFontSize()) : Math.floor(parseFloat(i) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i);
                    var s = function(t) {
                        var e, r, n = [], i = t.trim();
                        if ("" === i) return Wt;
                        if (i in Mt) return [
                            Mt[i]
                        ];
                        for(; "" !== i;){
                            switch(r = null, e = (i = Dt(i)).charAt(0)){
                                case '"':
                                case "'":
                                    r = Rt(i.substring(1), e);
                                    break;
                                default:
                                    r = Tt(i);
                            }
                            if (null === r) return Wt;
                            if (n.push(r[0]), "" !== (i = Dt(r[1])) && "," !== i.charAt(0)) return Wt;
                            i = i.replace(/^,/, "");
                        }
                        return n;
                    }(a);
                    if (this.fontFaces) {
                        var c = qt(f(this.pdf, this.fontFaces), s.map(function(t) {
                            return {
                                family: t,
                                stretch: "normal",
                                weight: n,
                                style: r
                            };
                        }));
                        this.pdf.setFont(c.ref.name, c.ref.style);
                    } else {
                        var u = "";
                        ("bold" === n || parseInt(n, 10) >= 700 || "bold" === r) && (u = "bold"), "italic" === r && (u += "italic"), 0 === u.length && (u = "normal");
                        for(var h = "", l = {
                            arial: "Helvetica",
                            Arial: "Helvetica",
                            verdana: "Helvetica",
                            Verdana: "Helvetica",
                            helvetica: "Helvetica",
                            Helvetica: "Helvetica",
                            "sans-serif": "Helvetica",
                            fixed: "Courier",
                            monospace: "Courier",
                            terminal: "Courier",
                            cursive: "Times",
                            fantasy: "Times",
                            serif: "Times"
                        }, d = 0; d < s.length; d++){
                            if (void 0 !== this.pdf.internal.getFont(s[d], u, {
                                noFallback: !0,
                                disableWarning: !0
                            })) {
                                h = s[d];
                                break;
                            }
                            if ("bolditalic" === u && void 0 !== this.pdf.internal.getFont(s[d], "bold", {
                                noFallback: !0,
                                disableWarning: !0
                            })) h = s[d], u = "bold";
                            else if (void 0 !== this.pdf.internal.getFont(s[d], "normal", {
                                noFallback: !0,
                                disableWarning: !0
                            })) {
                                h = s[d], u = "normal";
                                break;
                            }
                        }
                        if ("" === h) {
                            for(var p = 0; p < s.length; p++)if (l[s[p]]) {
                                h = l[s[p]];
                                break;
                            }
                        }
                        h = "" === h ? "Times" : h, this.pdf.setFont(h, u);
                    }
                }
            }
        }), Object.defineProperty(this, "globalCompositeOperation", {
            get: function() {
                return this.ctx.globalCompositeOperation;
            },
            set: function(t) {
                this.ctx.globalCompositeOperation = t;
            }
        }), Object.defineProperty(this, "globalAlpha", {
            get: function() {
                return this.ctx.globalAlpha;
            },
            set: function(t) {
                this.ctx.globalAlpha = t;
            }
        }), Object.defineProperty(this, "lineDashOffset", {
            get: function() {
                return this.ctx.lineDashOffset;
            },
            set: function(t) {
                this.ctx.lineDashOffset = t, T.call(this);
            }
        }), Object.defineProperty(this, "lineDash", {
            get: function() {
                return this.ctx.lineDash;
            },
            set: function(t) {
                this.ctx.lineDash = t, T.call(this);
            }
        }), Object.defineProperty(this, "ignoreClearRect", {
            get: function() {
                return this.ctx.ignoreClearRect;
            },
            set: function(t) {
                this.ctx.ignoreClearRect = Boolean(t);
            }
        });
    };
    p.prototype.setLineDash = function(t) {
        this.lineDash = t;
    }, p.prototype.getLineDash = function() {
        return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
    }, p.prototype.fill = function() {
        A.call(this, "fill", !1);
    }, p.prototype.stroke = function() {
        A.call(this, "stroke", !1);
    }, p.prototype.beginPath = function() {
        this.path = [
            {
                type: "begin"
            }
        ];
    }, p.prototype.moveTo = function(t, e) {
        if (isNaN(t) || isNaN(e)) throw a.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
        var r = this.ctx.transform.applyToPoint(new c(t, e));
        this.path.push({
            type: "mt",
            x: r.x,
            y: r.y
        }), this.ctx.lastPoint = new c(t, e);
    }, p.prototype.closePath = function() {
        var e = new c(0, 0), r = 0;
        for(r = this.path.length - 1; -1 !== r; r--)if ("begin" === this.path[r].type && "object" === (0, _typeofDefault.default)(this.path[r + 1]) && "number" == typeof this.path[r + 1].x) {
            e = new c(this.path[r + 1].x, this.path[r + 1].y);
            break;
        }
        this.path.push({
            type: "close"
        }), this.ctx.lastPoint = new c(e.x, e.y);
    }, p.prototype.lineTo = function(t, e) {
        if (isNaN(t) || isNaN(e)) throw a.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
        var r = this.ctx.transform.applyToPoint(new c(t, e));
        this.path.push({
            type: "lt",
            x: r.x,
            y: r.y
        }), this.ctx.lastPoint = new c(r.x, r.y);
    }, p.prototype.clip = function() {
        this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A.call(this, null, !0);
    }, p.prototype.quadraticCurveTo = function(t, e, r, n) {
        if (isNaN(r) || isNaN(n) || isNaN(t) || isNaN(e)) throw a.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
        var i = this.ctx.transform.applyToPoint(new c(r, n)), o = this.ctx.transform.applyToPoint(new c(t, e));
        this.path.push({
            type: "qct",
            x1: o.x,
            y1: o.y,
            x: i.x,
            y: i.y
        }), this.ctx.lastPoint = new c(i.x, i.y);
    }, p.prototype.bezierCurveTo = function(t, e, r, n, i, o) {
        if (isNaN(i) || isNaN(o) || isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n)) throw a.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
        var s = this.ctx.transform.applyToPoint(new c(i, o)), u = this.ctx.transform.applyToPoint(new c(t, e)), h = this.ctx.transform.applyToPoint(new c(r, n));
        this.path.push({
            type: "bct",
            x1: u.x,
            y1: u.y,
            x2: h.x,
            y2: h.y,
            x: s.x,
            y: s.y
        }), this.ctx.lastPoint = new c(s.x, s.y);
    }, p.prototype.arc = function(t, e, r, n, i, o) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n) || isNaN(i)) throw a.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
        if (o = Boolean(o), !this.ctx.transform.isIdentity) {
            var s = this.ctx.transform.applyToPoint(new c(t, e));
            t = s.x, e = s.y;
            var u = this.ctx.transform.applyToPoint(new c(0, r)), h = this.ctx.transform.applyToPoint(new c(0, 0));
            r = Math.sqrt(Math.pow(u.x - h.x, 2) + Math.pow(u.y - h.y, 2));
        }
        Math.abs(i - n) >= 2 * Math.PI && (n = 0, i = 2 * Math.PI), this.path.push({
            type: "arc",
            x: t,
            y: e,
            radius: r,
            startAngle: n,
            endAngle: i,
            counterclockwise: o
        });
    }, p.prototype.arcTo = function(t, e, r, n, i) {
        throw new Error("arcTo not implemented.");
    }, p.prototype.rect = function(t, e, r, n) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n)) throw a.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
        this.moveTo(t, e), this.lineTo(t + r, e), this.lineTo(t + r, e + n), this.lineTo(t, e + n), this.lineTo(t, e), this.lineTo(t + r, e), this.lineTo(t, e);
    }, p.prototype.fillRect = function(t, e, r, n) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n)) throw a.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
        if (!m.call(this)) {
            var i = {};
            "butt" !== this.lineCap && (i.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t, e, r, n), this.fill(), i.hasOwnProperty("lineCap") && (this.lineCap = i.lineCap), i.hasOwnProperty("lineJoin") && (this.lineJoin = i.lineJoin);
        }
    }, p.prototype.strokeRect = function(t, e, r, n) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n)) throw a.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
        v.call(this) || (this.beginPath(), this.rect(t, e, r, n), this.stroke());
    }, p.prototype.clearRect = function(t, e, r, n) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n)) throw a.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
        this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t, e, r, n));
    }, p.prototype.save = function(t) {
        t = "boolean" != typeof t || t;
        for(var e = this.pdf.internal.getCurrentPageInfo().pageNumber, r = 0; r < this.pdf.internal.getNumberOfPages(); r++)this.pdf.setPage(r + 1), this.pdf.internal.out("q");
        if (this.pdf.setPage(e), t) {
            this.ctx.fontSize = this.pdf.internal.getFontSize();
            var n = new d(this.ctx);
            this.ctxStack.push(this.ctx), this.ctx = n;
        }
    }, p.prototype.restore = function(t) {
        t = "boolean" != typeof t || t;
        for(var e = this.pdf.internal.getCurrentPageInfo().pageNumber, r = 0; r < this.pdf.internal.getNumberOfPages(); r++)this.pdf.setPage(r + 1), this.pdf.internal.out("Q");
        this.pdf.setPage(e), t && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
    }, p.prototype.toDataURL = function() {
        throw new Error("toDataUrl not implemented.");
    };
    var g = function(t) {
        var e, r, n, i;
        if (!0 === t.isCanvasGradient && (t = t.getColor()), !t) return {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            style: t
        };
        if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t)) e = 0, r = 0, n = 0, i = 0;
        else {
            var a = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t);
            if (null !== a) e = parseInt(a[1]), r = parseInt(a[2]), n = parseInt(a[3]), i = 1;
            else if (null !== (a = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t))) e = parseInt(a[1]), r = parseInt(a[2]), n = parseInt(a[3]), i = parseFloat(a[4]);
            else {
                if (i = 1, "string" == typeof t && "#" !== t.charAt(0)) {
                    var o = new f(t);
                    t = o.ok ? o.toHex() : "#000000";
                }
                4 === t.length ? (e = t.substring(1, 2), e += e, r = t.substring(2, 3), r += r, n = t.substring(3, 4), n += n) : (e = t.substring(1, 3), r = t.substring(3, 5), n = t.substring(5, 7)), e = parseInt(e, 16), r = parseInt(r, 16), n = parseInt(n, 16);
            }
        }
        return {
            r: e,
            g: r,
            b: n,
            a: i,
            style: t
        };
    }, m = function() {
        return this.ctx.isFillTransparent || 0 == this.globalAlpha;
    }, v = function() {
        return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
    };
    p.prototype.fillText = function(t, e, r, n) {
        if (isNaN(e) || isNaN(r) || "string" != typeof t) throw a.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
        if (n = isNaN(n) ? void 0 : n, !m.call(this)) {
            var i = q(this.ctx.transform.rotation), o = this.ctx.transform.scaleX;
            C.call(this, {
                text: t,
                x: e,
                y: r,
                scale: o,
                angle: i,
                align: this.textAlign,
                maxWidth: n
            });
        }
    }, p.prototype.strokeText = function(t, e, r, n) {
        if (isNaN(e) || isNaN(r) || "string" != typeof t) throw a.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
        if (!v.call(this)) {
            n = isNaN(n) ? void 0 : n;
            var i = q(this.ctx.transform.rotation), o = this.ctx.transform.scaleX;
            C.call(this, {
                text: t,
                x: e,
                y: r,
                scale: o,
                renderingMode: "stroke",
                angle: i,
                align: this.textAlign,
                maxWidth: n
            });
        }
    }, p.prototype.measureText = function(t) {
        if ("string" != typeof t) throw a.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
        var e = this.pdf, r = this.pdf.internal.scaleFactor, n = e.internal.getFontSize(), i = e.getStringUnitWidth(t) * n / e.internal.scaleFactor, o = function(t) {
            var e = (t = t || {}).width || 0;
            return Object.defineProperty(this, "width", {
                get: function() {
                    return e;
                }
            }), this;
        };
        return new o({
            width: i *= Math.round(96 * r / 72 * 1e4) / 1e4
        });
    }, p.prototype.scale = function(t, e) {
        if (isNaN(t) || isNaN(e)) throw a.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
        var r = new h(t, 0, 0, e, 0, 0);
        this.ctx.transform = this.ctx.transform.multiply(r);
    }, p.prototype.rotate = function(t) {
        if (isNaN(t)) throw a.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
        var e = new h(Math.cos(t), Math.sin(t), -Math.sin(t), Math.cos(t), 0, 0);
        this.ctx.transform = this.ctx.transform.multiply(e);
    }, p.prototype.translate = function(t, e) {
        if (isNaN(t) || isNaN(e)) throw a.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
        var r = new h(1, 0, 0, 1, t, e);
        this.ctx.transform = this.ctx.transform.multiply(r);
    }, p.prototype.transform = function(t, e, r, n, i, o) {
        if (isNaN(t) || isNaN(e) || isNaN(r) || isNaN(n) || isNaN(i) || isNaN(o)) throw a.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
        var s = new h(t, e, r, n, i, o);
        this.ctx.transform = this.ctx.transform.multiply(s);
    }, p.prototype.setTransform = function(t, e, r, n, i, a) {
        t = isNaN(t) ? 1 : t, e = isNaN(e) ? 0 : e, r = isNaN(r) ? 0 : r, n = isNaN(n) ? 1 : n, i = isNaN(i) ? 0 : i, a = isNaN(a) ? 0 : a, this.ctx.transform = new h(t, e, r, n, i, a);
    };
    var b = function() {
        return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
    };
    p.prototype.drawImage = function(t, e, r, n, i, a, o, s, c) {
        var l = this.pdf.getImageProperties(t), f = 1, d = 1, p = 1, g = 1;
        void 0 !== n && void 0 !== s && (p = s / n, g = c / i, f = l.width / n * s / n, d = l.height / i * c / i), void 0 === a && (a = e, o = r, e = 0, r = 0), void 0 !== n && void 0 === s && (s = n, c = i), void 0 === n && void 0 === s && (s = l.width, c = l.height);
        for(var m, v = this.ctx.transform.decompose(), w = q(v.rotate.shx), A = new h, S = (A = (A = (A = A.multiply(v.translate)).multiply(v.skew)).multiply(v.scale)).applyToRectangle(new u(a - e * p, o - r * g, n * f, i * d)), _ = y.call(this, S), P = [], k = 0; k < _.length; k += 1)-1 === P.indexOf(_[k]) && P.push(_[k]);
        if (L(P), this.autoPaging) for(var I = P[0], F = P[P.length - 1], C = I; C < F + 1; C++){
            this.pdf.setPage(C);
            var j = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O = 1 === C ? this.posY + this.margin[0] : this.margin[0], B = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E = 1 === C ? 0 : B + (C - 2) * M;
            if (0 !== this.ctx.clip_path.length) {
                var D = this.path;
                m = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N(m, this.posX + this.margin[3], -E + O + this.ctx.prevPageLastElemOffset), x.call(this, "fill", !0), this.path = D;
            }
            var R = JSON.parse(JSON.stringify(S));
            R = N([
                R
            ], this.posX + this.margin[3], -E + O + this.ctx.prevPageLastElemOffset)[0];
            var T = (C > I || C < F) && b.call(this);
            T && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j, M, null).clip().discardPath()), this.pdf.addImage(t, "JPEG", R.x, R.y, R.w, R.h, null, null, w), T && this.pdf.restoreGraphicsState();
        }
        else this.pdf.addImage(t, "JPEG", S.x, S.y, S.w, S.h, null, null, w);
    };
    var y = function(t, e, r) {
        var n = [];
        e = e || this.pdf.internal.pageSize.width, r = r || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
        var i = this.posY + this.ctx.prevPageLastElemOffset;
        switch(t.type){
            default:
            case "mt":
            case "lt":
                n.push(Math.floor((t.y + i) / r) + 1);
                break;
            case "arc":
                n.push(Math.floor((t.y + i - t.radius) / r) + 1), n.push(Math.floor((t.y + i + t.radius) / r) + 1);
                break;
            case "qct":
                var a = D(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t.x1, t.y1, t.x, t.y);
                n.push(Math.floor((a.y + i) / r) + 1), n.push(Math.floor((a.y + a.h + i) / r) + 1);
                break;
            case "bct":
                var o = R(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t.x1, t.y1, t.x2, t.y2, t.x, t.y);
                n.push(Math.floor((o.y + i) / r) + 1), n.push(Math.floor((o.y + o.h + i) / r) + 1);
                break;
            case "rect":
                n.push(Math.floor((t.y + i) / r) + 1), n.push(Math.floor((t.y + t.h + i) / r) + 1);
        }
        for(var s = 0; s < n.length; s += 1)for(; this.pdf.internal.getNumberOfPages() < n[s];)w.call(this);
        return n;
    }, w = function() {
        var t = this.fillStyle, e = this.strokeStyle, r = this.font, n = this.lineCap, i = this.lineWidth, a = this.lineJoin;
        this.pdf.addPage(), this.fillStyle = t, this.strokeStyle = e, this.font = r, this.lineCap = n, this.lineWidth = i, this.lineJoin = a;
    }, N = function(t, e, r) {
        for(var n = 0; n < t.length; n++)switch(t[n].type){
            case "bct":
                t[n].x2 += e, t[n].y2 += r;
            case "qct":
                t[n].x1 += e, t[n].y1 += r;
            case "mt":
            case "lt":
            case "arc":
            default:
                t[n].x += e, t[n].y += r;
        }
        return t;
    }, L = function(t) {
        return t.sort(function(t, e) {
            return t - e;
        });
    }, A = function(t, e) {
        for(var r, n, i = this.fillStyle, a = this.strokeStyle, o = this.lineCap, s = this.lineWidth, c = Math.abs(s * this.ctx.transform.scaleX), u = this.lineJoin, h = JSON.parse(JSON.stringify(this.path)), l = JSON.parse(JSON.stringify(this.path)), f = [], d = 0; d < l.length; d++)if (void 0 !== l[d].x) for(var p = y.call(this, l[d]), g = 0; g < p.length; g += 1)-1 === f.indexOf(p[g]) && f.push(p[g]);
        for(var m = 0; m < f.length; m++)for(; this.pdf.internal.getNumberOfPages() < f[m];)w.call(this);
        if (L(f), this.autoPaging) for(var v = f[0], A = f[f.length - 1], S = v; S < A + 1; S++){
            this.pdf.setPage(S), this.fillStyle = i, this.strokeStyle = a, this.lineCap = o, this.lineWidth = c, this.lineJoin = u;
            var _ = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P = 1 === S ? this.posY + this.margin[0] : this.margin[0], k = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F = 1 === S ? 0 : k + (S - 2) * I;
            if (0 !== this.ctx.clip_path.length) {
                var C = this.path;
                r = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N(r, this.posX + this.margin[3], -F + P + this.ctx.prevPageLastElemOffset), x.call(this, t, !0), this.path = C;
            }
            if (n = JSON.parse(JSON.stringify(h)), this.path = N(n, this.posX + this.margin[3], -F + P + this.ctx.prevPageLastElemOffset), !1 === e || 0 === S) {
                var j = (S > v || S < A) && b.call(this);
                j && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _, I, null).clip().discardPath()), x.call(this, t, e), j && this.pdf.restoreGraphicsState();
            }
            this.lineWidth = s;
        }
        else this.lineWidth = c, x.call(this, t, e), this.lineWidth = s;
        this.path = h;
    }, x = function(t, e) {
        if (("stroke" !== t || e || !v.call(this)) && ("stroke" === t || e || !m.call(this))) {
            for(var r, n, i = [], a = this.path, o = 0; o < a.length; o++){
                var s = a[o];
                switch(s.type){
                    case "begin":
                        i.push({
                            begin: !0
                        });
                        break;
                    case "close":
                        i.push({
                            close: !0
                        });
                        break;
                    case "mt":
                        i.push({
                            start: s,
                            deltas: [],
                            abs: []
                        });
                        break;
                    case "lt":
                        var c = i.length;
                        if (a[o - 1] && !isNaN(a[o - 1].x) && (r = [
                            s.x - a[o - 1].x,
                            s.y - a[o - 1].y
                        ], c > 0)) {
                            for(; c >= 0; c--)if (!0 !== i[c - 1].close && !0 !== i[c - 1].begin) {
                                i[c - 1].deltas.push(r), i[c - 1].abs.push(s);
                                break;
                            }
                        }
                        break;
                    case "bct":
                        r = [
                            s.x1 - a[o - 1].x,
                            s.y1 - a[o - 1].y,
                            s.x2 - a[o - 1].x,
                            s.y2 - a[o - 1].y,
                            s.x - a[o - 1].x,
                            s.y - a[o - 1].y
                        ], i[i.length - 1].deltas.push(r);
                        break;
                    case "qct":
                        var u = a[o - 1].x + 2 / 3 * (s.x1 - a[o - 1].x), h = a[o - 1].y + 2 / 3 * (s.y1 - a[o - 1].y), l = s.x + 2 / 3 * (s.x1 - s.x), f = s.y + 2 / 3 * (s.y1 - s.y), d = s.x, p = s.y;
                        r = [
                            u - a[o - 1].x,
                            h - a[o - 1].y,
                            l - a[o - 1].x,
                            f - a[o - 1].y,
                            d - a[o - 1].x,
                            p - a[o - 1].y
                        ], i[i.length - 1].deltas.push(r);
                        break;
                    case "arc":
                        i.push({
                            deltas: [],
                            abs: [],
                            arc: !0
                        }), Array.isArray(i[i.length - 1].abs) && i[i.length - 1].abs.push(s);
                }
            }
            n = e ? null : "stroke" === t ? "stroke" : "fill";
            for(var g = !1, b = 0; b < i.length; b++)if (i[b].arc) for(var y = i[b].abs, w = 0; w < y.length; w++){
                var N = y[w];
                "arc" === N.type ? P.call(this, N.x, N.y, N.radius, N.startAngle, N.endAngle, N.counterclockwise, void 0, e, !g) : j.call(this, N.x, N.y), g = !0;
            }
            else if (!0 === i[b].close) this.pdf.internal.out("h"), g = !1;
            else if (!0 !== i[b].begin) {
                var L = i[b].start.x, A = i[b].start.y;
                O.call(this, i[b].deltas, L, A), g = !0;
            }
            n && k.call(this, n), e && I.call(this);
        }
    }, S = function(t) {
        var e = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r = e * (this.pdf.internal.getLineHeightFactor() - 1);
        switch(this.ctx.textBaseline){
            case "bottom":
                return t - r;
            case "top":
                return t + e - r;
            case "hanging":
                return t + e - 2 * r;
            case "middle":
                return t + e / 2 - r;
            case "ideographic":
                return t;
            case "alphabetic":
            default:
                return t;
        }
    }, _ = function(t) {
        return t + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
    };
    p.prototype.createLinearGradient = function() {
        var t = function() {};
        return t.colorStops = [], t.addColorStop = function(t, e) {
            this.colorStops.push([
                t,
                e
            ]);
        }, t.getColor = function() {
            return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
        }, t.isCanvasGradient = !0, t;
    }, p.prototype.createPattern = function() {
        return this.createLinearGradient();
    }, p.prototype.createRadialGradient = function() {
        return this.createLinearGradient();
    };
    var P = function(t, e, r, n, i, a, o, s, c) {
        for(var u = M.call(this, r, n, i, a), h = 0; h < u.length; h++){
            var l = u[h];
            0 === h && (c ? F.call(this, l.x1 + t, l.y1 + e) : j.call(this, l.x1 + t, l.y1 + e)), B.call(this, t, e, l.x2, l.y2, l.x3, l.y3, l.x4, l.y4);
        }
        s ? I.call(this) : k.call(this, o);
    }, k = function(t) {
        switch(t){
            case "stroke":
                this.pdf.internal.out("S");
                break;
            case "fill":
                this.pdf.internal.out("f");
        }
    }, I = function() {
        this.pdf.clip(), this.pdf.discardPath();
    }, F = function(t, e) {
        this.pdf.internal.out(n(t) + " " + i(e) + " m");
    }, C = function(t) {
        var e;
        switch(t.align){
            case "right":
            case "end":
                e = "right";
                break;
            case "center":
                e = "center";
                break;
            case "left":
            case "start":
            default:
                e = "left";
        }
        var r = this.pdf.getTextDimensions(t.text), n = S.call(this, t.y), i = _.call(this, n) - r.h, a = this.ctx.transform.applyToPoint(new c(t.x, n)), o = this.ctx.transform.decompose(), s = new h;
        s = (s = (s = s.multiply(o.translate)).multiply(o.skew)).multiply(o.scale);
        for(var l, f, d, p = this.ctx.transform.applyToRectangle(new u(t.x, n, r.w, r.h)), g = s.applyToRectangle(new u(t.x, i, r.w, r.h)), m = y.call(this, g), v = [], w = 0; w < m.length; w += 1)-1 === v.indexOf(m[w]) && v.push(m[w]);
        if (L(v), this.autoPaging) for(var A = v[0], P = v[v.length - 1], k = A; k < P + 1; k++){
            this.pdf.setPage(k);
            var I = 1 === k ? this.posY + this.margin[0] : this.margin[0], F = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C = this.pdf.internal.pageSize.height - this.margin[2], j = C - this.margin[0], O = this.pdf.internal.pageSize.width - this.margin[1], B = O - this.margin[3], M = 1 === k ? 0 : F + (k - 2) * j;
            if (0 !== this.ctx.clip_path.length) {
                var E = this.path;
                l = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N(l, this.posX + this.margin[3], -1 * M + I), x.call(this, "fill", !0), this.path = E;
            }
            var q = N([
                JSON.parse(JSON.stringify(g))
            ], this.posX + this.margin[3], -M + I + this.ctx.prevPageLastElemOffset)[0];
            t.scale >= .01 && (f = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f * t.scale), d = this.lineWidth, this.lineWidth = d * t.scale);
            var D = "text" !== this.autoPaging;
            if (D || q.y + q.h <= C) {
                if (D || q.y >= I && q.x <= O) {
                    var R = D ? t.text : this.pdf.splitTextToSize(t.text, t.maxWidth || O - q.x)[0], T = N([
                        JSON.parse(JSON.stringify(p))
                    ], this.posX + this.margin[3], -M + I + this.ctx.prevPageLastElemOffset)[0], U = D && (k > A || k < P) && b.call(this);
                    U && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B, j, null).clip().discardPath()), this.pdf.text(R, T.x, T.y, {
                        angle: t.angle,
                        align: e,
                        renderingMode: t.renderingMode
                    }), U && this.pdf.restoreGraphicsState();
                }
            } else q.y < C && (this.ctx.prevPageLastElemOffset += C - q.y);
            t.scale >= .01 && (this.pdf.setFontSize(f), this.lineWidth = d);
        }
        else t.scale >= .01 && (f = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f * t.scale), d = this.lineWidth, this.lineWidth = d * t.scale), this.pdf.text(t.text, a.x + this.posX, a.y + this.posY, {
            angle: t.angle,
            align: e,
            renderingMode: t.renderingMode,
            maxWidth: t.maxWidth
        }), t.scale >= .01 && (this.pdf.setFontSize(f), this.lineWidth = d);
    }, j = function(t, e, r, a) {
        r = r || 0, a = a || 0, this.pdf.internal.out(n(t + r) + " " + i(e + a) + " l");
    }, O = function(t, e, r) {
        return this.pdf.lines(t, e, r, null, null);
    }, B = function(t, e, n, i, a, c, u, h) {
        this.pdf.internal.out([
            r(o(n + t)),
            r(s(i + e)),
            r(o(a + t)),
            r(s(c + e)),
            r(o(u + t)),
            r(s(h + e)),
            "c"
        ].join(" "));
    }, M = function(t, e, r, n) {
        for(var i = 2 * Math.PI, a = Math.PI / 2; e > r;)e -= i;
        var o = Math.abs(r - e);
        o < i && n && (o = i - o);
        for(var s = [], c = n ? -1 : 1, u = e; o > 1e-5;){
            var h = u + c * Math.min(o, a);
            s.push(E.call(this, t, u, h)), o -= Math.abs(h - u), u = h;
        }
        return s;
    }, E = function(t, e, r) {
        var n = (r - e) / 2, i = t * Math.cos(n), a = t * Math.sin(n), o = i, s = -a, c = o * o + s * s, u = c + o * i + s * a, h = 4 / 3 * (Math.sqrt(2 * c * u) - u) / (o * a - s * i), l = o - h * s, f = s + h * o, d = l, p = -f, g = n + e, m = Math.cos(g), v = Math.sin(g);
        return {
            x1: t * Math.cos(e),
            y1: t * Math.sin(e),
            x2: l * m - f * v,
            y2: l * v + f * m,
            x3: d * m - p * v,
            y3: d * v + p * m,
            x4: t * Math.cos(r),
            y4: t * Math.sin(r)
        };
    }, q = function(t) {
        return 180 * t / Math.PI;
    }, D = function(t, e, r, n, i, a) {
        var o = t + .5 * (r - t), s = e + .5 * (n - e), c = i + .5 * (r - i), h = a + .5 * (n - a), l = Math.min(t, i, o, c), f = Math.max(t, i, o, c), d = Math.min(e, a, s, h), p = Math.max(e, a, s, h);
        return new u(l, d, f - l, p - d);
    }, R = function(t, e, r, n, i, a, o, s) {
        var c, h, l, f, d, p, g, m, v, b, y, w, N, L, A = r - t, x = n - e, S = i - r, _ = a - n, P = o - i, k = s - a;
        for(h = 0; h < 41; h++)v = (g = (l = t + (c = h / 40) * A) + c * ((d = r + c * S) - l)) + c * (d + c * (i + c * P - d) - g), b = (m = (f = e + c * x) + c * ((p = n + c * _) - f)) + c * (p + c * (a + c * k - p) - m), 0 == h ? (y = v, w = b, N = v, L = b) : (y = Math.min(y, v), w = Math.min(w, b), N = Math.max(N, v), L = Math.max(L, b));
        return new u(Math.round(y), Math.round(w), Math.round(N - y), Math.round(L - w));
    }, T = function() {
        if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
            var t, e, r = (t = this.ctx.lineDash, e = this.ctx.lineDashOffset, JSON.stringify({
                lineDash: t,
                lineDashOffset: e
            }));
            this.prevLineDash !== r && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r);
        }
    };
}(E.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    var r = function(t) {
        var e, r, n, i, a, o, s, c, u, h;
        for(/[^\x00-\xFF]/.test(t), r = [], n = 0, i = (t += e = "\0\0\0\0".slice(t.length % 4 || 4)).length; i > n; n += 4)0 !== (a = (t.charCodeAt(n) << 24) + (t.charCodeAt(n + 1) << 16) + (t.charCodeAt(n + 2) << 8) + t.charCodeAt(n + 3)) ? (o = (a = ((a = ((a = ((a = (a - (h = a % 85)) / 85) - (u = a % 85)) / 85) - (c = a % 85)) / 85) - (s = a % 85)) / 85) % 85, r.push(o + 33, s + 33, c + 33, u + 33, h + 33)) : r.push(122);
        return function(t, e) {
            for(var r = e; r > 0; r--)t.pop();
        }(r, e.length), String.fromCharCode.apply(String, r) + "~>";
    }, n = function(t) {
        var e, r, n, i, a, o = String, s = "length", c = 255, u = "charCodeAt", h = "slice", l = "replace";
        for(t[h](-2), t = t[h](0, -2)[l](/\s/g, "")[l]("z", "!!!!!"), n = [], i = 0, a = (t += e = "uuuuu"[h](t[s] % 5 || 5))[s]; a > i; i += 5)r = 52200625 * (t[u](i) - 33) + 614125 * (t[u](i + 1) - 33) + 7225 * (t[u](i + 2) - 33) + 85 * (t[u](i + 3) - 33) + (t[u](i + 4) - 33), n.push(c & r >> 24, c & r >> 16, c & r >> 8, c & r);
        return function(t, e) {
            for(var r = e; r > 0; r--)t.pop();
        }(n, e[s]), o.fromCharCode.apply(o, n);
    }, i = function(t) {
        var e = new RegExp(/^([0-9A-Fa-f]{2})+$/);
        if (-1 !== (t = t.replace(/\s/g, "")).indexOf(">") && (t = t.substr(0, t.indexOf(">"))), t.length % 2 && (t += "0"), !1 === e.test(t)) return "";
        for(var r = "", n = 0; n < t.length; n += 2)r += String.fromCharCode("0x" + (t[n] + t[n + 1]));
        return r;
    }, a = function(t) {
        for(var r = new Uint8Array(t.length), n = t.length; n--;)r[n] = t.charCodeAt(n);
        return t = (r = (0, _fflate.zlibSync)(r)).reduce(function(t, e) {
            return t + String.fromCharCode(e);
        }, "");
    };
    t.processDataByFilters = function(t, e) {
        var o = 0, s = t || "", c = [];
        for("string" == typeof (e = e || []) && (e = [
            e
        ]), o = 0; o < e.length; o += 1)switch(e[o]){
            case "ASCII85Decode":
            case "/ASCII85Decode":
                s = n(s), c.push("/ASCII85Encode");
                break;
            case "ASCII85Encode":
            case "/ASCII85Encode":
                s = r(s), c.push("/ASCII85Decode");
                break;
            case "ASCIIHexDecode":
            case "/ASCIIHexDecode":
                s = i(s), c.push("/ASCIIHexEncode");
                break;
            case "ASCIIHexEncode":
            case "/ASCIIHexEncode":
                s = s.split("").map(function(t) {
                    return ("0" + t.charCodeAt().toString(16)).slice(-2);
                }).join("") + ">", c.push("/ASCIIHexDecode");
                break;
            case "FlateEncode":
            case "/FlateEncode":
                s = a(s), c.push("/FlateDecode");
                break;
            default:
                throw new Error('The filter: "' + e[o] + '" is not implemented');
        }
        return {
            data: s,
            reverseChain: c.reverse().join(" ")
        };
    };
}(E.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    t.loadFile = function(t, e, r) {
        return function(t, e, r) {
            e = !1 !== e, r = "function" == typeof r ? r : function() {};
            var n = void 0;
            try {
                n = function(t, e, r) {
                    var n = new XMLHttpRequest, i = 0, a = function(t) {
                        var e = t.length, r = [], n = String.fromCharCode;
                        for(i = 0; i < e; i += 1)r.push(n(255 & t.charCodeAt(i)));
                        return r.join("");
                    };
                    if (n.open("GET", t, !e), n.overrideMimeType("text/plain; charset=x-user-defined"), !1 === e && (n.onload = function() {
                        200 === n.status ? r(a(this.responseText)) : r(void 0);
                    }), n.send(null), e && 200 === n.status) return a(n.responseText);
                }(t, e, r);
            } catch (t) {}
            return n;
        }(t, e, r);
    }, t.loadImageFile = t.loadFile;
}(E.API), function(e) {
    function r() {
        return (n.html2canvas ? Promise.resolve(n.html2canvas) : require("e35ed7d1af132742")).catch(function(t) {
            return Promise.reject(new Error("Could not load html2canvas: " + t));
        }).then(function(t) {
            return t.default ? t.default : t;
        });
    }
    function i() {
        return (n.DOMPurify ? Promise.resolve(n.DOMPurify) : require("fd4d839f94e36dff")).catch(function(t) {
            return Promise.reject(new Error("Could not load dompurify: " + t));
        }).then(function(t) {
            return t.default ? t.default : t;
        });
    }
    var a = function(e) {
        var r = (0, _typeofDefault.default)(e);
        return "undefined" === r ? "undefined" : "string" === r || e instanceof String ? "string" : "number" === r || e instanceof Number ? "number" : "function" === r || e instanceof Function ? "function" : e && e.constructor === Array ? "array" : e && 1 === e.nodeType ? "element" : "object" === r ? "object" : "unknown";
    }, o = function(t, e) {
        var r = document.createElement(t);
        for(var n in e.className && (r.className = e.className), e.innerHTML && e.dompurify && (r.innerHTML = e.dompurify.sanitize(e.innerHTML)), e.style)r.style[n] = e.style[n];
        return r;
    }, s = function t(e) {
        var r = Object.assign(t.convert(Promise.resolve()), JSON.parse(JSON.stringify(t.template))), n = t.convert(Promise.resolve(), r);
        return n = (n = n.setProgress(1, t, 1, [
            t
        ])).set(e);
    };
    (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(t, e) {
        return t.__proto__ = e || s.prototype, t;
    }, s.template = {
        prop: {
            src: null,
            container: null,
            overlay: null,
            canvas: null,
            img: null,
            pdf: null,
            pageSize: null,
            callback: function() {}
        },
        progress: {
            val: 0,
            state: null,
            n: 0,
            stack: []
        },
        opt: {
            filename: "file.pdf",
            margin: [
                0,
                0,
                0,
                0
            ],
            enableLinks: !0,
            x: 0,
            y: 0,
            html2canvas: {},
            jsPDF: {},
            backgroundColor: "transparent"
        }
    }, s.prototype.from = function(t, e) {
        return this.then(function() {
            switch(e = e || function(t) {
                switch(a(t)){
                    case "string":
                        return "string";
                    case "element":
                        return "canvas" === t.nodeName.toLowerCase() ? "canvas" : "element";
                    default:
                        return "unknown";
                }
            }(t)){
                case "string":
                    return this.then(i).then(function(e) {
                        return this.set({
                            src: o("div", {
                                innerHTML: t,
                                dompurify: e
                            })
                        });
                    });
                case "element":
                    return this.set({
                        src: t
                    });
                case "canvas":
                    return this.set({
                        canvas: t
                    });
                case "img":
                    return this.set({
                        img: t
                    });
                default:
                    return this.error("Unknown source type.");
            }
        });
    }, s.prototype.to = function(t) {
        switch(t){
            case "container":
                return this.toContainer();
            case "canvas":
                return this.toCanvas();
            case "img":
                return this.toImg();
            case "pdf":
                return this.toPdf();
            default:
                return this.error("Invalid target.");
        }
    }, s.prototype.toContainer = function() {
        return this.thenList([
            function() {
                return this.prop.src || this.error("Cannot duplicate - no source HTML.");
            },
            function() {
                return this.prop.pageSize || this.setPageSize();
            }
        ]).then(function() {
            var t = {
                position: "relative",
                display: "inline-block",
                width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px",
                left: 0,
                right: 0,
                top: 0,
                margin: "auto",
                backgroundColor: this.opt.backgroundColor
            }, e = function t(e, r) {
                for(var n = 3 === e.nodeType ? document.createTextNode(e.nodeValue) : e.cloneNode(!1), i = e.firstChild; i; i = i.nextSibling)!0 !== r && 1 === i.nodeType && "SCRIPT" === i.nodeName || n.appendChild(t(i, r));
                return 1 === e.nodeType && ("CANVAS" === e.nodeName ? (n.width = e.width, n.height = e.height, n.getContext("2d").drawImage(e, 0, 0)) : "TEXTAREA" !== e.nodeName && "SELECT" !== e.nodeName || (n.value = e.value), n.addEventListener("load", function() {
                    n.scrollTop = e.scrollTop, n.scrollLeft = e.scrollLeft;
                }, !0)), n;
            }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
            "BODY" === e.tagName && (t.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o("div", {
                className: "html2pdf__overlay",
                style: {
                    position: "fixed",
                    overflow: "hidden",
                    zIndex: 1e3,
                    left: "-100000px",
                    right: 0,
                    bottom: 0,
                    top: 0
                }
            }), this.prop.container = o("div", {
                className: "html2pdf__container",
                style: t
            }), this.prop.container.appendChild(e), this.prop.container.firstChild.appendChild(o("div", {
                style: {
                    clear: "both",
                    border: "0 none transparent",
                    margin: 0,
                    padding: 0,
                    height: 0
                }
            })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
        });
    }, s.prototype.toCanvas = function() {
        var t = [
            function() {
                return document.body.contains(this.prop.container) || this.toContainer();
            }
        ];
        return this.thenList(t).then(r).then(function(t) {
            var e = Object.assign({}, this.opt.html2canvas);
            return delete e.onrendered, t(this.prop.container, e);
        }).then(function(t) {
            (this.opt.html2canvas.onrendered || function() {})(t), this.prop.canvas = t, document.body.removeChild(this.prop.overlay);
        });
    }, s.prototype.toContext2d = function() {
        var t = [
            function() {
                return document.body.contains(this.prop.container) || this.toContainer();
            }
        ];
        return this.thenList(t).then(r).then(function(t) {
            var e = this.opt.jsPDF, r = this.opt.fontFaces, n = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i = Object.assign({
                async: !0,
                allowTaint: !0,
                scale: n,
                scrollX: this.opt.scrollX || 0,
                scrollY: this.opt.scrollY || 0,
                backgroundColor: "#ffffff",
                imageTimeout: 15e3,
                logging: !0,
                proxy: null,
                removeContainer: !0,
                foreignObjectRendering: !1,
                useCORS: !1
            }, this.opt.html2canvas);
            if (delete i.onrendered, e.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e.context2d.posX = this.opt.x, e.context2d.posY = this.opt.y, e.context2d.margin = this.opt.margin, e.context2d.fontFaces = r, r) for(var a = 0; a < r.length; ++a){
                var o = r[a], s = o.src.find(function(t) {
                    return "truetype" === t.format;
                });
                s && e.addFont(s.url, o.ref.name, o.ref.style);
            }
            return i.windowHeight = i.windowHeight || 0, i.windowHeight = 0 == i.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i.windowHeight, e.context2d.save(!0), t(this.prop.container, i);
        }).then(function(t) {
            this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {})(t), this.prop.canvas = t, document.body.removeChild(this.prop.overlay);
        });
    }, s.prototype.toImg = function() {
        return this.thenList([
            function() {
                return this.prop.canvas || this.toCanvas();
            }
        ]).then(function() {
            var t = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
            this.prop.img = document.createElement("img"), this.prop.img.src = t;
        });
    }, s.prototype.toPdf = function() {
        return this.thenList([
            function() {
                return this.toContext2d();
            }
        ]).then(function() {
            this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
        });
    }, s.prototype.output = function(t, e, r) {
        return "img" === (r = r || "pdf").toLowerCase() || "image" === r.toLowerCase() ? this.outputImg(t, e) : this.outputPdf(t, e);
    }, s.prototype.outputPdf = function(t, e) {
        return this.thenList([
            function() {
                return this.prop.pdf || this.toPdf();
            }
        ]).then(function() {
            return this.prop.pdf.output(t, e);
        });
    }, s.prototype.outputImg = function(t) {
        return this.thenList([
            function() {
                return this.prop.img || this.toImg();
            }
        ]).then(function() {
            switch(t){
                case void 0:
                case "img":
                    return this.prop.img;
                case "datauristring":
                case "dataurlstring":
                    return this.prop.img.src;
                case "datauri":
                case "dataurl":
                    return document.location.href = this.prop.img.src;
                default:
                    throw 'Image output type "' + t + '" is not supported.';
            }
        });
    }, s.prototype.save = function(t) {
        return this.thenList([
            function() {
                return this.prop.pdf || this.toPdf();
            }
        ]).set(t ? {
            filename: t
        } : null).then(function() {
            this.prop.pdf.save(this.opt.filename);
        });
    }, s.prototype.doCallback = function() {
        return this.thenList([
            function() {
                return this.prop.pdf || this.toPdf();
            }
        ]).then(function() {
            this.prop.callback(this.prop.pdf);
        });
    }, s.prototype.set = function(t) {
        if ("object" !== a(t)) return this;
        var e = Object.keys(t || {}).map(function(e) {
            if (e in s.template.prop) return function() {
                this.prop[e] = t[e];
            };
            switch(e){
                case "margin":
                    return this.setMargin.bind(this, t.margin);
                case "jsPDF":
                    return function() {
                        return this.opt.jsPDF = t.jsPDF, this.setPageSize();
                    };
                case "pageSize":
                    return this.setPageSize.bind(this, t.pageSize);
                default:
                    return function() {
                        this.opt[e] = t[e];
                    };
            }
        }, this);
        return this.then(function() {
            return this.thenList(e);
        });
    }, s.prototype.get = function(t, e) {
        return this.then(function() {
            var r = t in s.template.prop ? this.prop[t] : this.opt[t];
            return e ? e(r) : r;
        });
    }, s.prototype.setMargin = function(t) {
        return this.then(function() {
            switch(a(t)){
                case "number":
                    t = [
                        t,
                        t,
                        t,
                        t
                    ];
                case "array":
                    if (2 === t.length && (t = [
                        t[0],
                        t[1],
                        t[0],
                        t[1]
                    ]), 4 === t.length) break;
                default:
                    return this.error("Invalid margin array.");
            }
            this.opt.margin = t;
        }).then(this.setPageSize);
    }, s.prototype.setPageSize = function(t) {
        function e(t, e) {
            return Math.floor(t * e / 72 * 96);
        }
        return this.then(function() {
            (t = t || E.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t.inner = {
                width: t.width - this.opt.margin[1] - this.opt.margin[3],
                height: t.height - this.opt.margin[0] - this.opt.margin[2]
            }, t.inner.px = {
                width: e(t.inner.width, t.k),
                height: e(t.inner.height, t.k)
            }, t.inner.ratio = t.inner.height / t.inner.width), this.prop.pageSize = t;
        });
    }, s.prototype.setProgress = function(t, e, r, n) {
        return null != t && (this.progress.val = t), null != e && (this.progress.state = e), null != r && (this.progress.n = r), null != n && (this.progress.stack = n), this.progress.ratio = this.progress.val / this.progress.state, this;
    }, s.prototype.updateProgress = function(t, e, r, n) {
        return this.setProgress(t ? this.progress.val + t : null, e || null, r ? this.progress.n + r : null, n ? this.progress.stack.concat(n) : null);
    }, s.prototype.then = function(t, e) {
        var r = this;
        return this.thenCore(t, e, function(t, e) {
            return r.updateProgress(null, null, 1, [
                t
            ]), Promise.prototype.then.call(this, function(e) {
                return r.updateProgress(null, t), e;
            }).then(t, e).then(function(t) {
                return r.updateProgress(1), t;
            });
        });
    }, s.prototype.thenCore = function(t, e, r) {
        r = r || Promise.prototype.then;
        t && (t = t.bind(this)), e && (e = e.bind(this));
        var n = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? this : s.convert(Object.assign({}, this), Promise.prototype), i = r.call(n, t, e);
        return s.convert(i, this.__proto__);
    }, s.prototype.thenExternal = function(t, e) {
        return Promise.prototype.then.call(this, t, e);
    }, s.prototype.thenList = function(t) {
        var e = this;
        return t.forEach(function(t) {
            e = e.thenCore(t);
        }), e;
    }, s.prototype.catch = function(t) {
        t && (t = t.bind(this));
        var e = Promise.prototype.catch.call(this, t);
        return s.convert(e, this);
    }, s.prototype.catchExternal = function(t) {
        return Promise.prototype.catch.call(this, t);
    }, s.prototype.error = function(t) {
        return this.then(function() {
            throw new Error(t);
        });
    }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, E.getPageSize = function(e, r, n) {
        if ("object" === (0, _typeofDefault.default)(e)) {
            var i = e;
            e = i.orientation, r = i.unit || r, n = i.format || n;
        }
        r = r || "mm", n = n || "a4", e = ("" + (e || "P")).toLowerCase();
        var a, o = ("" + n).toLowerCase(), s = {
            a0: [
                2383.94,
                3370.39
            ],
            a1: [
                1683.78,
                2383.94
            ],
            a2: [
                1190.55,
                1683.78
            ],
            a3: [
                841.89,
                1190.55
            ],
            a4: [
                595.28,
                841.89
            ],
            a5: [
                419.53,
                595.28
            ],
            a6: [
                297.64,
                419.53
            ],
            a7: [
                209.76,
                297.64
            ],
            a8: [
                147.4,
                209.76
            ],
            a9: [
                104.88,
                147.4
            ],
            a10: [
                73.7,
                104.88
            ],
            b0: [
                2834.65,
                4008.19
            ],
            b1: [
                2004.09,
                2834.65
            ],
            b2: [
                1417.32,
                2004.09
            ],
            b3: [
                1000.63,
                1417.32
            ],
            b4: [
                708.66,
                1000.63
            ],
            b5: [
                498.9,
                708.66
            ],
            b6: [
                354.33,
                498.9
            ],
            b7: [
                249.45,
                354.33
            ],
            b8: [
                175.75,
                249.45
            ],
            b9: [
                124.72,
                175.75
            ],
            b10: [
                87.87,
                124.72
            ],
            c0: [
                2599.37,
                3676.54
            ],
            c1: [
                1836.85,
                2599.37
            ],
            c2: [
                1298.27,
                1836.85
            ],
            c3: [
                918.43,
                1298.27
            ],
            c4: [
                649.13,
                918.43
            ],
            c5: [
                459.21,
                649.13
            ],
            c6: [
                323.15,
                459.21
            ],
            c7: [
                229.61,
                323.15
            ],
            c8: [
                161.57,
                229.61
            ],
            c9: [
                113.39,
                161.57
            ],
            c10: [
                79.37,
                113.39
            ],
            dl: [
                311.81,
                623.62
            ],
            letter: [
                612,
                792
            ],
            "government-letter": [
                576,
                756
            ],
            legal: [
                612,
                1008
            ],
            "junior-legal": [
                576,
                360
            ],
            ledger: [
                1224,
                792
            ],
            tabloid: [
                792,
                1224
            ],
            "credit-card": [
                153,
                243
            ]
        };
        switch(r){
            case "pt":
                a = 1;
                break;
            case "mm":
                a = 72 / 25.4;
                break;
            case "cm":
                a = 72 / 2.54;
                break;
            case "in":
                a = 72;
                break;
            case "px":
                a = .75;
                break;
            case "pc":
            case "em":
                a = 12;
                break;
            case "ex":
                a = 6;
                break;
            default:
                throw "Invalid unit: " + r;
        }
        var c, u = 0, h = 0;
        if (s.hasOwnProperty(o)) u = s[o][1] / a, h = s[o][0] / a;
        else try {
            u = n[1], h = n[0];
        } catch (t) {
            throw new Error("Invalid format: " + n);
        }
        if ("p" === e || "portrait" === e) e = "p", h > u && (c = h, h = u, u = c);
        else {
            if ("l" !== e && "landscape" !== e) throw "Invalid orientation: " + e;
            e = "l", u > h && (c = h, h = u, u = c);
        }
        return {
            width: h,
            height: u,
            unit: r,
            k: a,
            orientation: e
        };
    }, e.html = function(t, e) {
        (e = e || {}).callback = e.callback || function() {}, e.html2canvas = e.html2canvas || {}, e.html2canvas.canvas = e.html2canvas.canvas || this.canvas, e.jsPDF = e.jsPDF || this, e.fontFaces = e.fontFaces ? e.fontFaces.map(jt) : null;
        var r = new s(e);
        return e.worker ? r : r.from(t).doCallback();
    };
}(E.API), E.API.addJS = function(t) {
    return Ht = t, this.internal.events.subscribe("postPutResources", function() {
        Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
    }), this.internal.events.subscribe("putCatalog", function() {
        void 0 !== Ut && void 0 !== zt && this.internal.out("/Names <</JavaScript " + Ut + " 0 R>>");
    }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    var e;
    t.events.push([
        "postPutResources",
        function() {
            var t = this, r = /^(\d+) 0 obj$/;
            if (this.outline.root.children.length > 0) for(var n = t.outline.render().split(/\r\n/), i = 0; i < n.length; i++){
                var a = n[i], o = r.exec(a);
                if (null != o) {
                    var s = o[1];
                    t.internal.newObjectDeferredBegin(s, !1);
                }
                t.internal.write(a);
            }
            if (this.outline.createNamedDestinations) {
                var c = this.internal.pages.length, u = [];
                for(i = 0; i < c; i++){
                    var h = t.internal.newObject();
                    u.push(h);
                    var l = t.internal.getPageInfo(i + 1);
                    t.internal.write("<< /D[" + l.objId + " 0 R /XYZ null null null]>> endobj");
                }
                var f = t.internal.newObject();
                t.internal.write("<< /Names [ ");
                for(i = 0; i < u.length; i++)t.internal.write("(page_" + (i + 1) + ")" + u[i] + " 0 R");
                t.internal.write(" ] >>", "endobj"), e = t.internal.newObject(), t.internal.write("<< /Dests " + f + " 0 R"), t.internal.write(">>", "endobj");
            }
        }
    ]), t.events.push([
        "putCatalog",
        function() {
            this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
        }
    ]), t.events.push([
        "initialized",
        function() {
            var t = this;
            t.outline = {
                createNamedDestinations: !1,
                root: {
                    children: []
                }
            }, t.outline.add = function(t, e, r) {
                var n = {
                    title: e,
                    options: r,
                    children: []
                };
                return null == t && (t = this.root), t.children.push(n), n;
            }, t.outline.render = function() {
                return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
            }, t.outline.genIds_r = function(e) {
                e.id = t.internal.newObjectDeferred();
                for(var r = 0; r < e.children.length; r++)this.genIds_r(e.children[r]);
            }, t.outline.renderRoot = function(t) {
                this.objStart(t), this.line("/Type /Outlines"), t.children.length > 0 && (this.line("/First " + this.makeRef(t.children[0])), this.line("/Last " + this.makeRef(t.children[t.children.length - 1]))), this.line("/Count " + this.count_r({
                    count: 0
                }, t)), this.objEnd();
            }, t.outline.renderItems = function(e) {
                for(var r = this.ctx.pdf.internal.getVerticalCoordinateString, n = 0; n < e.children.length; n++){
                    var i = e.children[n];
                    this.objStart(i), this.line("/Title " + this.makeString(i.title)), this.line("/Parent " + this.makeRef(e)), n > 0 && this.line("/Prev " + this.makeRef(e.children[n - 1])), n < e.children.length - 1 && this.line("/Next " + this.makeRef(e.children[n + 1])), i.children.length > 0 && (this.line("/First " + this.makeRef(i.children[0])), this.line("/Last " + this.makeRef(i.children[i.children.length - 1])));
                    var a = this.count = this.count_r({
                        count: 0
                    }, i);
                    if (a > 0 && this.line("/Count " + a), i.options && i.options.pageNumber) {
                        var o = t.internal.getPageInfo(i.options.pageNumber);
                        this.line("/Dest [" + o.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
                    }
                    this.objEnd();
                }
                for(var s = 0; s < e.children.length; s++)this.renderItems(e.children[s]);
            }, t.outline.line = function(t) {
                this.ctx.val += t + "\r\n";
            }, t.outline.makeRef = function(t) {
                return t.id + " 0 R";
            }, t.outline.makeString = function(e) {
                return "(" + t.internal.pdfEscape(e) + ")";
            }, t.outline.objStart = function(t) {
                this.ctx.val += "\r\n" + t.id + " 0 obj\r\n<<\r\n";
            }, t.outline.objEnd = function() {
                this.ctx.val += ">> \r\nendobj\r\n";
            }, t.outline.count_r = function(t, e) {
                for(var r = 0; r < e.children.length; r++)t.count++, this.count_r(t, e.children[r]);
                return t.count;
            };
        }
    ]);
}(E.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    var e = [
        192,
        193,
        194,
        195,
        196,
        197,
        198,
        199
    ];
    t.processJPEG = function(t, r, n, i, a, o) {
        var s, c = this.decode.DCT_DECODE, u = null;
        if ("string" == typeof t || this.__addimage__.isArrayBuffer(t) || this.__addimage__.isArrayBufferView(t)) {
            switch(t = a || t, t = this.__addimage__.isArrayBuffer(t) ? new Uint8Array(t) : t, (s = function(t) {
                for(var r, n = 256 * t.charCodeAt(4) + t.charCodeAt(5), i = t.length, a = {
                    width: 0,
                    height: 0,
                    numcomponents: 1
                }, o = 4; o < i; o += 2){
                    if (o += n, -1 !== e.indexOf(t.charCodeAt(o + 1))) {
                        r = 256 * t.charCodeAt(o + 5) + t.charCodeAt(o + 6), a = {
                            width: 256 * t.charCodeAt(o + 7) + t.charCodeAt(o + 8),
                            height: r,
                            numcomponents: t.charCodeAt(o + 9)
                        };
                        break;
                    }
                    n = 256 * t.charCodeAt(o + 2) + t.charCodeAt(o + 3);
                }
                return a;
            }(t = this.__addimage__.isArrayBufferView(t) ? this.__addimage__.arrayBufferToBinaryString(t) : t)).numcomponents){
                case 1:
                    o = this.color_spaces.DEVICE_GRAY;
                    break;
                case 4:
                    o = this.color_spaces.DEVICE_CMYK;
                    break;
                case 3:
                    o = this.color_spaces.DEVICE_RGB;
            }
            u = {
                data: t,
                width: s.width,
                height: s.height,
                colorSpace: o,
                bitsPerComponent: 8,
                filter: c,
                index: r,
                alias: n
            };
        }
        return u;
    };
}(E.API);
var Vt, Gt, Yt, Jt, Xt, Kt = function() {
    var t, e, i;
    function a(t) {
        var e, r, n, i, a, o, s, c, u, h, l, f, d, p;
        for(this.data = t, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o = null;;){
            switch(e = this.readUInt32(), u = (function() {
                var t, e;
                for(e = [], t = 0; t < 4; ++t)e.push(String.fromCharCode(this.data[this.pos++]));
                return e;
            }).call(this).join("")){
                case "IHDR":
                    this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
                    break;
                case "acTL":
                    this.animation = {
                        numFrames: this.readUInt32(),
                        numPlays: this.readUInt32() || 1 / 0,
                        frames: []
                    };
                    break;
                case "PLTE":
                    this.palette = this.read(e);
                    break;
                case "fcTL":
                    o && this.animation.frames.push(o), this.pos += 4, o = {
                        width: this.readUInt32(),
                        height: this.readUInt32(),
                        xOffset: this.readUInt32(),
                        yOffset: this.readUInt32()
                    }, a = this.readUInt16(), i = this.readUInt16() || 100, o.delay = 1e3 * a / i, o.disposeOp = this.data[this.pos++], o.blendOp = this.data[this.pos++], o.data = [];
                    break;
                case "IDAT":
                case "fdAT":
                    for("fdAT" === u && (this.pos += 4, e -= 4), t = (null != o ? o.data : void 0) || this.imgData, f = 0; 0 <= e ? f < e : f > e; 0 <= e ? ++f : --f)t.push(this.data[this.pos++]);
                    break;
                case "tRNS":
                    switch(this.transparency = {}, this.colorType){
                        case 3:
                            if (n = this.palette.length / 3, this.transparency.indexed = this.read(e), this.transparency.indexed.length > n) throw new Error("More transparent colors than palette size");
                            if ((h = n - this.transparency.indexed.length) > 0) for(d = 0; 0 <= h ? d < h : d > h; 0 <= h ? ++d : --d)this.transparency.indexed.push(255);
                            break;
                        case 0:
                            this.transparency.grayscale = this.read(e)[0];
                            break;
                        case 2:
                            this.transparency.rgb = this.read(e);
                    }
                    break;
                case "tEXt":
                    s = (l = this.read(e)).indexOf(0), c = String.fromCharCode.apply(String, l.slice(0, s)), this.text[c] = String.fromCharCode.apply(String, l.slice(s + 1));
                    break;
                case "IEND":
                    return o && this.animation.frames.push(o), this.colors = (function() {
                        switch(this.colorType){
                            case 0:
                            case 3:
                            case 4:
                                return 1;
                            case 2:
                            case 6:
                                return 3;
                        }
                    }).call(this), this.hasAlphaChannel = 4 === (p = this.colorType) || 6 === p, r = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r, this.colorSpace = (function() {
                        switch(this.colors){
                            case 1:
                                return "DeviceGray";
                            case 3:
                                return "DeviceRGB";
                        }
                    }).call(this), void (this.imgData = new Uint8Array(this.imgData));
                default:
                    this.pos += e;
            }
            if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
        }
    }
    a.prototype.read = function(t) {
        var e, r;
        for(r = [], e = 0; 0 <= t ? e < t : e > t; 0 <= t ? ++e : --e)r.push(this.data[this.pos++]);
        return r;
    }, a.prototype.readUInt32 = function() {
        return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
    }, a.prototype.readUInt16 = function() {
        return this.data[this.pos++] << 8 | this.data[this.pos++];
    }, a.prototype.decodePixels = function(t) {
        var e = this.pixelBitlength / 8, n = new Uint8Array(this.width * this.height * e), i = 0, a = this;
        if (null == t && (t = this.imgData), 0 === t.length) return new Uint8Array(0);
        function o(r, o, s, c) {
            var u, h, l, f, d, p, g, m, v, b, y, w, N, L, A, x, S, _, P, k, I, F = Math.ceil((a.width - r) / s), C = Math.ceil((a.height - o) / c), j = a.width == F && a.height == C;
            for(L = e * F, w = j ? n : new Uint8Array(L * C), p = t.length, N = 0, h = 0; N < C && i < p;){
                switch(t[i++]){
                    case 0:
                        for(f = S = 0; S < L; f = S += 1)w[h++] = t[i++];
                        break;
                    case 1:
                        for(f = _ = 0; _ < L; f = _ += 1)u = t[i++], d = f < e ? 0 : w[h - e], w[h++] = (u + d) % 256;
                        break;
                    case 2:
                        for(f = P = 0; P < L; f = P += 1)u = t[i++], l = (f - f % e) / e, A = N && w[(N - 1) * L + l * e + f % e], w[h++] = (A + u) % 256;
                        break;
                    case 3:
                        for(f = k = 0; k < L; f = k += 1)u = t[i++], l = (f - f % e) / e, d = f < e ? 0 : w[h - e], A = N && w[(N - 1) * L + l * e + f % e], w[h++] = (u + Math.floor((d + A) / 2)) % 256;
                        break;
                    case 4:
                        for(f = I = 0; I < L; f = I += 1)u = t[i++], l = (f - f % e) / e, d = f < e ? 0 : w[h - e], 0 === N ? A = x = 0 : (A = w[(N - 1) * L + l * e + f % e], x = l && w[(N - 1) * L + (l - 1) * e + f % e]), g = d + A - x, m = Math.abs(g - d), b = Math.abs(g - A), y = Math.abs(g - x), v = m <= b && m <= y ? d : b <= y ? A : x, w[h++] = (u + v) % 256;
                        break;
                    default:
                        throw new Error("Invalid filter algorithm: " + t[i - 1]);
                }
                if (!j) {
                    var O = ((o + N * c) * a.width + r) * e, B = N * L;
                    for(f = 0; f < F; f += 1){
                        for(var M = 0; M < e; M += 1)n[O++] = w[B++];
                        O += (s - 1) * e;
                    }
                }
                N++;
            }
        }
        return t = (0, _fflate.unzlibSync)(t), 1 == a.interlaceMethod ? (o(0, 0, 8, 8), o(4, 0, 8, 8), o(0, 4, 4, 8), o(2, 0, 4, 4), o(0, 2, 2, 4), o(1, 0, 2, 2), o(0, 1, 1, 2)) : o(0, 0, 1, 1), n;
    }, a.prototype.decodePalette = function() {
        var t, e, r, n, i, a, o, s, c;
        for(r = this.palette, a = this.transparency.indexed || [], i = new Uint8Array((a.length || 0) + r.length), n = 0, t = 0, e = o = 0, s = r.length; o < s; e = o += 3)i[n++] = r[e], i[n++] = r[e + 1], i[n++] = r[e + 2], i[n++] = null != (c = a[t++]) ? c : 255;
        return i;
    }, a.prototype.copyToImageData = function(t, e) {
        var r, n, i, a, o, s, c, u, h, l, f;
        if (n = this.colors, h = null, r = this.hasAlphaChannel, this.palette.length && (h = null != (f = this._decodedPalette) ? f : this._decodedPalette = this.decodePalette(), n = 4, r = !0), u = (i = t.data || t).length, o = h || e, a = s = 0, 1 === n) for(; a < u;)c = h ? 4 * e[a / 4] : s, l = o[c++], i[a++] = l, i[a++] = l, i[a++] = l, i[a++] = r ? o[c++] : 255, s = c;
        else for(; a < u;)c = h ? 4 * e[a / 4] : s, i[a++] = o[c++], i[a++] = o[c++], i[a++] = o[c++], i[a++] = r ? o[c++] : 255, s = c;
    }, a.prototype.decode = function() {
        var t;
        return t = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t, this.decodePixels()), t;
    };
    var o = function() {
        if ("[object Window]" === Object.prototype.toString.call(n)) {
            try {
                e = n.document.createElement("canvas"), i = e.getContext("2d");
            } catch (t) {
                return !1;
            }
            return !0;
        }
        return !1;
    };
    return o(), t = function(t) {
        var r;
        if (!0 === o()) return i.width = t.width, i.height = t.height, i.clearRect(0, 0, t.width, t.height), i.putImageData(t, 0, 0), (r = new Image).src = e.toDataURL(), r;
        throw new Error("This method requires a Browser with Canvas-capability.");
    }, a.prototype.decodeFrames = function(e) {
        var r, n, i, a, o, s, c, u;
        if (this.animation) {
            for(u = [], n = o = 0, s = (c = this.animation.frames).length; o < s; n = ++o)r = c[n], i = e.createImageData(r.width, r.height), a = this.decodePixels(new Uint8Array(r.data)), this.copyToImageData(i, a), r.imageData = i, u.push(r.image = t(i));
            return u;
        }
    }, a.prototype.renderFrame = function(t, e) {
        var r, n, i;
        return r = (n = this.animation.frames)[e], i = n[e - 1], 0 === e && t.clearRect(0, 0, this.width, this.height), 1 === (null != i ? i.disposeOp : void 0) ? t.clearRect(i.xOffset, i.yOffset, i.width, i.height) : 2 === (null != i ? i.disposeOp : void 0) && t.putImageData(i.imageData, i.xOffset, i.yOffset), 0 === r.blendOp && t.clearRect(r.xOffset, r.yOffset, r.width, r.height), t.drawImage(r.image, r.xOffset, r.yOffset);
    }, a.prototype.animate = function(t) {
        var e, r, n, i, a, o, s = this;
        return r = 0, o = this.animation, i = o.numFrames, n = o.frames, a = o.numPlays, (e = function() {
            var o, c;
            if (o = r++ % i, c = n[o], s.renderFrame(t, o), i > 1 && r / i < a) return s.animation._timeout = setTimeout(e, c.delay);
        })();
    }, a.prototype.stopAnimation = function() {
        var t;
        return clearTimeout(null != (t = this.animation) ? t._timeout : void 0);
    }, a.prototype.render = function(t) {
        var e, r;
        return t._png && t._png.stopAnimation(), t._png = this, t.width = this.width, t.height = this.height, e = t.getContext("2d"), this.animation ? (this.decodeFrames(e), this.animate(e)) : (r = e.createImageData(this.width, this.height), this.copyToImageData(r, this.decodePixels()), e.putImageData(r, 0, 0));
    }, a;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */ /**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */ function Zt(t) {
    var e = 0;
    if (71 !== t[e++] || 73 !== t[e++] || 70 !== t[e++] || 56 !== t[e++] || 56 != (t[e++] + 1 & 253) || 97 !== t[e++]) throw new Error("Invalid GIF 87a/89a header.");
    var r = t[e++] | t[e++] << 8, n = t[e++] | t[e++] << 8, i = t[e++], a = i >> 7, o = 1 << (7 & i) + 1;
    t[e++];
    t[e++];
    var s = null, c = null;
    a && (s = e, c = o, e += 3 * o);
    var u = !0, h = [], l = 0, f = null, d = 0, p = null;
    for(this.width = r, this.height = n; u && e < t.length;)switch(t[e++]){
        case 33:
            switch(t[e++]){
                case 255:
                    if (11 !== t[e] || 78 == t[e + 1] && 69 == t[e + 2] && 84 == t[e + 3] && 83 == t[e + 4] && 67 == t[e + 5] && 65 == t[e + 6] && 80 == t[e + 7] && 69 == t[e + 8] && 50 == t[e + 9] && 46 == t[e + 10] && 48 == t[e + 11] && 3 == t[e + 12] && 1 == t[e + 13] && 0 == t[e + 16]) e += 14, p = t[e++] | t[e++] << 8, e++;
                    else for(e += 12;;){
                        if (!((P = t[e++]) >= 0)) throw Error("Invalid block size");
                        if (0 === P) break;
                        e += P;
                    }
                    break;
                case 249:
                    if (4 !== t[e++] || 0 !== t[e + 4]) throw new Error("Invalid graphics extension block.");
                    var g = t[e++];
                    l = t[e++] | t[e++] << 8, f = t[e++], 0 == (1 & g) && (f = null), d = g >> 2 & 7, e++;
                    break;
                case 254:
                    for(;;){
                        if (!((P = t[e++]) >= 0)) throw Error("Invalid block size");
                        if (0 === P) break;
                        e += P;
                    }
                    break;
                default:
                    throw new Error("Unknown graphic control label: 0x" + t[e - 1].toString(16));
            }
            break;
        case 44:
            var m = t[e++] | t[e++] << 8, v = t[e++] | t[e++] << 8, b = t[e++] | t[e++] << 8, y = t[e++] | t[e++] << 8, w = t[e++], N = w >> 6 & 1, L = 1 << (7 & w) + 1, A = s, x = c, S = !1;
            if (w >> 7) {
                S = !0;
                A = e, x = L, e += 3 * L;
            }
            var _ = e;
            for(e++;;){
                var P;
                if (!((P = t[e++]) >= 0)) throw Error("Invalid block size");
                if (0 === P) break;
                e += P;
            }
            h.push({
                x: m,
                y: v,
                width: b,
                height: y,
                has_local_palette: S,
                palette_offset: A,
                palette_size: x,
                data_offset: _,
                data_length: e - _,
                transparent_index: f,
                interlaced: !!N,
                delay: l,
                disposal: d
            });
            break;
        case 59:
            u = !1;
            break;
        default:
            throw new Error("Unknown gif block: 0x" + t[e - 1].toString(16));
    }
    this.numFrames = function() {
        return h.length;
    }, this.loopCount = function() {
        return p;
    }, this.frameInfo = function(t) {
        if (t < 0 || t >= h.length) throw new Error("Frame index out of range.");
        return h[t];
    }, this.decodeAndBlitFrameBGRA = function(e, n) {
        var i = this.frameInfo(e), a = i.width * i.height, o = new Uint8Array(a);
        $t(t, i.data_offset, o, a);
        var s = i.palette_offset, c = i.transparent_index;
        null === c && (c = 256);
        var u = i.width, h = r - u, l = u, f = 4 * (i.y * r + i.x), d = 4 * ((i.y + i.height) * r + i.x), p = f, g = 4 * h;
        !0 === i.interlaced && (g += 4 * r * 7);
        for(var m = 8, v = 0, b = o.length; v < b; ++v){
            var y = o[v];
            if (0 === l && (l = u, (p += g) >= d && (g = 4 * h + 4 * r * (m - 1), p = f + (u + h) * (m << 1), m >>= 1)), y === c) p += 4;
            else {
                var w = t[s + 3 * y], N = t[s + 3 * y + 1], L = t[s + 3 * y + 2];
                n[p++] = L, n[p++] = N, n[p++] = w, n[p++] = 255;
            }
            --l;
        }
    }, this.decodeAndBlitFrameRGBA = function(e, n) {
        var i = this.frameInfo(e), a = i.width * i.height, o = new Uint8Array(a);
        $t(t, i.data_offset, o, a);
        var s = i.palette_offset, c = i.transparent_index;
        null === c && (c = 256);
        var u = i.width, h = r - u, l = u, f = 4 * (i.y * r + i.x), d = 4 * ((i.y + i.height) * r + i.x), p = f, g = 4 * h;
        !0 === i.interlaced && (g += 4 * r * 7);
        for(var m = 8, v = 0, b = o.length; v < b; ++v){
            var y = o[v];
            if (0 === l && (l = u, (p += g) >= d && (g = 4 * h + 4 * r * (m - 1), p = f + (u + h) * (m << 1), m >>= 1)), y === c) p += 4;
            else {
                var w = t[s + 3 * y], N = t[s + 3 * y + 1], L = t[s + 3 * y + 2];
                n[p++] = w, n[p++] = N, n[p++] = L, n[p++] = 255;
            }
            --l;
        }
    };
}
function $t(t, e, r, n) {
    for(var i = t[e++], o = 1 << i, s = o + 1, c = s + 1, u = i + 1, h = (1 << u) - 1, l = 0, f = 0, d = 0, p = t[e++], g = new Int32Array(4096), m = null;;){
        for(; l < 16 && 0 !== p;)f |= t[e++] << l, l += 8, 1 === p ? p = t[e++] : --p;
        if (l < u) break;
        var v = f & h;
        if (f >>= u, l -= u, v !== o) {
            if (v === s) break;
            for(var b = v < c ? v : m, y = 0, w = b; w > o;)w = g[w] >> 8, ++y;
            var N = w;
            if (d + y + (b !== v ? 1 : 0) > n) return void a.log("Warning, gif stream longer than expected.");
            r[d++] = N;
            var L = d += y;
            for(b !== v && (r[d++] = N), w = b; y--;)w = g[w], r[--L] = 255 & w, w >>= 8;
            null !== m && c < 4096 && (g[c++] = m << 8 | N, c >= h + 1 && u < 12 && (++u, h = h << 1 | 1)), m = v;
        } else c = s + 1, h = (1 << (u = i + 1)) - 1, m = null;
    }
    return d !== n && a.log("Warning, gif stream shorter than expected."), r;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/ function Qt(t) {
    var e, r, n, i, a, o = Math.floor, s = new Array(64), c = new Array(64), u = new Array(64), h = new Array(64), l = new Array(65535), f = new Array(65535), d = new Array(64), p = new Array(64), g = [], m = 0, v = 7, b = new Array(64), y = new Array(64), w = new Array(64), N = new Array(256), L = new Array(2048), A = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
    ], x = [
        0,
        0,
        1,
        5,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ], S = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11
    ], _ = [
        0,
        0,
        2,
        1,
        3,
        3,
        2,
        4,
        3,
        5,
        5,
        4,
        4,
        0,
        0,
        1,
        125
    ], P = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
    ], k = [
        0,
        0,
        3,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0
    ], I = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11
    ], F = [
        0,
        0,
        2,
        1,
        2,
        4,
        4,
        3,
        4,
        7,
        5,
        4,
        4,
        0,
        1,
        2,
        119
    ], C = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
    ];
    function j(t, e) {
        for(var r = 0, n = 0, i = new Array, a = 1; a <= 16; a++){
            for(var o = 1; o <= t[a]; o++)i[e[n]] = [], i[e[n]][0] = r, i[e[n]][1] = a, n++, r++;
            r *= 2;
        }
        return i;
    }
    function O(t) {
        for(var e = t[0], r = t[1] - 1; r >= 0;)e & 1 << r && (m |= 1 << v), r--, --v < 0 && (255 == m ? (B(255), B(0)) : B(m), v = 7, m = 0);
    }
    function B(t) {
        g.push(t);
    }
    function M(t) {
        B(t >> 8 & 255), B(255 & t);
    }
    function E(t, e, r, n, i) {
        for(var a, o = i[0], s = i[240], c = function(t, e) {
            var r, n, i, a, o, s, c, u, h, l, f = 0;
            for(h = 0; h < 8; ++h){
                r = t[f], n = t[f + 1], i = t[f + 2], a = t[f + 3], o = t[f + 4], s = t[f + 5], c = t[f + 6];
                var p = r + (u = t[f + 7]), g = r - u, m = n + c, v = n - c, b = i + s, y = i - s, w = a + o, N = a - o, L = p + w, A = p - w, x = m + b, S = m - b;
                t[f] = L + x, t[f + 4] = L - x;
                var _ = .707106781 * (S + A);
                t[f + 2] = A + _, t[f + 6] = A - _;
                var P = .382683433 * ((L = N + y) - (S = v + g)), k = .5411961 * L + P, I = 1.306562965 * S + P, F = .707106781 * (x = y + v), C = g + F, j = g - F;
                t[f + 5] = j + k, t[f + 3] = j - k, t[f + 1] = C + I, t[f + 7] = C - I, f += 8;
            }
            for(f = 0, h = 0; h < 8; ++h){
                r = t[f], n = t[f + 8], i = t[f + 16], a = t[f + 24], o = t[f + 32], s = t[f + 40], c = t[f + 48];
                var O = r + (u = t[f + 56]), B = r - u, M = n + c, E = n - c, q = i + s, D = i - s, R = a + o, T = a - o, U = O + R, z = O - R, H = M + q, W = M - q;
                t[f] = U + H, t[f + 32] = U - H;
                var V = .707106781 * (W + z);
                t[f + 16] = z + V, t[f + 48] = z - V;
                var G = .382683433 * ((U = T + D) - (W = E + B)), Y = .5411961 * U + G, J = 1.306562965 * W + G, X = .707106781 * (H = D + E), K = B + X, Z = B - X;
                t[f + 40] = Z + Y, t[f + 24] = Z - Y, t[f + 8] = K + J, t[f + 56] = K - J, f++;
            }
            for(h = 0; h < 64; ++h)l = t[h] * e[h], d[h] = l > 0 ? l + .5 | 0 : l - .5 | 0;
            return d;
        }(t, e), u = 0; u < 64; ++u)p[A[u]] = c[u];
        var h = p[0] - r;
        r = p[0], 0 == h ? O(n[0]) : (O(n[f[a = 32767 + h]]), O(l[a]));
        for(var g = 63; g > 0 && 0 == p[g];)g--;
        if (0 == g) return O(o), r;
        for(var m, v = 1; v <= g;){
            for(var b = v; 0 == p[v] && v <= g;)++v;
            var y = v - b;
            if (y >= 16) {
                m = y >> 4;
                for(var w = 1; w <= m; ++w)O(s);
                y &= 15;
            }
            a = 32767 + p[v], O(i[(y << 4) + f[a]]), O(l[a]), v++;
        }
        return 63 != g && O(o), r;
    }
    function q(t) {
        (t = Math.min(Math.max(t, 1), 100), a != t) && (!function(t) {
            for(var e = [
                16,
                11,
                10,
                16,
                24,
                40,
                51,
                61,
                12,
                12,
                14,
                19,
                26,
                58,
                60,
                55,
                14,
                13,
                16,
                24,
                40,
                57,
                69,
                56,
                14,
                17,
                22,
                29,
                51,
                87,
                80,
                62,
                18,
                22,
                37,
                56,
                68,
                109,
                103,
                77,
                24,
                35,
                55,
                64,
                81,
                104,
                113,
                92,
                49,
                64,
                78,
                87,
                103,
                121,
                120,
                101,
                72,
                92,
                95,
                98,
                112,
                100,
                103,
                99
            ], r = 0; r < 64; r++){
                var n = o((e[r] * t + 50) / 100);
                n = Math.min(Math.max(n, 1), 255), s[A[r]] = n;
            }
            for(var i = [
                17,
                18,
                24,
                47,
                99,
                99,
                99,
                99,
                18,
                21,
                26,
                66,
                99,
                99,
                99,
                99,
                24,
                26,
                56,
                99,
                99,
                99,
                99,
                99,
                47,
                66,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99
            ], a = 0; a < 64; a++){
                var l = o((i[a] * t + 50) / 100);
                l = Math.min(Math.max(l, 1), 255), c[A[a]] = l;
            }
            for(var f = [
                1,
                1.387039845,
                1.306562965,
                1.175875602,
                1,
                .785694958,
                .5411961,
                .275899379
            ], d = 0, p = 0; p < 8; p++)for(var g = 0; g < 8; g++)u[d] = 1 / (s[A[d]] * f[p] * f[g] * 8), h[d] = 1 / (c[A[d]] * f[p] * f[g] * 8), d++;
        }(t < 50 ? Math.floor(5e3 / t) : Math.floor(200 - 2 * t)), a = t);
    }
    this.encode = function(t, a) {
        a && q(a), g = new Array, m = 0, v = 7, M(65496), M(65504), M(16), B(74), B(70), B(73), B(70), B(0), B(1), B(1), B(0), M(1), M(1), B(0), B(0), function() {
            M(65499), M(132), B(0);
            for(var t = 0; t < 64; t++)B(s[t]);
            B(1);
            for(var e = 0; e < 64; e++)B(c[e]);
        }(), function(t, e) {
            M(65472), M(17), B(8), M(e), M(t), B(3), B(1), B(17), B(0), B(2), B(17), B(1), B(3), B(17), B(1);
        }(t.width, t.height), function() {
            M(65476), M(418), B(0);
            for(var t = 0; t < 16; t++)B(x[t + 1]);
            for(var e = 0; e <= 11; e++)B(S[e]);
            B(16);
            for(var r = 0; r < 16; r++)B(_[r + 1]);
            for(var n = 0; n <= 161; n++)B(P[n]);
            B(1);
            for(var i = 0; i < 16; i++)B(k[i + 1]);
            for(var a = 0; a <= 11; a++)B(I[a]);
            B(17);
            for(var o = 0; o < 16; o++)B(F[o + 1]);
            for(var s = 0; s <= 161; s++)B(C[s]);
        }(), M(65498), M(12), B(3), B(1), B(0), B(2), B(17), B(3), B(17), B(0), B(63), B(0);
        var o = 0, l = 0, f = 0;
        m = 0, v = 7, this.encode.displayName = "_encode_";
        for(var d, p, N, A, j, D, R, T, U, z = t.data, H = t.width, W = t.height, V = 4 * H, G = 0; G < W;){
            for(d = 0; d < V;){
                for(j = V * G + d, R = -1, T = 0, U = 0; U < 64; U++)D = j + (T = U >> 3) * V + (R = 4 * (7 & U)), G + T >= W && (D -= V * (G + 1 + T - W)), d + R >= V && (D -= d + R - V + 4), p = z[D++], N = z[D++], A = z[D++], b[U] = (L[p] + L[N + 256 >> 0] + L[A + 512 >> 0] >> 16) - 128, y[U] = (L[p + 768 >> 0] + L[N + 1024 >> 0] + L[A + 1280 >> 0] >> 16) - 128, w[U] = (L[p + 1280 >> 0] + L[N + 1536 >> 0] + L[A + 1792 >> 0] >> 16) - 128;
                o = E(b, u, o, e, n), l = E(y, h, l, r, i), f = E(w, h, f, r, i), d += 32;
            }
            G += 8;
        }
        if (v >= 0) {
            var Y = [];
            Y[1] = v + 1, Y[0] = (1 << v + 1) - 1, O(Y);
        }
        return M(65497), new Uint8Array(g);
    }, t = t || 50, function() {
        for(var t = String.fromCharCode, e = 0; e < 256; e++)N[e] = t(e);
    }(), e = j(x, S), r = j(k, I), n = j(_, P), i = j(F, C), function() {
        for(var t = 1, e = 2, r = 1; r <= 15; r++){
            for(var n = t; n < e; n++)f[32767 + n] = r, l[32767 + n] = [], l[32767 + n][1] = r, l[32767 + n][0] = n;
            for(var i = -(e - 1); i <= -t; i++)f[32767 + i] = r, l[32767 + i] = [], l[32767 + i][1] = r, l[32767 + i][0] = e - 1 + i;
            t <<= 1, e <<= 1;
        }
    }(), function() {
        for(var t = 0; t < 256; t++)L[t] = 19595 * t, L[t + 256 >> 0] = 38470 * t, L[t + 512 >> 0] = 7471 * t + 32768, L[t + 768 >> 0] = -11059 * t, L[t + 1024 >> 0] = -21709 * t, L[t + 1280 >> 0] = 32768 * t + 8421375, L[t + 1536 >> 0] = -27439 * t, L[t + 1792 >> 0] = -5329 * t;
    }(), q(t);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function te(t, e) {
    if (this.pos = 0, this.buffer = t, this.datav = new DataView(t.buffer), this.is_with_alpha = !!e, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === [
        "BM",
        "BA",
        "CI",
        "CP",
        "IC",
        "PT"
    ].indexOf(this.flag)) throw new Error("Invalid BMP File");
    this.parseHeader(), this.parseBGR();
}
function ee(t) {
    function e(t) {
        if (!t) throw Error("assert :P");
    }
    function r(t, e, r) {
        for(var n = 0; 4 > n; n++)if (t[e + n] != r.charCodeAt(n)) return !0;
        return !1;
    }
    function n(t, e, r, n, i) {
        for(var a = 0; a < i; a++)t[e + a] = r[n + a];
    }
    function i(t, e, r, n) {
        for(var i = 0; i < n; i++)t[e + i] = r;
    }
    function a(t) {
        return new Int32Array(t);
    }
    function o(t, e) {
        for(var r = [], n = 0; n < t; n++)r.push(new e);
        return r;
    }
    function s(t, e) {
        var r = [];
        return function t(r, n, i) {
            for(var a = i[n], o = 0; o < a && (r.push(i.length > n + 1 ? [] : new e), !(i.length < n + 1)); o++)t(r[o], n + 1, i);
        }(r, 0, t), r;
    }
    var c = function() {
        var t = this;
        function c(t, e) {
            for(var r = 1 << e - 1 >>> 0; t & r;)r >>>= 1;
            return r ? (t & r - 1) + r : t;
        }
        function u(t, r, n, i, a) {
            e(!(i % n));
            do t[r + (i -= n)] = a;
            while (0 < i);
        }
        function h(t, r, n, i, o) {
            if (e(2328 >= o), 512 >= o) var s = a(512);
            else if (null == (s = a(o))) return 0;
            return function(t, r, n, i, o, s) {
                var h, f, d = r, p = 1 << n, g = a(16), m = a(16);
                for(e(0 != o), e(null != i), e(null != t), e(0 < n), f = 0; f < o; ++f){
                    if (15 < i[f]) return 0;
                    ++g[i[f]];
                }
                if (g[0] == o) return 0;
                for(m[1] = 0, h = 1; 15 > h; ++h){
                    if (g[h] > 1 << h) return 0;
                    m[h + 1] = m[h] + g[h];
                }
                for(f = 0; f < o; ++f)h = i[f], 0 < i[f] && (s[m[h]++] = f);
                if (1 == m[15]) return (i = new l).g = 0, i.value = s[0], u(t, d, 1, p, i), p;
                var v, b = -1, y = p - 1, w = 0, N = 1, L = 1, A = 1 << n;
                for(f = 0, h = 1, o = 2; h <= n; ++h, o <<= 1){
                    if (N += L <<= 1, 0 > (L -= g[h])) return 0;
                    for(; 0 < g[h]; --g[h])(i = new l).g = h, i.value = s[f++], u(t, d + w, o, A, i), w = c(w, h);
                }
                for(h = n + 1, o = 2; 15 >= h; ++h, o <<= 1){
                    if (N += L <<= 1, 0 > (L -= g[h])) return 0;
                    for(; 0 < g[h]; --g[h]){
                        if (i = new l, (w & y) != b) {
                            for(d += A, v = 1 << (b = h) - n; 15 > b && !(0 >= (v -= g[b]));)++b, v <<= 1;
                            p += A = 1 << (v = b - n), t[r + (b = w & y)].g = v + n, t[r + b].value = d - r - b;
                        }
                        i.g = h - n, i.value = s[f++], u(t, d + (w >> n), o, A, i), w = c(w, h);
                    }
                }
                return N != 2 * m[15] - 1 ? 0 : p;
            }(t, r, n, i, o, s);
        }
        function l() {
            this.value = this.g = 0;
        }
        function f() {
            this.value = this.g = 0;
        }
        function d() {
            this.G = o(5, l), this.H = a(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o(Dr, f);
        }
        function p(t, r, n, i) {
            e(null != t), e(null != r), e(2147483648 > i), t.Ca = 254, t.I = 0, t.b = -8, t.Ka = 0, t.oa = r, t.pa = n, t.Jd = r, t.Yc = n + i, t.Zc = 4 <= i ? n + i - 4 + 1 : n, _(t);
        }
        function g(t, e) {
            for(var r = 0; 0 < e--;)r |= k(t, 128) << e;
            return r;
        }
        function m(t, e) {
            var r = g(t, e);
            return P(t) ? -r : r;
        }
        function v(t, r, n, i) {
            var a, o = 0;
            for(e(null != t), e(null != r), e(4294967288 > i), t.Sb = i, t.Ra = 0, t.u = 0, t.h = 0, 4 < i && (i = 4), a = 0; a < i; ++a)o += r[n + a] << 8 * a;
            t.Ra = o, t.bb = i, t.oa = r, t.pa = n;
        }
        function b(t) {
            for(; 8 <= t.u && t.bb < t.Sb;)t.Ra >>>= 8, t.Ra += t.oa[t.pa + t.bb] << Ur - 8 >>> 0, ++t.bb, t.u -= 8;
            A(t) && (t.h = 1, t.u = 0);
        }
        function y(t, r) {
            if (e(0 <= r), !t.h && r <= Tr) {
                var n = L(t) & Rr[r];
                return t.u += r, b(t), n;
            }
            return t.h = 1, t.u = 0;
        }
        function w() {
            this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
        }
        function N() {
            this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
        }
        function L(t) {
            return t.Ra >>> (t.u & Ur - 1) >>> 0;
        }
        function A(t) {
            return e(t.bb <= t.Sb), t.h || t.bb == t.Sb && t.u > Ur;
        }
        function x(t, e) {
            t.u = e, t.h = A(t);
        }
        function S(t) {
            t.u >= zr && (e(t.u >= zr), b(t));
        }
        function _(t) {
            e(null != t && null != t.oa), t.pa < t.Zc ? (t.I = (t.oa[t.pa++] | t.I << 8) >>> 0, t.b += 8) : (e(null != t && null != t.oa), t.pa < t.Yc ? (t.b += 8, t.I = t.oa[t.pa++] | t.I << 8) : t.Ka ? t.b = 0 : (t.I <<= 8, t.b += 8, t.Ka = 1));
        }
        function P(t) {
            return g(t, 1);
        }
        function k(t, e) {
            var r = t.Ca;
            0 > t.b && _(t);
            var n = t.b, i = r * e >>> 8, a = (t.I >>> n > i) + 0;
            for(a ? (r -= i, t.I -= i + 1 << n >>> 0) : r = i + 1, n = r, i = 0; 256 <= n;)i += 8, n >>= 8;
            return n = 7 ^ i + Hr[n], t.b -= n, t.Ca = (r << n) - 1, a;
        }
        function I(t, e, r) {
            t[e + 0] = r >> 24 & 255, t[e + 1] = r >> 16 & 255, t[e + 2] = r >> 8 & 255, t[e + 3] = r >> 0 & 255;
        }
        function F(t, e) {
            return t[e + 0] << 0 | t[e + 1] << 8;
        }
        function C(t, e) {
            return F(t, e) | t[e + 2] << 16;
        }
        function j(t, e) {
            return F(t, e) | F(t, e + 2) << 16;
        }
        function O(t, r) {
            var n = 1 << r;
            return e(null != t), e(0 < r), t.X = a(n), null == t.X ? 0 : (t.Mb = 32 - r, t.Xa = r, 1);
        }
        function B(t, r) {
            e(null != t), e(null != r), e(t.Xa == r.Xa), n(r.X, 0, t.X, 0, 1 << r.Xa);
        }
        function M() {
            this.X = [], this.Xa = this.Mb = 0;
        }
        function E(t, r, n, i) {
            e(null != n), e(null != i);
            var a = n[0], o = i[0];
            return 0 == a && (a = (t * o + r / 2) / r), 0 == o && (o = (r * a + t / 2) / t), 0 >= a || 0 >= o ? 0 : (n[0] = a, i[0] = o, 1);
        }
        function q(t, e) {
            return t + (1 << e) - 1 >>> e;
        }
        function D(t, e) {
            return ((4278255360 & t) + (4278255360 & e) >>> 0 & 4278255360) + ((16711935 & t) + (16711935 & e) >>> 0 & 16711935) >>> 0;
        }
        function R(e, r) {
            t[r] = function(r, n, i, a, o, s, c) {
                var u;
                for(u = 0; u < o; ++u){
                    var h = t[e](s[c + u - 1], i, a + u);
                    s[c + u] = D(r[n + u], h);
                }
            };
        }
        function T() {
            this.ud = this.hd = this.jd = 0;
        }
        function U(t, e) {
            return ((4278124286 & (t ^ e)) >>> 1) + (t & e) >>> 0;
        }
        function z(t) {
            return 0 <= t && 256 > t ? t : 0 > t ? 0 : 255 < t ? 255 : void 0;
        }
        function H(t, e) {
            return z(t + (t - e + .5 >> 1));
        }
        function W(t, e, r) {
            return Math.abs(e - r) - Math.abs(t - r);
        }
        function V(t, e, r, n, i, a, o) {
            for(n = a[o - 1], r = 0; r < i; ++r)a[o + r] = n = D(t[e + r], n);
        }
        function G(t, e, r, n, i) {
            var a;
            for(a = 0; a < r; ++a){
                var o = t[e + a], s = o >> 8 & 255, c = 16711935 & (c = (c = 16711935 & o) + ((s << 16) + s));
                n[i + a] = (4278255360 & o) + c >>> 0;
            }
        }
        function Y(t, e) {
            e.jd = t >> 0 & 255, e.hd = t >> 8 & 255, e.ud = t >> 16 & 255;
        }
        function J(t, e, r, n, i, a) {
            var o;
            for(o = 0; o < n; ++o){
                var s = e[r + o], c = s >>> 8, u = s, h = 255 & (h = (h = s >>> 16) + ((t.jd << 24 >> 24) * (c << 24 >> 24) >>> 5));
                u = 255 & (u = (u = u + ((t.hd << 24 >> 24) * (c << 24 >> 24) >>> 5)) + ((t.ud << 24 >> 24) * (h << 24 >> 24) >>> 5));
                i[a + o] = (4278255360 & s) + (h << 16) + u;
            }
        }
        function X(e, r, n, i, a) {
            t[r] = function(t, e, r, n, o, s, c, u, h) {
                for(n = c; n < u; ++n)for(c = 0; c < h; ++c)o[s++] = a(r[i(t[e++])]);
            }, t[e] = function(e, r, o, s, c, u, h) {
                var l = 8 >> e.b, f = e.Ea, d = e.K[0], p = e.w;
                if (8 > l) for(e = (1 << e.b) - 1, p = (1 << l) - 1; r < o; ++r){
                    var g, m = 0;
                    for(g = 0; g < f; ++g)g & e || (m = i(s[c++])), u[h++] = a(d[m & p]), m >>= l;
                }
                else t["VP8LMapColor" + n](s, c, d, p, u, h, r, o, f);
            };
        }
        function K(t, e, r, n, i) {
            for(r = e + r; e < r;){
                var a = t[e++];
                n[i++] = a >> 16 & 255, n[i++] = a >> 8 & 255, n[i++] = a >> 0 & 255;
            }
        }
        function Z(t, e, r, n, i) {
            for(r = e + r; e < r;){
                var a = t[e++];
                n[i++] = a >> 16 & 255, n[i++] = a >> 8 & 255, n[i++] = a >> 0 & 255, n[i++] = a >> 24 & 255;
            }
        }
        function $(t, e, r, n, i) {
            for(r = e + r; e < r;){
                var a = (o = t[e++]) >> 16 & 240 | o >> 12 & 15, o = o >> 0 & 240 | o >> 28 & 15;
                n[i++] = a, n[i++] = o;
            }
        }
        function Q(t, e, r, n, i) {
            for(r = e + r; e < r;){
                var a = (o = t[e++]) >> 16 & 248 | o >> 13 & 7, o = o >> 5 & 224 | o >> 3 & 31;
                n[i++] = a, n[i++] = o;
            }
        }
        function tt(t, e, r, n, i) {
            for(r = e + r; e < r;){
                var a = t[e++];
                n[i++] = a >> 0 & 255, n[i++] = a >> 8 & 255, n[i++] = a >> 16 & 255;
            }
        }
        function et(t, e, r, i, a, o) {
            if (0 == o) for(r = e + r; e < r;)I(i, ((o = t[e++])[0] >> 24 | o[1] >> 8 & 65280 | o[2] << 8 & 16711680 | o[3] << 24) >>> 0), a += 32;
            else n(i, a, t, e, r);
        }
        function rt(e, r) {
            t[r][0] = t[e + "0"], t[r][1] = t[e + "1"], t[r][2] = t[e + "2"], t[r][3] = t[e + "3"], t[r][4] = t[e + "4"], t[r][5] = t[e + "5"], t[r][6] = t[e + "6"], t[r][7] = t[e + "7"], t[r][8] = t[e + "8"], t[r][9] = t[e + "9"], t[r][10] = t[e + "10"], t[r][11] = t[e + "11"], t[r][12] = t[e + "12"], t[r][13] = t[e + "13"], t[r][14] = t[e + "0"], t[r][15] = t[e + "0"];
        }
        function nt(t) {
            return t == Hn || t == Wn || t == Vn || t == Gn;
        }
        function it() {
            this.eb = [], this.size = this.A = this.fb = 0;
        }
        function at() {
            this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
        }
        function ot() {
            this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it, this.f.kb = new at, this.sd = null;
        }
        function st() {
            this.width = [
                0
            ], this.height = [
                0
            ], this.Pd = [
                0
            ], this.Qd = [
                0
            ], this.format = [
                0
            ];
        }
        function ct() {
            this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
        }
        function ut(t) {
            return alert("todo:WebPSamplerProcessPlane"), t.T;
        }
        function ht(t, e) {
            var r = t.T, i = e.ba.f.RGBA, a = i.eb, o = i.fb + t.ka * i.A, s = vi[e.ba.S], c = t.y, u = t.O, h = t.f, l = t.N, f = t.ea, d = t.W, p = e.cc, g = e.dc, m = e.Mc, v = e.Nc, b = t.ka, y = t.ka + t.T, w = t.U, N = w + 1 >> 1;
            for(0 == b ? s(c, u, null, null, h, l, f, d, h, l, f, d, a, o, null, null, w) : (s(e.ec, e.fc, c, u, p, g, m, v, h, l, f, d, a, o - i.A, a, o, w), ++r); b + 2 < y; b += 2)p = h, g = l, m = f, v = d, l += t.Rc, d += t.Rc, o += 2 * i.A, s(c, (u += 2 * t.fa) - t.fa, c, u, p, g, m, v, h, l, f, d, a, o - i.A, a, o, w);
            return u += t.fa, t.j + y < t.o ? (n(e.ec, e.fc, c, u, w), n(e.cc, e.dc, h, l, N), n(e.Mc, e.Nc, f, d, N), r--) : 1 & y || s(c, u, null, null, h, l, f, d, h, l, f, d, a, o + i.A, null, null, w), r;
        }
        function lt(t, r, n) {
            var i = t.F, a = [
                t.J
            ];
            if (null != i) {
                var o = t.U, s = r.ba.S, c = s == Tn || s == Vn;
                r = r.ba.f.RGBA;
                var u = [
                    0
                ], h = t.ka;
                u[0] = t.T, t.Kb && (0 == h ? --u[0] : (--h, a[0] -= t.width), t.j + t.ka + t.T == t.o && (u[0] = t.o - t.j - h));
                var l = r.eb;
                h = r.fb + h * r.A;
                t = Sn(i, a[0], t.width, o, u, l, h + (c ? 0 : 3), r.A), e(n == u), t && nt(s) && An(l, h, c, o, u, r.A);
            }
            return 0;
        }
        function ft(t) {
            var e = t.ma, r = e.ba.S, n = 11 > r, i = r == qn || r == Rn || r == Tn || r == Un || 12 == r || nt(r);
            if (e.memory = null, e.Ib = null, e.Jb = null, e.Nd = null, !Mr(e.Oa, t, i ? 11 : 12)) return 0;
            if (i && nt(r) && br(), t.da) alert("todo:use_scaling");
            else {
                if (n) {
                    if (e.Ib = ut, t.Kb) {
                        if (r = t.U + 1 >> 1, e.memory = a(t.U + 2 * r), null == e.memory) return 0;
                        e.ec = e.memory, e.fc = 0, e.cc = e.ec, e.dc = e.fc + t.U, e.Mc = e.cc, e.Nc = e.dc + r, e.Ib = ht, br();
                    }
                } else alert("todo:EmitYUV");
                i && (e.Jb = lt, n && mr());
            }
            if (n && !Ci) {
                for(t = 0; 256 > t; ++t)ji[t] = 89858 * (t - 128) + _i >> Si, Mi[t] = -22014 * (t - 128) + _i, Bi[t] = -45773 * (t - 128), Oi[t] = 113618 * (t - 128) + _i >> Si;
                for(t = Pi; t < ki; ++t)e = 76283 * (t - 16) + _i >> Si, Ei[t - Pi] = Vt(e, 255), qi[t - Pi] = Vt(e + 8 >> 4, 15);
                Ci = 1;
            }
            return 1;
        }
        function dt(t) {
            var r = t.ma, n = t.U, i = t.T;
            return e(!(1 & t.ka)), 0 >= n || 0 >= i ? 0 : (n = r.Ib(t, r), null != r.Jb && r.Jb(t, r, n), r.Dc += n, 1);
        }
        function pt(t) {
            t.ma.memory = null;
        }
        function gt(t, e, r, n) {
            return 47 != y(t, 8) ? 0 : (e[0] = y(t, 14) + 1, r[0] = y(t, 14) + 1, n[0] = y(t, 1), 0 != y(t, 3) ? 0 : !t.h);
        }
        function mt(t, e) {
            if (4 > t) return t + 1;
            var r = t - 2 >> 1;
            return (2 + (1 & t) << r) + y(e, r) + 1;
        }
        function vt(t, e) {
            var r;
            return 120 < e ? e - 120 : 1 <= (r = ((r = $n[e - 1]) >> 4) * t + (8 - (15 & r))) ? r : 1;
        }
        function bt(t, e, r) {
            var n = L(r), i = t[e += 255 & n].g - 8;
            return 0 < i && (x(r, r.u + 8), n = L(r), e += t[e].value, e += n & (1 << i) - 1), x(r, r.u + t[e].g), t[e].value;
        }
        function yt(t, r, n) {
            return n.g += t.g, n.value += t.value << r >>> 0, e(8 >= n.g), t.g;
        }
        function wt(t, r, n) {
            var i = t.xc;
            return e((r = 0 == i ? 0 : t.vc[t.md * (n >> i) + (r >> i)]) < t.Wb), t.Ya[r];
        }
        function Nt(t, r, i, a) {
            var o = t.ab, s = t.c * r, c = t.C;
            r = c + r;
            var u = i, h = a;
            for(a = t.Ta, i = t.Ua; 0 < o--;){
                var l = t.gc[o], f = c, d = r, p = u, g = h, m = (h = a, u = i, l.Ea);
                switch(e(f < d), e(d <= l.nc), l.hc){
                    case 2:
                        Gr(p, g, (d - f) * m, h, u);
                        break;
                    case 0:
                        var v = f, b = d, y = h, w = u, N = (_ = l).Ea;
                        0 == v && (Wr(p, g, null, null, 1, y, w), V(p, g + 1, 0, 0, N - 1, y, w + 1), g += N, w += N, ++v);
                        for(var L = 1 << _.b, A = L - 1, x = q(N, _.b), S = _.K, _ = _.w + (v >> _.b) * x; v < b;){
                            var P = S, k = _, I = 1;
                            for(Vr(p, g, y, w - N, 1, y, w); I < N;){
                                var F = (I & ~A) + L;
                                F > N && (F = N), (0, Zr[P[k++] >> 8 & 15])(p, g + +I, y, w + I - N, F - I, y, w + I), I = F;
                            }
                            g += N, w += N, ++v & A || (_ += x);
                        }
                        d != l.nc && n(h, u - m, h, u + (d - f - 1) * m, m);
                        break;
                    case 1:
                        for(m = p, b = g, N = (p = l.Ea) - (w = p & ~(y = (g = 1 << l.b) - 1)), v = q(p, l.b), L = l.K, l = l.w + (f >> l.b) * v; f < d;){
                            for(A = L, x = l, S = new T, _ = b + w, P = b + p; b < _;)Y(A[x++], S), $r(S, m, b, g, h, u), b += g, u += g;
                            b < P && (Y(A[x++], S), $r(S, m, b, N, h, u), b += N, u += N), ++f & y || (l += v);
                        }
                        break;
                    case 3:
                        if (p == h && g == u && 0 < l.b) {
                            for(b = h, p = m = u + (d - f) * m - (w = (d - f) * q(l.Ea, l.b)), g = h, y = u, v = [], w = (N = w) - 1; 0 <= w; --w)v[w] = g[y + w];
                            for(w = N - 1; 0 <= w; --w)b[p + w] = v[w];
                            Yr(l, f, d, h, m, h, u);
                        } else Yr(l, f, d, p, g, h, u);
                }
                u = a, h = i;
            }
            h != i && n(a, i, u, h, s);
        }
        function Lt(t, r) {
            var n = t.V, i = t.Ba + t.c * t.C, a = r - t.C;
            if (e(r <= t.l.o), e(16 >= a), 0 < a) {
                var o = t.l, s = t.Ta, c = t.Ua, u = o.width;
                if (Nt(t, a, n, i), a = c = [
                    c
                ], e((n = t.C) < (i = r)), e(o.v < o.va), i > o.o && (i = o.o), n < o.j) {
                    var h = o.j - n;
                    n = o.j;
                    a[0] += h * u;
                }
                if (n >= i ? n = 0 : (a[0] += 4 * o.v, o.ka = n - o.j, o.U = o.va - o.v, o.T = i - n, n = 1), n) {
                    if (c = c[0], 11 > (n = t.ca).S) {
                        var l = n.f.RGBA, f = (i = n.S, a = o.U, o = o.T, h = l.eb, l.A), d = o;
                        for(l = l.fb + t.Ma * l.A; 0 < d--;){
                            var p = s, g = c, m = a, v = h, b = l;
                            switch(i){
                                case En:
                                    Qr(p, g, m, v, b);
                                    break;
                                case qn:
                                    tn(p, g, m, v, b);
                                    break;
                                case Hn:
                                    tn(p, g, m, v, b), An(v, b, 0, m, 1, 0);
                                    break;
                                case Dn:
                                    nn(p, g, m, v, b);
                                    break;
                                case Rn:
                                    et(p, g, m, v, b, 1);
                                    break;
                                case Wn:
                                    et(p, g, m, v, b, 1), An(v, b, 0, m, 1, 0);
                                    break;
                                case Tn:
                                    et(p, g, m, v, b, 0);
                                    break;
                                case Vn:
                                    et(p, g, m, v, b, 0), An(v, b, 1, m, 1, 0);
                                    break;
                                case Un:
                                    en(p, g, m, v, b);
                                    break;
                                case Gn:
                                    en(p, g, m, v, b), xn(v, b, m, 1, 0);
                                    break;
                                case zn:
                                    rn(p, g, m, v, b);
                                    break;
                                default:
                                    e(0);
                            }
                            c += u, l += f;
                        }
                        t.Ma += o;
                    } else alert("todo:EmitRescaledRowsYUVA");
                    e(t.Ma <= n.height);
                }
            }
            t.C = r, e(t.C <= t.i);
        }
        function At(t) {
            var e;
            if (0 < t.ua) return 0;
            for(e = 0; e < t.Wb; ++e){
                var r = t.Ya[e].G, n = t.Ya[e].H;
                if (0 < r[1][n[1] + 0].g || 0 < r[2][n[2] + 0].g || 0 < r[3][n[3] + 0].g) return 0;
            }
            return 1;
        }
        function xt(t, r, n, i, a, o) {
            if (0 != t.Z) {
                var s = t.qd, c = t.rd;
                for(e(null != mi[t.Z]); r < n; ++r)mi[t.Z](s, c, i, a, i, a, o), s = i, c = a, a += o;
                t.qd = s, t.rd = c;
            }
        }
        function St(t, r) {
            var n = t.l.ma, i = 0 == n.Z || 1 == n.Z ? t.l.j : t.C;
            i = t.C < i ? i : t.C;
            if (e(r <= t.l.o), r > i) {
                var a = t.l.width, o = n.ca, s = n.tb + a * i, c = t.V, u = t.Ba + t.c * i, h = t.gc;
                e(1 == t.ab), e(3 == h[0].hc), Xr(h[0], i, r, c, u, o, s), xt(n, i, r, o, s, a);
            }
            t.C = t.Ma = r;
        }
        function _t(t, r, n, i, a, o, s) {
            var c = t.$ / i, u = t.$ % i, h = t.m, l = t.s, f = n + t.$, d = f;
            a = n + i * a;
            var p = n + i * o, g = 280 + l.ua, m = t.Pb ? c : 16777216, v = 0 < l.ua ? l.Wa : null, b = l.wc, y = f < p ? wt(l, u, c) : null;
            e(t.C < o), e(p <= a);
            var w = !1;
            t: for(;;){
                for(; w || f < p;){
                    var N = 0;
                    if (c >= m) {
                        var _ = f - n;
                        e((m = t).Pb), m.wd = m.m, m.xd = _, 0 < m.s.ua && B(m.s.Wa, m.s.vb), m = c + ti;
                    }
                    if (u & b || (y = wt(l, u, c)), e(null != y), y.Qb && (r[f] = y.qb, w = !0), !w) {
                        if (S(h), y.jc) {
                            N = h, _ = r;
                            var P = f, k = y.pd[L(N) & Dr - 1];
                            e(y.jc), 256 > k.g ? (x(N, N.u + k.g), _[P] = k.value, N = 0) : (x(N, N.u + k.g - 256), e(256 <= k.value), N = k.value), 0 == N && (w = !0);
                        } else N = bt(y.G[0], y.H[0], h);
                    }
                    if (h.h) break;
                    if (w || 256 > N) {
                        if (!w) {
                            if (y.nd) r[f] = (y.qb | N << 8) >>> 0;
                            else {
                                if (S(h), w = bt(y.G[1], y.H[1], h), S(h), _ = bt(y.G[2], y.H[2], h), P = bt(y.G[3], y.H[3], h), h.h) break;
                                r[f] = (P << 24 | w << 16 | N << 8 | _) >>> 0;
                            }
                        }
                        if (w = !1, ++f, ++u >= i && (u = 0, ++c, null != s && c <= o && !(c % 16) && s(t, c), null != v)) for(; d < f;)N = r[d++], v.X[(506832829 * N & 4294967295) >>> v.Mb] = N;
                    } else if (280 > N) {
                        if (N = mt(N - 256, h), _ = bt(y.G[4], y.H[4], h), S(h), _ = vt(i, _ = mt(_, h)), h.h) break;
                        if (f - n < _ || a - f < N) break t;
                        for(P = 0; P < N; ++P)r[f + P] = r[f + P - _];
                        for(f += N, u += N; u >= i;)u -= i, ++c, null != s && c <= o && !(c % 16) && s(t, c);
                        if (e(f <= a), u & b && (y = wt(l, u, c)), null != v) for(; d < f;)N = r[d++], v.X[(506832829 * N & 4294967295) >>> v.Mb] = N;
                    } else {
                        if (!(N < g)) break t;
                        for(w = N - 280, e(null != v); d < f;)N = r[d++], v.X[(506832829 * N & 4294967295) >>> v.Mb] = N;
                        N = f, e(!(w >>> (_ = v).Xa)), r[N] = _.X[w], w = !0;
                    }
                    w || e(h.h == A(h));
                }
                if (t.Pb && h.h && f < a) e(t.m.h), t.a = 5, t.m = t.wd, t.$ = t.xd, 0 < t.s.ua && B(t.s.vb, t.s.Wa);
                else {
                    if (h.h) break t;
                    null != s && s(t, c > o ? o : c), t.a = 0, t.$ = f - n;
                }
                return 1;
            }
            return t.a = 3, 0;
        }
        function Pt(t) {
            e(null != t), t.vc = null, t.yc = null, t.Ya = null;
            var r = t.Wa;
            null != r && (r.X = null), t.vb = null, e(null != t);
        }
        function kt() {
            var e = new or;
            return null == e ? null : (e.a = 0, e.xb = gi, rt("Predictor", "VP8LPredictors"), rt("Predictor", "VP8LPredictors_C"), rt("PredictorAdd", "VP8LPredictorsAdd"), rt("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G, $r = J, Qr = K, tn = Z, en = $, rn = Q, nn = tt, t.VP8LMapColor32b = Jr, t.VP8LMapColor8b = Kr, e);
        }
        function It(t, r, n, s, c) {
            var u = 1, f = [
                t
            ], p = [
                r
            ], g = s.m, m = s.s, v = null, b = 0;
            t: for(;;){
                if (n) for(; u && y(g, 1);){
                    var w = f, N = p, A = s, _ = 1, P = A.m, k = A.gc[A.ab], I = y(P, 2);
                    if (A.Oc & 1 << I) u = 0;
                    else {
                        switch(A.Oc |= 1 << I, k.hc = I, k.Ea = w[0], k.nc = N[0], k.K = [
                            null
                        ], ++A.ab, e(4 >= A.ab), I){
                            case 0:
                            case 1:
                                k.b = y(P, 3) + 2, _ = It(q(k.Ea, k.b), q(k.nc, k.b), 0, A, k.K), k.K = k.K[0];
                                break;
                            case 3:
                                var F, C = y(P, 8) + 1, j = 16 < C ? 0 : 4 < C ? 1 : 2 < C ? 2 : 3;
                                if (w[0] = q(k.Ea, j), k.b = j, F = _ = It(C, 1, 0, A, k.K)) {
                                    var B, M = C, E = k, R = 1 << (8 >> E.b), T = a(R);
                                    if (null == T) F = 0;
                                    else {
                                        var U = E.K[0], z = E.w;
                                        for(T[0] = E.K[0][0], B = 1; B < 1 * M; ++B)T[B] = D(U[z + B], T[B - 1]);
                                        for(; B < 4 * R; ++B)T[B] = 0;
                                        E.K[0] = null, E.K[0] = T, F = 1;
                                    }
                                }
                                _ = F;
                                break;
                            case 2:
                                break;
                            default:
                                e(0);
                        }
                        u = _;
                    }
                }
                if (f = f[0], p = p[0], u && y(g, 1) && !(u = 1 <= (b = y(g, 4)) && 11 >= b)) {
                    s.a = 3;
                    break t;
                }
                var H;
                if (H = u) e: {
                    var W, V, G, Y = s, J = f, X = p, K = b, Z = n, $ = Y.m, Q = Y.s, tt = [
                        null
                    ], et = 1, rt = 0, nt = Qn[K];
                    r: for(;;){
                        if (Z && y($, 1)) {
                            var it = y($, 3) + 2, at = q(J, it), ot = q(X, it), st = at * ot;
                            if (!It(at, ot, 0, Y, tt)) break r;
                            for(tt = tt[0], Q.xc = it, W = 0; W < st; ++W){
                                var ct = tt[W] >> 8 & 65535;
                                tt[W] = ct, ct >= et && (et = ct + 1);
                            }
                        }
                        if ($.h) break r;
                        for(V = 0; 5 > V; ++V){
                            var ut = Xn[V];
                            !V && 0 < K && (ut += 1 << K), rt < ut && (rt = ut);
                        }
                        var ht = o(et * nt, l), lt = et, ft = o(lt, d);
                        if (null == ft) var dt = null;
                        else e(65536 >= lt), dt = ft;
                        var pt = a(rt);
                        if (null == dt || null == pt || null == ht) {
                            Y.a = 1;
                            break r;
                        }
                        var gt = ht;
                        for(W = G = 0; W < et; ++W){
                            var mt = dt[W], vt = mt.G, bt = mt.H, wt = 0, Nt = 1, Lt = 0;
                            for(V = 0; 5 > V; ++V){
                                ut = Xn[V], vt[V] = gt, bt[V] = G, !V && 0 < K && (ut += 1 << K);
                                n: {
                                    var At, xt = ut, St = Y, kt = pt, Ft = gt, Ct = G, jt = 0, Ot = St.m, Bt = y(Ot, 1);
                                    if (i(kt, 0, 0, xt), Bt) {
                                        var Mt = y(Ot, 1) + 1, Et = y(Ot, 1), qt = y(Ot, 0 == Et ? 1 : 8);
                                        kt[qt] = 1, 2 == Mt && (kt[qt = y(Ot, 8)] = 1);
                                        var Dt = 1;
                                    } else {
                                        var Rt = a(19), Tt = y(Ot, 4) + 4;
                                        if (19 < Tt) {
                                            St.a = 3;
                                            var Ut = 0;
                                            break n;
                                        }
                                        for(At = 0; At < Tt; ++At)Rt[Zn[At]] = y(Ot, 3);
                                        var zt = void 0, Ht = void 0, Wt = St, Vt = Rt, Gt = xt, Yt = kt, Jt = 0, Xt = Wt.m, Kt = 8, Zt = o(128, l);
                                        i: for(; h(Zt, 0, 7, Vt, 19);){
                                            if (y(Xt, 1)) {
                                                var $t = 2 + 2 * y(Xt, 3);
                                                if ((zt = 2 + y(Xt, $t)) > Gt) break i;
                                            } else zt = Gt;
                                            for(Ht = 0; Ht < Gt && zt--;){
                                                S(Xt);
                                                var Qt = Zt[0 + (127 & L(Xt))];
                                                x(Xt, Xt.u + Qt.g);
                                                var te = Qt.value;
                                                if (16 > te) Yt[Ht++] = te, 0 != te && (Kt = te);
                                                else {
                                                    var ee = 16 == te, re = te - 16, ne = Jn[re], ie = y(Xt, Yn[re]) + ne;
                                                    if (Ht + ie > Gt) break i;
                                                    for(var ae = ee ? Kt : 0; 0 < ie--;)Yt[Ht++] = ae;
                                                }
                                            }
                                            Jt = 1;
                                            break i;
                                        }
                                        Jt || (Wt.a = 3), Dt = Jt;
                                    }
                                    (Dt = Dt && !Ot.h) && (jt = h(Ft, Ct, 8, kt, xt)), Dt && 0 != jt ? Ut = jt : (St.a = 3, Ut = 0);
                                }
                                if (0 == Ut) break r;
                                if (Nt && 1 == Kn[V] && (Nt = 0 == gt[G].g), wt += gt[G].g, G += Ut, 3 >= V) {
                                    var oe, se = pt[0];
                                    for(oe = 1; oe < ut; ++oe)pt[oe] > se && (se = pt[oe]);
                                    Lt += se;
                                }
                            }
                            if (mt.nd = Nt, mt.Qb = 0, Nt && (mt.qb = (vt[3][bt[3] + 0].value << 24 | vt[1][bt[1] + 0].value << 16 | vt[2][bt[2] + 0].value) >>> 0, 0 == wt && 256 > vt[0][bt[0] + 0].value && (mt.Qb = 1, mt.qb += vt[0][bt[0] + 0].value << 8)), mt.jc = !mt.Qb && 6 > Lt, mt.jc) {
                                var ce, ue = mt;
                                for(ce = 0; ce < Dr; ++ce){
                                    var he = ce, le = ue.pd[he], fe = ue.G[0][ue.H[0] + he];
                                    256 <= fe.value ? (le.g = fe.g + 256, le.value = fe.value) : (le.g = 0, le.value = 0, he >>= yt(fe, 8, le), he >>= yt(ue.G[1][ue.H[1] + he], 16, le), he >>= yt(ue.G[2][ue.H[2] + he], 0, le), yt(ue.G[3][ue.H[3] + he], 24, le));
                                }
                            }
                        }
                        Q.vc = tt, Q.Wb = et, Q.Ya = dt, Q.yc = ht, H = 1;
                        break e;
                    }
                    H = 0;
                }
                if (!(u = H)) {
                    s.a = 3;
                    break t;
                }
                if (0 < b) {
                    if (m.ua = 1 << b, !O(m.Wa, b)) {
                        s.a = 1, u = 0;
                        break t;
                    }
                } else m.ua = 0;
                var de = s, pe = f, ge = p, me = de.s, ve = me.xc;
                if (de.c = pe, de.i = ge, me.md = q(pe, ve), me.wc = 0 == ve ? -1 : (1 << ve) - 1, n) {
                    s.xb = pi;
                    break t;
                }
                if (null == (v = a(f * p))) {
                    s.a = 1, u = 0;
                    break t;
                }
                u = (u = _t(s, v, 0, f, p, p, null)) && !g.h;
                break t;
            }
            return u ? (null != c ? c[0] = v : (e(null == v), e(n)), s.$ = 0, n || Pt(m)) : Pt(m), u;
        }
        function Ft(t, r) {
            var n = t.c * t.i, i = n + r + 16 * r;
            return e(t.c <= r), t.V = a(i), null == t.V ? (t.Ta = null, t.Ua = 0, t.a = 1, 0) : (t.Ta = t.V, t.Ua = t.Ba + n + r, 1);
        }
        function Ct(t, r) {
            var n = t.C, i = r - n, a = t.V, o = t.Ba + t.c * n;
            for(e(r <= t.l.o); 0 < i;){
                var s = 16 < i ? 16 : i, c = t.l.ma, u = t.l.width, h = u * s, l = c.ca, f = c.tb + u * n, d = t.Ta, p = t.Ua;
                Nt(t, s, a, o), _n(d, p, l, f, h), xt(c, n, n + s, l, f, u), i -= s, a += s * t.c, n += s;
            }
            e(n == r), t.C = t.Ma = r;
        }
        function jt() {
            this.ub = this.yd = this.td = this.Rb = 0;
        }
        function Ot() {
            this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
        }
        function Bt() {
            this.Fb = this.Bb = this.Cb = 0, this.Zb = a(4), this.Lb = a(4);
        }
        function Mt() {
            this.Yb = function() {
                var t = [];
                return function t(e, r, n) {
                    for(var i = n[r], a = 0; a < i && (e.push(n.length > r + 1 ? [] : 0), !(n.length < r + 1)); a++)t(e[a], r + 1, n);
                }(t, 0, [
                    3,
                    11
                ]), t;
            }();
        }
        function Et() {
            this.jb = a(3), this.Wc = s([
                4,
                8
            ], Mt), this.Xc = s([
                4,
                17
            ], Mt);
        }
        function qt() {
            this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a(4), this.od = new a(4);
        }
        function Dt() {
            this.ld = this.La = this.dd = this.tc = 0;
        }
        function Rt() {
            this.Na = this.la = 0;
        }
        function Tt() {
            this.Sc = [
                0,
                0
            ], this.Eb = [
                0,
                0
            ], this.Qc = [
                0,
                0
            ], this.ia = this.lc = 0;
        }
        function Ut() {
            this.ad = a(384), this.Za = 0, this.Ob = a(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
        }
        function zt() {
            this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt), this.Y = 0, this.ya = Array(new Ut), this.aa = 0, this.l = new Gt;
        }
        function Ht() {
            this.y = a(16), this.f = a(8), this.ea = a(8);
        }
        function Wt() {
            this.cb = this.a = 0, this.sc = "", this.m = new w, this.Od = new jt, this.Kc = new Ot, this.ed = new qt, this.Qa = new Bt, this.Ic = this.$c = this.Aa = 0, this.D = new zt, this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o(8, w), this.ia = 0, this.pb = o(4, Tt), this.Pa = new Et, this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [
                0,
                0,
                0,
                0
            ], this.Gd = Array(new Ht), this.Hd = 0, this.rb = Array(new Rt), this.sb = 0, this.wa = Array(new Dt), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ut), this.L = this.aa = 0, this.gd = s([
                4,
                2
            ], Dt), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
        }
        function Vt(t, e) {
            return 0 > t ? 0 : t > e ? e : t;
        }
        function Gt() {
            this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
        }
        function Yt() {
            var t = new Wt;
            return null != t && (t.a = 0, t.sc = "OK", t.cb = 0, t.Xb = 0, ni || (ni = Zt)), t;
        }
        function Jt(t, e, r) {
            return 0 == t.a && (t.a = e, t.sc = r, t.cb = 0), 0;
        }
        function Xt(t, e, r) {
            return 3 <= r && 157 == t[e + 0] && 1 == t[e + 1] && 42 == t[e + 2];
        }
        function Kt(t, r) {
            if (null == t) return 0;
            if (t.a = 0, t.sc = "OK", null == r) return Jt(t, 2, "null VP8Io passed to VP8GetHeaders()");
            var n = r.data, a = r.w, o = r.ha;
            if (4 > o) return Jt(t, 7, "Truncated header.");
            var s = n[a + 0] | n[a + 1] << 8 | n[a + 2] << 16, c = t.Od;
            if (c.Rb = !(1 & s), c.td = s >> 1 & 7, c.yd = s >> 4 & 1, c.ub = s >> 5, 3 < c.td) return Jt(t, 3, "Incorrect keyframe parameters.");
            if (!c.yd) return Jt(t, 4, "Frame not displayable.");
            a += 3, o -= 3;
            var u = t.Kc;
            if (c.Rb) {
                if (7 > o) return Jt(t, 7, "cannot parse picture header");
                if (!Xt(n, a, o)) return Jt(t, 3, "Bad code word");
                u.c = 16383 & (n[a + 4] << 8 | n[a + 3]), u.Td = n[a + 4] >> 6, u.i = 16383 & (n[a + 6] << 8 | n[a + 5]), u.Ud = n[a + 6] >> 6, a += 7, o -= 7, t.za = u.c + 15 >> 4, t.Ub = u.i + 15 >> 4, r.width = u.c, r.height = u.i, r.Da = 0, r.j = 0, r.v = 0, r.va = r.width, r.o = r.height, r.da = 0, r.ib = r.width, r.hb = r.height, r.U = r.width, r.T = r.height, i((s = t.Pa).jb, 0, 255, s.jb.length), e(null != (s = t.Qa)), s.Cb = 0, s.Bb = 0, s.Fb = 1, i(s.Zb, 0, 0, s.Zb.length), i(s.Lb, 0, 0, s.Lb);
            }
            if (c.ub > o) return Jt(t, 7, "bad partition length");
            p(s = t.m, n, a, c.ub), a += c.ub, o -= c.ub, c.Rb && (u.Ld = P(s), u.Kd = P(s)), u = t.Qa;
            var h, l = t.Pa;
            if (e(null != s), e(null != u), u.Cb = P(s), u.Cb) {
                if (u.Bb = P(s), P(s)) {
                    for(u.Fb = P(s), h = 0; 4 > h; ++h)u.Zb[h] = P(s) ? m(s, 7) : 0;
                    for(h = 0; 4 > h; ++h)u.Lb[h] = P(s) ? m(s, 6) : 0;
                }
                if (u.Bb) for(h = 0; 3 > h; ++h)l.jb[h] = P(s) ? g(s, 8) : 255;
            } else u.Bb = 0;
            if (s.Ka) return Jt(t, 3, "cannot parse segment header");
            if ((u = t.ed).zd = P(s), u.Tb = g(s, 6), u.wb = g(s, 3), u.Pc = P(s), u.Pc && P(s)) {
                for(l = 0; 4 > l; ++l)P(s) && (u.vd[l] = m(s, 6));
                for(l = 0; 4 > l; ++l)P(s) && (u.od[l] = m(s, 6));
            }
            if (t.L = 0 == u.Tb ? 0 : u.zd ? 1 : 2, s.Ka) return Jt(t, 3, "cannot parse filter header");
            var f = o;
            if (o = h = a, a = h + f, u = f, t.Xb = (1 << g(t.m, 2)) - 1, f < 3 * (l = t.Xb)) n = 7;
            else {
                for(h += 3 * l, u -= 3 * l, f = 0; f < l; ++f){
                    var d = n[o + 0] | n[o + 1] << 8 | n[o + 2] << 16;
                    d > u && (d = u), p(t.Jc[+f], n, h, d), h += d, u -= d, o += 3;
                }
                p(t.Jc[+l], n, h, u), n = h < a ? 0 : 5;
            }
            if (0 != n) return Jt(t, n, "cannot parse partitions");
            for(n = g(h = t.m, 7), o = P(h) ? m(h, 4) : 0, a = P(h) ? m(h, 4) : 0, u = P(h) ? m(h, 4) : 0, l = P(h) ? m(h, 4) : 0, h = P(h) ? m(h, 4) : 0, f = t.Qa, d = 0; 4 > d; ++d){
                if (f.Cb) {
                    var v = f.Zb[d];
                    f.Fb || (v += n);
                } else {
                    if (0 < d) {
                        t.pb[d] = t.pb[0];
                        continue;
                    }
                    v = n;
                }
                var b = t.pb[d];
                b.Sc[0] = ei[Vt(v + o, 127)], b.Sc[1] = ri[Vt(v + 0, 127)], b.Eb[0] = 2 * ei[Vt(v + a, 127)], b.Eb[1] = 101581 * ri[Vt(v + u, 127)] >> 16, 8 > b.Eb[1] && (b.Eb[1] = 8), b.Qc[0] = ei[Vt(v + l, 117)], b.Qc[1] = ri[Vt(v + h, 127)], b.lc = v + h;
            }
            if (!c.Rb) return Jt(t, 4, "Not a key frame.");
            for(P(s), c = t.Pa, n = 0; 4 > n; ++n){
                for(o = 0; 8 > o; ++o)for(a = 0; 3 > a; ++a)for(u = 0; 11 > u; ++u)l = k(s, ui[n][o][a][u]) ? g(s, 8) : si[n][o][a][u], c.Wc[n][o].Yb[a][u] = l;
                for(o = 0; 17 > o; ++o)c.Xc[n][o] = c.Wc[n][hi[o]];
            }
            return t.kc = P(s), t.kc && (t.Bd = g(s, 8)), t.cb = 1;
        }
        function Zt(t, e, r, n, i, a, o) {
            var s = e[i].Yb[r];
            for(r = 0; 16 > i; ++i){
                if (!k(t, s[r + 0])) return i;
                for(; !k(t, s[r + 1]);)if (s = e[++i].Yb[0], r = 0, 16 == i) return 16;
                var c = e[i + 1].Yb;
                if (k(t, s[r + 2])) {
                    var u = t, h = 0;
                    if (k(u, (f = s)[(l = r) + 3])) {
                        if (k(u, f[l + 6])) {
                            for(s = 0, l = 2 * (h = k(u, f[l + 8])) + (f = k(u, f[l + 9 + h])), h = 0, f = ii[l]; f[s]; ++s)h += h + k(u, f[s]);
                            h += 3 + (8 << l);
                        } else k(u, f[l + 7]) ? (h = 7 + 2 * k(u, 165), h += k(u, 145)) : h = 5 + k(u, 159);
                    } else h = k(u, f[l + 4]) ? 3 + k(u, f[l + 5]) : 2;
                    s = c[2];
                } else h = 1, s = c[1];
                c = o + ai[i], 0 > (u = t).b && _(u);
                var l, f = u.b, d = (l = u.Ca >> 1) - (u.I >> f) >> 31;
                --u.b, u.Ca += d, u.Ca |= 1, u.I -= (l + 1 & d) << f, a[c] = ((h ^ d) - d) * n[(0 < i) + 0];
            }
            return 16;
        }
        function $t(t) {
            var e = t.rb[t.sb - 1];
            e.la = 0, e.Na = 0, i(t.zc, 0, 0, t.zc.length), t.ja = 0;
        }
        function Qt(t, r) {
            if (null == t) return 0;
            if (null == r) return Jt(t, 2, "NULL VP8Io parameter in VP8Decode().");
            if (!t.cb && !Kt(t, r)) return 0;
            if (e(t.cb), null == r.ac || r.ac(r)) {
                r.ob && (t.L = 0);
                var s = Ri[t.L];
                if (2 == t.L ? (t.yb = 0, t.zb = 0) : (t.yb = r.v - s >> 4, t.zb = r.j - s >> 4, 0 > t.yb && (t.yb = 0), 0 > t.zb && (t.zb = 0)), t.Va = r.o + 15 + s >> 4, t.Hb = r.va + 15 + s >> 4, t.Hb > t.za && (t.Hb = t.za), t.Va > t.Ub && (t.Va = t.Ub), 0 < t.L) {
                    var c = t.ed;
                    for(s = 0; 4 > s; ++s){
                        var u;
                        if (t.Qa.Cb) {
                            var h = t.Qa.Lb[s];
                            t.Qa.Fb || (h += c.Tb);
                        } else h = c.Tb;
                        for(u = 0; 1 >= u; ++u){
                            var l = t.gd[s][u], f = h;
                            if (c.Pc && (f += c.vd[0], u && (f += c.od[0])), 0 < (f = 0 > f ? 0 : 63 < f ? 63 : f)) {
                                var d = f;
                                0 < c.wb && (d = 4 < c.wb ? d >> 2 : d >> 1) > 9 - c.wb && (d = 9 - c.wb), 1 > d && (d = 1), l.dd = d, l.tc = 2 * f + d, l.ld = 40 <= f ? 2 : 15 <= f ? 1 : 0;
                            } else l.tc = 0;
                            l.La = u;
                        }
                    }
                }
                s = 0;
            } else Jt(t, 6, "Frame setup failed"), s = t.a;
            if (s = 0 == s) {
                if (s) {
                    t.$c = 0, 0 < t.Aa || (t.Ic = Ui);
                    t: {
                        s = t.Ic;
                        c = 4 * (d = t.za);
                        var p = 32 * d, g = d + 1, m = 0 < t.L ? d * (0 < t.Aa ? 2 : 1) : 0, v = (2 == t.Aa ? 2 : 1) * d;
                        if ((l = c + 832 + (u = 3 * (16 * s + Ri[t.L]) / 2 * p) + (h = null != t.Fa && 0 < t.Fa.length ? t.Kc.c * t.Kc.i : 0)) != l) s = 0;
                        else {
                            if (l > t.Vb) {
                                if (t.Vb = 0, t.Ec = a(l), t.Fc = 0, null == t.Ec) {
                                    s = Jt(t, 1, "no memory during frame initialization.");
                                    break t;
                                }
                                t.Vb = l;
                            }
                            l = t.Ec, f = t.Fc, t.Ac = l, t.Bc = f, f += c, t.Gd = o(p, Ht), t.Hd = 0, t.rb = o(g + 1, Rt), t.sb = 1, t.wa = m ? o(m, Dt) : null, t.Y = 0, t.D.Nb = 0, t.D.wa = t.wa, t.D.Y = t.Y, 0 < t.Aa && (t.D.Y += d), e(!0), t.oc = l, t.pc = f, f += 832, t.ya = o(v, Ut), t.aa = 0, t.D.ya = t.ya, t.D.aa = t.aa, 2 == t.Aa && (t.D.aa += d), t.R = 16 * d, t.B = 8 * d, d = (p = Ri[t.L]) * t.R, p = p / 2 * t.B, t.sa = l, t.ta = f + d, t.qa = t.sa, t.ra = t.ta + 16 * s * t.R + p, t.Ha = t.qa, t.Ia = t.ra + 8 * s * t.B + p, t.$c = 0, f += u, t.mb = h ? l : null, t.nb = h ? f : null, e(f + h <= t.Fc + t.Vb), $t(t), i(t.Ac, t.Bc, 0, c), s = 1;
                        }
                    }
                    if (s) {
                        if (r.ka = 0, r.y = t.sa, r.O = t.ta, r.f = t.qa, r.N = t.ra, r.ea = t.Ha, r.Vd = t.Ia, r.fa = t.R, r.Rc = t.B, r.F = null, r.J = 0, !Cn) {
                            for(s = -255; 255 >= s; ++s)Pn[255 + s] = 0 > s ? -s : s;
                            for(s = -1020; 1020 >= s; ++s)kn[1020 + s] = -128 > s ? -128 : 127 < s ? 127 : s;
                            for(s = -112; 112 >= s; ++s)In[112 + s] = -16 > s ? -16 : 15 < s ? 15 : s;
                            for(s = -255; 510 >= s; ++s)Fn[255 + s] = 0 > s ? 0 : 255 < s ? 255 : s;
                            Cn = 1;
                        }
                        an = ue, on = ae, cn = oe, un = se, hn = ce, sn = ie, ln = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = ze, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le, fi[2] = Le, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve, li[1] = de, li[2] = pe, li[3] = ge, li[4] = be, li[5] = ye, li[6] = we, di[0] = Be, di[1] = fe, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s = 1;
                    } else s = 0;
                }
                s && (s = function(t, r) {
                    for(t.M = 0; t.M < t.Va; ++t.M){
                        var o, s = t.Jc[t.M & t.Xb], c = t.m, u = t;
                        for(o = 0; o < u.za; ++o){
                            var h = c, l = u, f = l.Ac, d = l.Bc + 4 * o, p = l.zc, g = l.ya[l.aa + o];
                            if (l.Qa.Bb ? g.$b = k(h, l.Pa.jb[0]) ? 2 + k(h, l.Pa.jb[2]) : k(h, l.Pa.jb[1]) : g.$b = 0, l.kc && (g.Ad = k(h, l.Bd)), g.Za = !k(h, 145) + 0, g.Za) {
                                var m = g.Ob, v = 0;
                                for(l = 0; 4 > l; ++l){
                                    var b, y = p[0 + l];
                                    for(b = 0; 4 > b; ++b){
                                        y = ci[f[d + b]][y];
                                        for(var w = oi[k(h, y[0])]; 0 < w;)w = oi[2 * w + k(h, y[w])];
                                        y = -w, f[d + b] = y;
                                    }
                                    n(m, v, f, d, 4), v += 4, p[0 + l] = y;
                                }
                            } else y = k(h, 156) ? k(h, 128) ? 1 : 3 : k(h, 163) ? 2 : 0, g.Ob[0] = y, i(f, d, y, 4), i(p, 0, y, 4);
                            g.Dd = k(h, 142) ? k(h, 114) ? k(h, 183) ? 1 : 3 : 2 : 0;
                        }
                        if (u.m.Ka) return Jt(t, 7, "Premature end-of-partition0 encountered.");
                        for(; t.ja < t.za; ++t.ja){
                            if (u = s, h = (c = t).rb[c.sb - 1], f = c.rb[c.sb + c.ja], o = c.ya[c.aa + c.ja], d = c.kc ? o.Ad : 0) h.la = f.la = 0, o.Za || (h.Na = f.Na = 0), o.Hc = 0, o.Gc = 0, o.ia = 0;
                            else {
                                var N, L;
                                h = f, f = u, d = c.Pa.Xc, p = c.ya[c.aa + c.ja], g = c.pb[p.$b];
                                if (l = p.ad, m = 0, v = c.rb[c.sb - 1], y = b = 0, i(l, m, 0, 384), p.Za) var A = 0, x = d[3];
                                else {
                                    w = a(16);
                                    var S = h.Na + v.Na;
                                    if (S = ni(f, d[1], S, g.Eb, 0, w, 0), h.Na = v.Na = (0 < S) + 0, 1 < S) an(w, 0, l, m);
                                    else {
                                        var _ = w[0] + 3 >> 3;
                                        for(w = 0; 256 > w; w += 16)l[m + w] = _;
                                    }
                                    A = 1, x = d[0];
                                }
                                var P = 15 & h.la, I = 15 & v.la;
                                for(w = 0; 4 > w; ++w){
                                    var F = 1 & I;
                                    for(_ = L = 0; 4 > _; ++_)P = P >> 1 | (F = (S = ni(f, x, S = F + (1 & P), g.Sc, A, l, m)) > A) << 7, L = L << 2 | (3 < S ? 3 : 1 < S ? 2 : 0 != l[m + 0]), m += 16;
                                    P >>= 4, I = I >> 1 | F << 7, b = (b << 8 | L) >>> 0;
                                }
                                for(x = P, A = I >> 4, N = 0; 4 > N; N += 2){
                                    for(L = 0, P = h.la >> 4 + N, I = v.la >> 4 + N, w = 0; 2 > w; ++w){
                                        for(F = 1 & I, _ = 0; 2 > _; ++_)S = F + (1 & P), P = P >> 1 | (F = 0 < (S = ni(f, d[2], S, g.Qc, 0, l, m))) << 3, L = L << 2 | (3 < S ? 3 : 1 < S ? 2 : 0 != l[m + 0]), m += 16;
                                        P >>= 2, I = I >> 1 | F << 5;
                                    }
                                    y |= L << 4 * N, x |= P << 4 << N, A |= (240 & I) << N;
                                }
                                h.la = x, v.la = A, p.Hc = b, p.Gc = y, p.ia = 43690 & y ? 0 : g.ia, d = !(b | y);
                            }
                            if (0 < c.L && (c.wa[c.Y + c.ja] = c.gd[o.$b][o.Za], c.wa[c.Y + c.ja].La |= !d), u.Ka) return Jt(t, 7, "Premature end-of-file encountered.");
                        }
                        if ($t(t), c = r, u = 1, o = (s = t).D, h = 0 < s.L && s.M >= s.zb && s.M <= s.Va, 0 == s.Aa) t: {
                            if (o.M = s.M, o.uc = h, Or(s, o), u = 1, o = (L = s.D).Nb, h = (y = Ri[s.L]) * s.R, f = y / 2 * s.B, w = 16 * o * s.R, _ = 8 * o * s.B, d = s.sa, p = s.ta - h + w, g = s.qa, l = s.ra - f + _, m = s.Ha, v = s.Ia - f + _, I = 0 == (P = L.M), b = P >= s.Va - 1, 2 == s.Aa && Or(s, L), L.uc) for(F = (S = s).D.M, e(S.D.uc), L = S.yb; L < S.Hb; ++L){
                                A = L, x = F;
                                var C = (j = (U = S).D).Nb;
                                N = U.R;
                                var j = j.wa[j.Y + A], O = U.sa, B = U.ta + 16 * C * N + 16 * A, M = j.dd, E = j.tc;
                                if (0 != E) {
                                    if (e(3 <= E), 1 == U.L) 0 < A && wn(O, B, N, E + 4), j.La && Ln(O, B, N, E), 0 < x && yn(O, B, N, E + 4), j.La && Nn(O, B, N, E);
                                    else {
                                        var q = U.B, D = U.qa, R = U.ra + 8 * C * q + 8 * A, T = U.Ha, U = U.Ia + 8 * C * q + 8 * A;
                                        C = j.ld;
                                        0 < A && (fn(O, B, N, E + 4, M, C), pn(D, R, T, U, q, E + 4, M, C)), j.La && (mn(O, B, N, E, M, C), bn(D, R, T, U, q, E, M, C)), 0 < x && (ln(O, B, N, E + 4, M, C), dn(D, R, T, U, q, E + 4, M, C)), j.La && (gn(O, B, N, E, M, C), vn(D, R, T, U, q, E, M, C));
                                    }
                                }
                            }
                            if (s.ia && alert("todo:DitherRow"), null != c.put) {
                                if (L = 16 * P, P = 16 * (P + 1), I ? (c.y = s.sa, c.O = s.ta + w, c.f = s.qa, c.N = s.ra + _, c.ea = s.Ha, c.W = s.Ia + _) : (L -= y, c.y = d, c.O = p, c.f = g, c.N = l, c.ea = m, c.W = v), b || (P -= y), P > c.o && (P = c.o), c.F = null, c.J = null, null != s.Fa && 0 < s.Fa.length && L < P && (c.J = lr(s, c, L, P - L), c.F = s.mb, null == c.F && 0 == c.F.length)) {
                                    u = Jt(s, 3, "Could not decode alpha data.");
                                    break t;
                                }
                                L < c.j && (y = c.j - L, L = c.j, e(!(1 & y)), c.O += s.R * y, c.N += s.B * (y >> 1), c.W += s.B * (y >> 1), null != c.F && (c.J += c.width * y)), L < P && (c.O += c.v, c.N += c.v >> 1, c.W += c.v >> 1, null != c.F && (c.J += c.v), c.ka = L - c.j, c.U = c.va - c.v, c.T = P - L, u = c.put(c));
                            }
                            o + 1 != s.Ic || b || (n(s.sa, s.ta - h, d, p + 16 * s.R, h), n(s.qa, s.ra - f, g, l + 8 * s.B, f), n(s.Ha, s.Ia - f, m, v + 8 * s.B, f));
                        }
                        if (!u) return Jt(t, 6, "Output aborted.");
                    }
                    return 1;
                }(t, r)), null != r.bc && r.bc(r), s &= 1;
            }
            return s ? (t.cb = 0, s) : 0;
        }
        function te(t, e, r, n, i) {
            i = t[e + r + 32 * n] + (i >> 3), t[e + r + 32 * n] = -256 & i ? 0 > i ? 0 : 255 : i;
        }
        function ee(t, e, r, n, i, a) {
            te(t, e, 0, r, n + i), te(t, e, 1, r, n + a), te(t, e, 2, r, n - a), te(t, e, 3, r, n - i);
        }
        function re(t) {
            return (20091 * t >> 16) + t;
        }
        function ne(t, e, r, n) {
            var i, o = 0, s = a(16);
            for(i = 0; 4 > i; ++i){
                var c = t[e + 0] + t[e + 8], u = t[e + 0] - t[e + 8], h = (35468 * t[e + 4] >> 16) - re(t[e + 12]), l = re(t[e + 4]) + (35468 * t[e + 12] >> 16);
                s[o + 0] = c + l, s[o + 1] = u + h, s[o + 2] = u - h, s[o + 3] = c - l, o += 4, e++;
            }
            for(i = o = 0; 4 > i; ++i)c = (t = s[o + 0] + 4) + s[o + 8], u = t - s[o + 8], h = (35468 * s[o + 4] >> 16) - re(s[o + 12]), te(r, n, 0, 0, c + (l = re(s[o + 4]) + (35468 * s[o + 12] >> 16))), te(r, n, 1, 0, u + h), te(r, n, 2, 0, u - h), te(r, n, 3, 0, c - l), o++, n += 32;
        }
        function ie(t, e, r, n) {
            var i = t[e + 0] + 4, a = 35468 * t[e + 4] >> 16, o = re(t[e + 4]), s = 35468 * t[e + 1] >> 16;
            ee(r, n, 0, i + o, t = re(t[e + 1]), s), ee(r, n, 1, i + a, t, s), ee(r, n, 2, i - a, t, s), ee(r, n, 3, i - o, t, s);
        }
        function ae(t, e, r, n, i) {
            ne(t, e, r, n), i && ne(t, e + 16, r, n + 4);
        }
        function oe(t, e, r, n) {
            on(t, e + 0, r, n, 1), on(t, e + 32, r, n + 128, 1);
        }
        function se(t, e, r, n) {
            var i;
            for(t = t[e + 0] + 4, i = 0; 4 > i; ++i)for(e = 0; 4 > e; ++e)te(r, n, e, i, t);
        }
        function ce(t, e, r, n) {
            t[e + 0] && un(t, e + 0, r, n), t[e + 16] && un(t, e + 16, r, n + 4), t[e + 32] && un(t, e + 32, r, n + 128), t[e + 48] && un(t, e + 48, r, n + 128 + 4);
        }
        function ue(t, e, r, n) {
            var i, o = a(16);
            for(i = 0; 4 > i; ++i){
                var s = t[e + 0 + i] + t[e + 12 + i], c = t[e + 4 + i] + t[e + 8 + i], u = t[e + 4 + i] - t[e + 8 + i], h = t[e + 0 + i] - t[e + 12 + i];
                o[0 + i] = s + c, o[8 + i] = s - c, o[4 + i] = h + u, o[12 + i] = h - u;
            }
            for(i = 0; 4 > i; ++i)s = (t = o[0 + 4 * i] + 3) + o[3 + 4 * i], c = o[1 + 4 * i] + o[2 + 4 * i], u = o[1 + 4 * i] - o[2 + 4 * i], h = t - o[3 + 4 * i], r[n + 0] = s + c >> 3, r[n + 16] = h + u >> 3, r[n + 32] = s - c >> 3, r[n + 48] = h - u >> 3, n += 64;
        }
        function he(t, e, r) {
            var n, i = e - 32, a = Bn, o = 255 - t[i - 1];
            for(n = 0; n < r; ++n){
                var s, c = a, u = o + t[e - 1];
                for(s = 0; s < r; ++s)t[e + s] = c[u + t[i + s]];
                e += 32;
            }
        }
        function le(t, e) {
            he(t, e, 4);
        }
        function fe(t, e) {
            he(t, e, 8);
        }
        function de(t, e) {
            he(t, e, 16);
        }
        function pe(t, e) {
            var r;
            for(r = 0; 16 > r; ++r)n(t, e + 32 * r, t, e - 32, 16);
        }
        function ge(t, e) {
            var r;
            for(r = 16; 0 < r; --r)i(t, e, t[e - 1], 16), e += 32;
        }
        function me(t, e, r) {
            var n;
            for(n = 0; 16 > n; ++n)i(e, r + 32 * n, t, 16);
        }
        function ve(t, e) {
            var r, n = 16;
            for(r = 0; 16 > r; ++r)n += t[e - 1 + 32 * r] + t[e + r - 32];
            me(n >> 5, t, e);
        }
        function be(t, e) {
            var r, n = 8;
            for(r = 0; 16 > r; ++r)n += t[e - 1 + 32 * r];
            me(n >> 4, t, e);
        }
        function ye(t, e) {
            var r, n = 8;
            for(r = 0; 16 > r; ++r)n += t[e + r - 32];
            me(n >> 4, t, e);
        }
        function we(t, e) {
            me(128, t, e);
        }
        function Ne(t, e, r) {
            return t + 2 * e + r + 2 >> 2;
        }
        function Le(t, e) {
            var r, i = e - 32;
            i = new Uint8Array([
                Ne(t[i - 1], t[i + 0], t[i + 1]),
                Ne(t[i + 0], t[i + 1], t[i + 2]),
                Ne(t[i + 1], t[i + 2], t[i + 3]),
                Ne(t[i + 2], t[i + 3], t[i + 4])
            ]);
            for(r = 0; 4 > r; ++r)n(t, e + 32 * r, i, 0, i.length);
        }
        function Ae(t, e) {
            var r = t[e - 1], n = t[e - 1 + 32], i = t[e - 1 + 64], a = t[e - 1 + 96];
            I(t, e + 0, 16843009 * Ne(t[e - 1 - 32], r, n)), I(t, e + 32, 16843009 * Ne(r, n, i)), I(t, e + 64, 16843009 * Ne(n, i, a)), I(t, e + 96, 16843009 * Ne(i, a, a));
        }
        function xe(t, e) {
            var r, n = 4;
            for(r = 0; 4 > r; ++r)n += t[e + r - 32] + t[e - 1 + 32 * r];
            for(n >>= 3, r = 0; 4 > r; ++r)i(t, e + 32 * r, n, 4);
        }
        function Se(t, e) {
            var r = t[e - 1 + 0], n = t[e - 1 + 32], i = t[e - 1 + 64], a = t[e - 1 - 32], o = t[e + 0 - 32], s = t[e + 1 - 32], c = t[e + 2 - 32], u = t[e + 3 - 32];
            t[e + 0 + 96] = Ne(n, i, t[e - 1 + 96]), t[e + 1 + 96] = t[e + 0 + 64] = Ne(r, n, i), t[e + 2 + 96] = t[e + 1 + 64] = t[e + 0 + 32] = Ne(a, r, n), t[e + 3 + 96] = t[e + 2 + 64] = t[e + 1 + 32] = t[e + 0 + 0] = Ne(o, a, r), t[e + 3 + 64] = t[e + 2 + 32] = t[e + 1 + 0] = Ne(s, o, a), t[e + 3 + 32] = t[e + 2 + 0] = Ne(c, s, o), t[e + 3 + 0] = Ne(u, c, s);
        }
        function _e(t, e) {
            var r = t[e + 1 - 32], n = t[e + 2 - 32], i = t[e + 3 - 32], a = t[e + 4 - 32], o = t[e + 5 - 32], s = t[e + 6 - 32], c = t[e + 7 - 32];
            t[e + 0 + 0] = Ne(t[e + 0 - 32], r, n), t[e + 1 + 0] = t[e + 0 + 32] = Ne(r, n, i), t[e + 2 + 0] = t[e + 1 + 32] = t[e + 0 + 64] = Ne(n, i, a), t[e + 3 + 0] = t[e + 2 + 32] = t[e + 1 + 64] = t[e + 0 + 96] = Ne(i, a, o), t[e + 3 + 32] = t[e + 2 + 64] = t[e + 1 + 96] = Ne(a, o, s), t[e + 3 + 64] = t[e + 2 + 96] = Ne(o, s, c), t[e + 3 + 96] = Ne(s, c, c);
        }
        function Pe(t, e) {
            var r = t[e - 1 + 0], n = t[e - 1 + 32], i = t[e - 1 + 64], a = t[e - 1 - 32], o = t[e + 0 - 32], s = t[e + 1 - 32], c = t[e + 2 - 32], u = t[e + 3 - 32];
            t[e + 0 + 0] = t[e + 1 + 64] = a + o + 1 >> 1, t[e + 1 + 0] = t[e + 2 + 64] = o + s + 1 >> 1, t[e + 2 + 0] = t[e + 3 + 64] = s + c + 1 >> 1, t[e + 3 + 0] = c + u + 1 >> 1, t[e + 0 + 96] = Ne(i, n, r), t[e + 0 + 64] = Ne(n, r, a), t[e + 0 + 32] = t[e + 1 + 96] = Ne(r, a, o), t[e + 1 + 32] = t[e + 2 + 96] = Ne(a, o, s), t[e + 2 + 32] = t[e + 3 + 96] = Ne(o, s, c), t[e + 3 + 32] = Ne(s, c, u);
        }
        function ke(t, e) {
            var r = t[e + 0 - 32], n = t[e + 1 - 32], i = t[e + 2 - 32], a = t[e + 3 - 32], o = t[e + 4 - 32], s = t[e + 5 - 32], c = t[e + 6 - 32], u = t[e + 7 - 32];
            t[e + 0 + 0] = r + n + 1 >> 1, t[e + 1 + 0] = t[e + 0 + 64] = n + i + 1 >> 1, t[e + 2 + 0] = t[e + 1 + 64] = i + a + 1 >> 1, t[e + 3 + 0] = t[e + 2 + 64] = a + o + 1 >> 1, t[e + 0 + 32] = Ne(r, n, i), t[e + 1 + 32] = t[e + 0 + 96] = Ne(n, i, a), t[e + 2 + 32] = t[e + 1 + 96] = Ne(i, a, o), t[e + 3 + 32] = t[e + 2 + 96] = Ne(a, o, s), t[e + 3 + 64] = Ne(o, s, c), t[e + 3 + 96] = Ne(s, c, u);
        }
        function Ie(t, e) {
            var r = t[e - 1 + 0], n = t[e - 1 + 32], i = t[e - 1 + 64], a = t[e - 1 + 96];
            t[e + 0 + 0] = r + n + 1 >> 1, t[e + 2 + 0] = t[e + 0 + 32] = n + i + 1 >> 1, t[e + 2 + 32] = t[e + 0 + 64] = i + a + 1 >> 1, t[e + 1 + 0] = Ne(r, n, i), t[e + 3 + 0] = t[e + 1 + 32] = Ne(n, i, a), t[e + 3 + 32] = t[e + 1 + 64] = Ne(i, a, a), t[e + 3 + 64] = t[e + 2 + 64] = t[e + 0 + 96] = t[e + 1 + 96] = t[e + 2 + 96] = t[e + 3 + 96] = a;
        }
        function Fe(t, e) {
            var r = t[e - 1 + 0], n = t[e - 1 + 32], i = t[e - 1 + 64], a = t[e - 1 + 96], o = t[e - 1 - 32], s = t[e + 0 - 32], c = t[e + 1 - 32], u = t[e + 2 - 32];
            t[e + 0 + 0] = t[e + 2 + 32] = r + o + 1 >> 1, t[e + 0 + 32] = t[e + 2 + 64] = n + r + 1 >> 1, t[e + 0 + 64] = t[e + 2 + 96] = i + n + 1 >> 1, t[e + 0 + 96] = a + i + 1 >> 1, t[e + 3 + 0] = Ne(s, c, u), t[e + 2 + 0] = Ne(o, s, c), t[e + 1 + 0] = t[e + 3 + 32] = Ne(r, o, s), t[e + 1 + 32] = t[e + 3 + 64] = Ne(n, r, o), t[e + 1 + 64] = t[e + 3 + 96] = Ne(i, n, r), t[e + 1 + 96] = Ne(a, i, n);
        }
        function Ce(t, e) {
            var r;
            for(r = 0; 8 > r; ++r)n(t, e + 32 * r, t, e - 32, 8);
        }
        function je(t, e) {
            var r;
            for(r = 0; 8 > r; ++r)i(t, e, t[e - 1], 8), e += 32;
        }
        function Oe(t, e, r) {
            var n;
            for(n = 0; 8 > n; ++n)i(e, r + 32 * n, t, 8);
        }
        function Be(t, e) {
            var r, n = 8;
            for(r = 0; 8 > r; ++r)n += t[e + r - 32] + t[e - 1 + 32 * r];
            Oe(n >> 4, t, e);
        }
        function Me(t, e) {
            var r, n = 4;
            for(r = 0; 8 > r; ++r)n += t[e + r - 32];
            Oe(n >> 3, t, e);
        }
        function Ee(t, e) {
            var r, n = 4;
            for(r = 0; 8 > r; ++r)n += t[e - 1 + 32 * r];
            Oe(n >> 3, t, e);
        }
        function qe(t, e) {
            Oe(128, t, e);
        }
        function De(t, e, r) {
            var n = t[e - r], i = t[e + 0], a = 3 * (i - n) + jn[1020 + t[e - 2 * r] - t[e + r]], o = On[112 + (a + 4 >> 3)];
            t[e - r] = Bn[255 + n + On[112 + (a + 3 >> 3)]], t[e + 0] = Bn[255 + i - o];
        }
        function Re(t, e, r, n) {
            var i = t[e + 0], a = t[e + r];
            return Mn[255 + t[e - 2 * r] - t[e - r]] > n || Mn[255 + a - i] > n;
        }
        function Te(t, e, r, n) {
            return 4 * Mn[255 + t[e - r] - t[e + 0]] + Mn[255 + t[e - 2 * r] - t[e + r]] <= n;
        }
        function Ue(t, e, r, n, i) {
            var a = t[e - 3 * r], o = t[e - 2 * r], s = t[e - r], c = t[e + 0], u = t[e + r], h = t[e + 2 * r], l = t[e + 3 * r];
            return 4 * Mn[255 + s - c] + Mn[255 + o - u] > n ? 0 : Mn[255 + t[e - 4 * r] - a] <= i && Mn[255 + a - o] <= i && Mn[255 + o - s] <= i && Mn[255 + l - h] <= i && Mn[255 + h - u] <= i && Mn[255 + u - c] <= i;
        }
        function ze(t, e, r, n) {
            var i = 2 * n + 1;
            for(n = 0; 16 > n; ++n)Te(t, e + n, r, i) && De(t, e + n, r);
        }
        function He(t, e, r, n) {
            var i = 2 * n + 1;
            for(n = 0; 16 > n; ++n)Te(t, e + n * r, 1, i) && De(t, e + n * r, 1);
        }
        function We(t, e, r, n) {
            var i;
            for(i = 3; 0 < i; --i)ze(t, e += 4 * r, r, n);
        }
        function Ve(t, e, r, n) {
            var i;
            for(i = 3; 0 < i; --i)He(t, e += 4, r, n);
        }
        function Ge(t, e, r, n, i, a, o, s) {
            for(a = 2 * a + 1; 0 < i--;){
                if (Ue(t, e, r, a, o)) {
                    if (Re(t, e, r, s)) De(t, e, r);
                    else {
                        var c = t, u = e, h = r, l = c[u - 2 * h], f = c[u - h], d = c[u + 0], p = c[u + h], g = c[u + 2 * h], m = 27 * (b = jn[1020 + 3 * (d - f) + jn[1020 + l - p]]) + 63 >> 7, v = 18 * b + 63 >> 7, b = 9 * b + 63 >> 7;
                        c[u - 3 * h] = Bn[255 + c[u - 3 * h] + b], c[u - 2 * h] = Bn[255 + l + v], c[u - h] = Bn[255 + f + m], c[u + 0] = Bn[255 + d - m], c[u + h] = Bn[255 + p - v], c[u + 2 * h] = Bn[255 + g - b];
                    }
                }
                e += n;
            }
        }
        function Ye(t, e, r, n, i, a, o, s) {
            for(a = 2 * a + 1; 0 < i--;){
                if (Ue(t, e, r, a, o)) {
                    if (Re(t, e, r, s)) De(t, e, r);
                    else {
                        var c = t, u = e, h = r, l = c[u - h], f = c[u + 0], d = c[u + h], p = On[112 + ((g = 3 * (f - l)) + 4 >> 3)], g = On[112 + (g + 3 >> 3)], m = p + 1 >> 1;
                        c[u - 2 * h] = Bn[255 + c[u - 2 * h] + m], c[u - h] = Bn[255 + l + g], c[u + 0] = Bn[255 + f - p], c[u + h] = Bn[255 + d - m];
                    }
                }
                e += n;
            }
        }
        function Je(t, e, r, n, i, a) {
            Ge(t, e, r, 1, 16, n, i, a);
        }
        function Xe(t, e, r, n, i, a) {
            Ge(t, e, 1, r, 16, n, i, a);
        }
        function Ke(t, e, r, n, i, a) {
            var o;
            for(o = 3; 0 < o; --o)Ye(t, e += 4 * r, r, 1, 16, n, i, a);
        }
        function Ze(t, e, r, n, i, a) {
            var o;
            for(o = 3; 0 < o; --o)Ye(t, e += 4, 1, r, 16, n, i, a);
        }
        function $e(t, e, r, n, i, a, o, s) {
            Ge(t, e, i, 1, 8, a, o, s), Ge(r, n, i, 1, 8, a, o, s);
        }
        function Qe(t, e, r, n, i, a, o, s) {
            Ge(t, e, 1, i, 8, a, o, s), Ge(r, n, 1, i, 8, a, o, s);
        }
        function tr(t, e, r, n, i, a, o, s) {
            Ye(t, e + 4 * i, i, 1, 8, a, o, s), Ye(r, n + 4 * i, i, 1, 8, a, o, s);
        }
        function er(t, e, r, n, i, a, o, s) {
            Ye(t, e + 4, 1, i, 8, a, o, s), Ye(r, n + 4, 1, i, 8, a, o, s);
        }
        function rr() {
            this.ba = new ot, this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct, this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
        }
        function nr() {
            this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
        }
        function ir() {
            this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
        }
        function ar() {
            this.ua = 0, this.Wa = new M, this.vb = new M, this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d, this.yc = new l;
        }
        function or() {
            this.xb = this.a = 0, this.l = new Gt, this.ca = new ot, this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N, this.Pb = 0, this.wd = new N, this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar, this.ab = 0, this.gc = o(4, ir), this.Oc = 0;
        }
        function sr() {
            this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt, this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
        }
        function cr(t, e, r, n, i, a, o) {
            for(t = null == t ? 0 : t[e + 0], e = 0; e < o; ++e)i[a + e] = t + r[n + e] & 255, t = i[a + e];
        }
        function ur(t, e, r, n, i, a, o) {
            var s;
            if (null == t) cr(null, null, r, n, i, a, o);
            else for(s = 0; s < o; ++s)i[a + s] = t[e + s] + r[n + s] & 255;
        }
        function hr(t, e, r, n, i, a, o) {
            if (null == t) cr(null, null, r, n, i, a, o);
            else {
                var s, c = t[e + 0], u = c, h = c;
                for(s = 0; s < o; ++s)u = h + (c = t[e + s]) - u, h = r[n + s] + (-256 & u ? 0 > u ? 0 : 255 : u) & 255, u = c, i[a + s] = h;
            }
        }
        function lr(t, r, i, o) {
            var s = r.width, c = r.o;
            if (e(null != t && null != r), 0 > i || 0 >= o || i + o > c) return null;
            if (!t.Cc) {
                if (null == t.ga) {
                    var u;
                    if (t.ga = new sr, (u = null == t.ga) || (u = r.width * r.o, e(0 == t.Gb.length), t.Gb = a(u), t.Uc = 0, null == t.Gb ? u = 0 : (t.mb = t.Gb, t.nb = t.Uc, t.rc = null, u = 1), u = !u), !u) {
                        u = t.ga;
                        var h = t.Fa, l = t.P, f = t.qc, d = t.mb, p = t.nb, g = l + 1, m = f - 1, b = u.l;
                        if (e(null != h && null != d && null != r), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u.ca = d, u.tb = p, u.c = r.width, u.i = r.height, e(0 < u.c && 0 < u.i), 1 >= f) r = 0;
                        else if (u.$a = h[l + 0] >> 0 & 3, u.Z = h[l + 0] >> 2 & 3, u.Lc = h[l + 0] >> 4 & 3, l = h[l + 0] >> 6 & 3, 0 > u.$a || 1 < u.$a || 4 <= u.Z || 1 < u.Lc || l) r = 0;
                        else if (b.put = dt, b.ac = ft, b.bc = pt, b.ma = u, b.width = r.width, b.height = r.height, b.Da = r.Da, b.v = r.v, b.va = r.va, b.j = r.j, b.o = r.o, u.$a) t: {
                            e(1 == u.$a), r = kt();
                            e: for(;;){
                                if (null == r) {
                                    r = 0;
                                    break t;
                                }
                                if (e(null != u), u.mc = r, r.c = u.c, r.i = u.i, r.l = u.l, r.l.ma = u, r.l.width = u.c, r.l.height = u.i, r.a = 0, v(r.m, h, g, m), !It(u.c, u.i, 1, r, null)) break e;
                                if (1 == r.ab && 3 == r.gc[0].hc && At(r.s) ? (u.ic = 1, h = r.c * r.i, r.Ta = null, r.Ua = 0, r.V = a(h), r.Ba = 0, null == r.V ? (r.a = 1, r = 0) : r = 1) : (u.ic = 0, r = Ft(r, u.c)), !r) break e;
                                r = 1;
                                break t;
                            }
                            u.mc = null, r = 0;
                        }
                        else r = m >= u.c * u.i;
                        u = !r;
                    }
                    if (u) return null;
                    1 != t.ga.Lc ? t.Ga = 0 : o = c - i;
                }
                e(null != t.ga), e(i + o <= c);
                t: {
                    if (r = (h = t.ga).c, c = h.l.o, 0 == h.$a) {
                        if (g = t.rc, m = t.Vc, b = t.Fa, l = t.P + 1 + i * r, f = t.mb, d = t.nb + i * r, e(l <= t.P + t.qc), 0 != h.Z) for(e(null != mi[h.Z]), u = 0; u < o; ++u)mi[h.Z](g, m, b, l, f, d, r), g = f, m = d, d += r, l += r;
                        else for(u = 0; u < o; ++u)n(f, d, b, l, r), g = f, m = d, d += r, l += r;
                        t.rc = g, t.Vc = m;
                    } else {
                        if (e(null != h.mc), r = i + o, e(null != (u = h.mc)), e(r <= u.i), u.C >= r) r = 1;
                        else if (h.ic || mr(), h.ic) {
                            h = u.V, g = u.Ba, m = u.c;
                            var y = u.i, w = (b = 1, l = u.$ / m, f = u.$ % m, d = u.m, p = u.s, u.$), N = m * y, L = m * r, x = p.wc, _ = w < L ? wt(p, f, l) : null;
                            e(w <= N), e(r <= y), e(At(p));
                            e: for(;;){
                                for(; !d.h && w < L;){
                                    if (f & x || (_ = wt(p, f, l)), e(null != _), S(d), 256 > (y = bt(_.G[0], _.H[0], d))) h[g + w] = y, ++w, ++f >= m && (f = 0, ++l <= r && !(l % 16) && St(u, l));
                                    else {
                                        if (!(280 > y)) {
                                            b = 0;
                                            break e;
                                        }
                                        y = mt(y - 256, d);
                                        var P, k = bt(_.G[4], _.H[4], d);
                                        if (S(d), !(w >= (k = vt(m, k = mt(k, d))) && N - w >= y)) {
                                            b = 0;
                                            break e;
                                        }
                                        for(P = 0; P < y; ++P)h[g + w + P] = h[g + w + P - k];
                                        for(w += y, f += y; f >= m;)f -= m, ++l <= r && !(l % 16) && St(u, l);
                                        w < L && f & x && (_ = wt(p, f, l));
                                    }
                                    e(d.h == A(d));
                                }
                                St(u, l > r ? r : l);
                                break e;
                            }
                            !b || d.h && w < N ? (b = 0, u.a = d.h ? 5 : 3) : u.$ = w, r = b;
                        } else r = _t(u, u.V, u.Ba, u.c, u.i, r, Ct);
                        if (!r) {
                            o = 0;
                            break t;
                        }
                    }
                    i + o >= c && (t.Cc = 1), o = 1;
                }
                if (!o) return null;
                if (t.Cc && (null != (o = t.ga) && (o.mc = null), t.ga = null, 0 < t.Ga)) return alert("todo:WebPDequantizeLevels"), null;
            }
            return t.nb + i * s;
        }
        function fr(t, e, r, n, i, a) {
            for(; 0 < i--;){
                var o, s = t, c = e + (r ? 1 : 0), u = t, h = e + (r ? 0 : 3);
                for(o = 0; o < n; ++o){
                    var l = u[h + 4 * o];
                    255 != l && (l *= 32897, s[c + 4 * o + 0] = s[c + 4 * o + 0] * l >> 23, s[c + 4 * o + 1] = s[c + 4 * o + 1] * l >> 23, s[c + 4 * o + 2] = s[c + 4 * o + 2] * l >> 23);
                }
                e += a;
            }
        }
        function dr(t, e, r, n, i) {
            for(; 0 < n--;){
                var a;
                for(a = 0; a < r; ++a){
                    var o = t[e + 2 * a + 0], s = 15 & (u = t[e + 2 * a + 1]), c = 4369 * s, u = (240 & u | u >> 4) * c >> 16;
                    t[e + 2 * a + 0] = (240 & o | o >> 4) * c >> 16 & 240 | (15 & o | o << 4) * c >> 16 >> 4 & 15, t[e + 2 * a + 1] = 240 & u | s;
                }
                e += i;
            }
        }
        function pr(t, e, r, n, i, a, o, s) {
            var c, u, h = 255;
            for(u = 0; u < i; ++u){
                for(c = 0; c < n; ++c){
                    var l = t[e + c];
                    a[o + 4 * c] = l, h &= l;
                }
                e += r, o += s;
            }
            return 255 != h;
        }
        function gr(t, e, r, n, i) {
            var a;
            for(a = 0; a < i; ++a)r[n + a] = t[e + a] >> 8;
        }
        function mr() {
            An = fr, xn = dr, Sn = pr, _n = gr;
        }
        function vr(r, n, i) {
            t[r] = function(t, r, a, o, s, c, u, h, l, f, d, p, g, m, v, b, y) {
                var w, N = y - 1 >> 1, L = s[c + 0] | u[h + 0] << 16, A = l[f + 0] | d[p + 0] << 16;
                e(null != t);
                var x = 3 * L + A + 131074 >> 2;
                for(n(t[r + 0], 255 & x, x >> 16, g, m), null != a && (x = 3 * A + L + 131074 >> 2, n(a[o + 0], 255 & x, x >> 16, v, b)), w = 1; w <= N; ++w){
                    var S = s[c + w] | u[h + w] << 16, _ = l[f + w] | d[p + w] << 16, P = L + S + A + _ + 524296, k = P + 2 * (S + A) >> 3;
                    x = k + L >> 1, L = (P = P + 2 * (L + _) >> 3) + S >> 1, n(t[r + 2 * w - 1], 255 & x, x >> 16, g, m + (2 * w - 1) * i), n(t[r + 2 * w - 0], 255 & L, L >> 16, g, m + (2 * w - 0) * i), null != a && (x = P + A >> 1, L = k + _ >> 1, n(a[o + 2 * w - 1], 255 & x, x >> 16, v, b + (2 * w - 1) * i), n(a[o + 2 * w + 0], 255 & L, L >> 16, v, b + (2 * w + 0) * i)), L = S, A = _;
                }
                1 & y || (x = 3 * L + A + 131074 >> 2, n(t[r + y - 1], 255 & x, x >> 16, g, m + (y - 1) * i), null != a && (x = 3 * A + L + 131074 >> 2, n(a[o + y - 1], 255 & x, x >> 16, v, b + (y - 1) * i)));
            };
        }
        function br() {
            vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[Un] = Ai, vi[zn] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
        }
        function yr(t) {
            return t & ~Fi ? 0 > t ? 0 : 255 : t >> Ii;
        }
        function wr(t, e) {
            return yr((19077 * t >> 8) + (26149 * e >> 8) - 14234);
        }
        function Nr(t, e, r) {
            return yr((19077 * t >> 8) - (6419 * e >> 8) - (13320 * r >> 8) + 8708);
        }
        function Lr(t, e) {
            return yr((19077 * t >> 8) + (33050 * e >> 8) - 17685);
        }
        function Ar(t, e, r, n, i) {
            n[i + 0] = wr(t, r), n[i + 1] = Nr(t, e, r), n[i + 2] = Lr(t, e);
        }
        function xr(t, e, r, n, i) {
            n[i + 0] = Lr(t, e), n[i + 1] = Nr(t, e, r), n[i + 2] = wr(t, r);
        }
        function Sr(t, e, r, n, i) {
            var a = Nr(t, e, r);
            e = a << 3 & 224 | Lr(t, e) >> 3, n[i + 0] = 248 & wr(t, r) | a >> 5, n[i + 1] = e;
        }
        function _r(t, e, r, n, i) {
            var a = 240 & Lr(t, e) | 15;
            n[i + 0] = 240 & wr(t, r) | Nr(t, e, r) >> 4, n[i + 1] = a;
        }
        function Pr(t, e, r, n, i) {
            n[i + 0] = 255, Ar(t, e, r, n, i + 1);
        }
        function kr(t, e, r, n, i) {
            xr(t, e, r, n, i), n[i + 3] = 255;
        }
        function Ir(t, e, r, n, i) {
            Ar(t, e, r, n, i), n[i + 3] = 255;
        }
        function Vt(t, e) {
            return 0 > t ? 0 : t > e ? e : t;
        }
        function Fr(e, r, n) {
            t[e] = function(t, e, i, a, o, s, c, u, h) {
                for(var l = u + (-2 & h) * n; u != l;)r(t[e + 0], i[a + 0], o[s + 0], c, u), r(t[e + 1], i[a + 0], o[s + 0], c, u + n), e += 2, ++a, ++s, u += 2 * n;
                1 & h && r(t[e + 0], i[a + 0], o[s + 0], c, u);
            };
        }
        function Cr(t, e, r) {
            return 0 == r ? 0 == t ? 0 == e ? 6 : 5 : 0 == e ? 4 : 0 : r;
        }
        function jr(t, e, r, n, i) {
            switch(t >>> 30){
                case 3:
                    on(e, r, n, i, 0);
                    break;
                case 2:
                    sn(e, r, n, i);
                    break;
                case 1:
                    un(e, r, n, i);
            }
        }
        function Or(t, e) {
            var r, a, o = e.M, s = e.Nb, c = t.oc, u = t.pc + 40, h = t.oc, l = t.pc + 584, f = t.oc, d = t.pc + 600;
            for(r = 0; 16 > r; ++r)c[u + 32 * r - 1] = 129;
            for(r = 0; 8 > r; ++r)h[l + 32 * r - 1] = 129, f[d + 32 * r - 1] = 129;
            for(0 < o ? c[u - 1 - 32] = h[l - 1 - 32] = f[d - 1 - 32] = 129 : (i(c, u - 32 - 1, 127, 21), i(h, l - 32 - 1, 127, 9), i(f, d - 32 - 1, 127, 9)), a = 0; a < t.za; ++a){
                var p = e.ya[e.aa + a];
                if (0 < a) {
                    for(r = -1; 16 > r; ++r)n(c, u + 32 * r - 4, c, u + 32 * r + 12, 4);
                    for(r = -1; 8 > r; ++r)n(h, l + 32 * r - 4, h, l + 32 * r + 4, 4), n(f, d + 32 * r - 4, f, d + 32 * r + 4, 4);
                }
                var g = t.Gd, m = t.Hd + a, v = p.ad, b = p.Hc;
                if (0 < o && (n(c, u - 32, g[m].y, 0, 16), n(h, l - 32, g[m].f, 0, 8), n(f, d - 32, g[m].ea, 0, 8)), p.Za) {
                    var y = c, w = u - 32 + 16;
                    for(0 < o && (a >= t.za - 1 ? i(y, w, g[m].y[15], 4) : n(y, w, g[m + 1].y, 0, 4)), r = 0; 4 > r; r++)y[w + 128 + r] = y[w + 256 + r] = y[w + 384 + r] = y[w + 0 + r];
                    for(r = 0; 16 > r; ++r, b <<= 2)y = c, w = u + Di[r], fi[p.Ob[r]](y, w), jr(b, v, 16 * +r, y, w);
                } else if (y = Cr(a, o, p.Ob[0]), li[y](c, u), 0 != b) for(r = 0; 16 > r; ++r, b <<= 2)jr(b, v, 16 * +r, c, u + Di[r]);
                for(r = p.Gc, y = Cr(a, o, p.Dd), di[y](h, l), di[y](f, d), b = v, y = h, w = l, 255 & (p = r >> 0) && (170 & p ? cn(b, 256, y, w) : hn(b, 256, y, w)), p = f, b = d, 255 & (r >>= 8) && (170 & r ? cn(v, 320, p, b) : hn(v, 320, p, b)), o < t.Ub - 1 && (n(g[m].y, 0, c, u + 480, 16), n(g[m].f, 0, h, l + 224, 8), n(g[m].ea, 0, f, d + 224, 8)), r = 8 * s * t.B, g = t.sa, m = t.ta + 16 * a + 16 * s * t.R, v = t.qa, p = t.ra + 8 * a + r, b = t.Ha, y = t.Ia + 8 * a + r, r = 0; 16 > r; ++r)n(g, m + r * t.R, c, u + 32 * r, 16);
                for(r = 0; 8 > r; ++r)n(v, p + r * t.B, h, l + 32 * r, 8), n(b, y + r * t.B, f, d + 32 * r, 8);
            }
        }
        function Br(t, n, i, a, o, s, c, u, h) {
            var l = [
                0
            ], f = [
                0
            ], d = 0, p = null != h ? h.kd : 0, g = null != h ? h : new nr;
            if (null == t || 12 > i) return 7;
            g.data = t, g.w = n, g.ha = i, n = [
                n
            ], i = [
                i
            ], g.gb = [
                g.gb
            ];
            t: {
                var m = n, b = i, y = g.gb;
                if (e(null != t), e(null != b), e(null != y), y[0] = 0, 12 <= b[0] && !r(t, m[0], "RIFF")) {
                    if (r(t, m[0] + 8, "WEBP")) {
                        y = 3;
                        break t;
                    }
                    var w = j(t, m[0] + 4);
                    if (12 > w || 4294967286 < w) {
                        y = 3;
                        break t;
                    }
                    if (p && w > b[0] - 8) {
                        y = 7;
                        break t;
                    }
                    y[0] = w, m[0] += 12, b[0] -= 12;
                }
                y = 0;
            }
            if (0 != y) return y;
            for(w = 0 < g.gb[0], i = i[0];;){
                t: {
                    var L = t;
                    b = n, y = i;
                    var A = l, x = f, S = m = [
                        0
                    ];
                    if ((k = d = [
                        d
                    ])[0] = 0, 8 > y[0]) y = 7;
                    else {
                        if (!r(L, b[0], "VP8X")) {
                            if (10 != j(L, b[0] + 4)) {
                                y = 3;
                                break t;
                            }
                            if (18 > y[0]) {
                                y = 7;
                                break t;
                            }
                            var _ = j(L, b[0] + 8), P = 1 + C(L, b[0] + 12);
                            if (2147483648 <= P * (L = 1 + C(L, b[0] + 15))) {
                                y = 3;
                                break t;
                            }
                            null != S && (S[0] = _), null != A && (A[0] = P), null != x && (x[0] = L), b[0] += 18, y[0] -= 18, k[0] = 1;
                        }
                        y = 0;
                    }
                }
                if (d = d[0], m = m[0], 0 != y) return y;
                if (b = !!(2 & m), !w && d) return 3;
                if (null != s && (s[0] = !!(16 & m)), null != c && (c[0] = b), null != u && (u[0] = 0), c = l[0], m = f[0], d && b && null == h) {
                    y = 0;
                    break;
                }
                if (4 > i) {
                    y = 7;
                    break;
                }
                if (w && d || !w && !d && !r(t, n[0], "ALPH")) {
                    i = [
                        i
                    ], g.na = [
                        g.na
                    ], g.P = [
                        g.P
                    ], g.Sa = [
                        g.Sa
                    ];
                    t: {
                        _ = t, y = n, w = i;
                        var k = g.gb;
                        A = g.na, x = g.P, S = g.Sa;
                        P = 22, e(null != _), e(null != w), L = y[0];
                        var I = w[0];
                        for(e(null != A), e(null != S), A[0] = null, x[0] = null, S[0] = 0;;){
                            if (y[0] = L, w[0] = I, 8 > I) {
                                y = 7;
                                break t;
                            }
                            var F = j(_, L + 4);
                            if (4294967286 < F) {
                                y = 3;
                                break t;
                            }
                            var O = 8 + F + 1 & -2;
                            if (P += O, 0 < k && P > k) {
                                y = 3;
                                break t;
                            }
                            if (!r(_, L, "VP8 ") || !r(_, L, "VP8L")) {
                                y = 0;
                                break t;
                            }
                            if (I[0] < O) {
                                y = 7;
                                break t;
                            }
                            r(_, L, "ALPH") || (A[0] = _, x[0] = L + 8, S[0] = F), L += O, I -= O;
                        }
                    }
                    if (i = i[0], g.na = g.na[0], g.P = g.P[0], g.Sa = g.Sa[0], 0 != y) break;
                }
                i = [
                    i
                ], g.Ja = [
                    g.Ja
                ], g.xa = [
                    g.xa
                ];
                t: if (k = t, y = n, w = i, A = g.gb[0], x = g.Ja, S = g.xa, _ = y[0], L = !r(k, _, "VP8 "), P = !r(k, _, "VP8L"), e(null != k), e(null != w), e(null != x), e(null != S), 8 > w[0]) y = 7;
                else {
                    if (L || P) {
                        if (k = j(k, _ + 4), 12 <= A && k > A - 12) {
                            y = 3;
                            break t;
                        }
                        if (p && k > w[0] - 8) {
                            y = 7;
                            break t;
                        }
                        x[0] = k, y[0] += 8, w[0] -= 8, S[0] = P;
                    } else S[0] = 5 <= w[0] && 47 == k[_ + 0] && !(k[_ + 4] >> 5), x[0] = w[0];
                    y = 0;
                }
                if (i = i[0], g.Ja = g.Ja[0], g.xa = g.xa[0], n = n[0], 0 != y) break;
                if (4294967286 < g.Ja) return 3;
                if (null == u || b || (u[0] = g.xa ? 2 : 1), c = [
                    c
                ], m = [
                    m
                ], g.xa) {
                    if (5 > i) {
                        y = 7;
                        break;
                    }
                    u = c, p = m, b = s, null == t || 5 > i ? t = 0 : 5 <= i && 47 == t[n + 0] && !(t[n + 4] >> 5) ? (w = [
                        0
                    ], k = [
                        0
                    ], A = [
                        0
                    ], v(x = new N, t, n, i), gt(x, w, k, A) ? (null != u && (u[0] = w[0]), null != p && (p[0] = k[0]), null != b && (b[0] = A[0]), t = 1) : t = 0) : t = 0;
                } else {
                    if (10 > i) {
                        y = 7;
                        break;
                    }
                    u = m, null == t || 10 > i || !Xt(t, n + 3, i - 3) ? t = 0 : (p = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16, b = 16383 & (t[n + 7] << 8 | t[n + 6]), t = 16383 & (t[n + 9] << 8 | t[n + 8]), 1 & p || 3 < (p >> 1 & 7) || !(p >> 4 & 1) || p >> 5 >= g.Ja || !b || !t ? t = 0 : (c && (c[0] = b), u && (u[0] = t), t = 1));
                }
                if (!t) return 3;
                if (c = c[0], m = m[0], d && (l[0] != c || f[0] != m)) return 3;
                null != h && (h[0] = g, h.offset = n - h.w, e(4294967286 > n - h.w), e(h.offset == h.ha - i));
                break;
            }
            return 0 == y || 7 == y && d && null == h ? (null != s && (s[0] |= null != g.na && 0 < g.na.length), null != a && (a[0] = c), null != o && (o[0] = m), 0) : y;
        }
        function Mr(t, e, r) {
            var n = e.width, i = e.height, a = 0, o = 0, s = n, c = i;
            if (e.Da = null != t && 0 < t.Da, e.Da && (s = t.cd, c = t.bd, a = t.v, o = t.j, 11 > r || (a &= -2, o &= -2), 0 > a || 0 > o || 0 >= s || 0 >= c || a + s > n || o + c > i)) return 0;
            if (e.v = a, e.j = o, e.va = a + s, e.o = o + c, e.U = s, e.T = c, e.da = null != t && 0 < t.da, e.da) {
                if (!E(s, c, r = [
                    t.ib
                ], a = [
                    t.hb
                ])) return 0;
                e.ib = r[0], e.hb = a[0];
            }
            return e.ob = null != t && t.ob, e.Kb = null == t || !t.Sd, e.da && (e.ob = e.ib < 3 * n / 4 && e.hb < 3 * i / 4, e.Kb = 0), 1;
        }
        function Er(t) {
            if (null == t) return 2;
            if (11 > t.S) {
                var e = t.f.RGBA;
                e.fb += (t.height - 1) * e.A, e.A = -e.A;
            } else e = t.f.kb, t = t.height, e.O += (t - 1) * e.fa, e.fa = -e.fa, e.N += (t - 1 >> 1) * e.Ab, e.Ab = -e.Ab, e.W += (t - 1 >> 1) * e.Db, e.Db = -e.Db, null != e.F && (e.J += (t - 1) * e.lb, e.lb = -e.lb);
            return 0;
        }
        function qr(t, e, r, n) {
            if (null == n || 0 >= t || 0 >= e) return 2;
            if (null != r) {
                if (r.Da) {
                    var i = r.cd, o = r.bd, s = -2 & r.v, c = -2 & r.j;
                    if (0 > s || 0 > c || 0 >= i || 0 >= o || s + i > t || c + o > e) return 2;
                    t = i, e = o;
                }
                if (r.da) {
                    if (!E(t, e, i = [
                        r.ib
                    ], o = [
                        r.hb
                    ])) return 2;
                    t = i[0], e = o[0];
                }
            }
            n.width = t, n.height = e;
            t: {
                var u = n.width, h = n.height;
                if (t = n.S, 0 >= u || 0 >= h || !(t >= En && 13 > t)) t = 2;
                else {
                    if (0 >= n.Rd && null == n.sd) {
                        s = o = i = e = 0;
                        var l = (c = u * zi[t]) * h;
                        if (11 > t || (o = (h + 1) / 2 * (e = (u + 1) / 2), 12 == t && (s = (i = u) * h)), null == (h = a(l + 2 * o + s))) {
                            t = 1;
                            break t;
                        }
                        n.sd = h, 11 > t ? ((u = n.f.RGBA).eb = h, u.fb = 0, u.A = c, u.size = l) : ((u = n.f.kb).y = h, u.O = 0, u.fa = c, u.Fd = l, u.f = h, u.N = 0 + l, u.Ab = e, u.Cd = o, u.ea = h, u.W = 0 + l + o, u.Db = e, u.Ed = o, 12 == t && (u.F = h, u.J = 0 + l + 2 * o), u.Tc = s, u.lb = i);
                    }
                    if (e = 1, i = n.S, o = n.width, s = n.height, i >= En && 13 > i) {
                        if (11 > i) t = n.f.RGBA, e &= (c = Math.abs(t.A)) * (s - 1) + o <= t.size, e &= c >= o * zi[i], e &= null != t.eb;
                        else {
                            t = n.f.kb, c = (o + 1) / 2, l = (s + 1) / 2, u = Math.abs(t.fa);
                            h = Math.abs(t.Ab);
                            var f = Math.abs(t.Db), d = Math.abs(t.lb), p = d * (s - 1) + o;
                            e &= u * (s - 1) + o <= t.Fd, e &= h * (l - 1) + c <= t.Cd, e = (e &= f * (l - 1) + c <= t.Ed) & u >= o & h >= c & f >= c, e &= null != t.y, e &= null != t.f, e &= null != t.ea, 12 == i && (e &= d >= o, e &= p <= t.Tc, e &= null != t.F);
                        }
                    } else e = 0;
                    t = e ? 0 : 2;
                }
            }
            return 0 != t || null != r && r.fd && (t = Er(n)), t;
        }
        var Dr = 64, Rr = [
            0,
            1,
            3,
            7,
            15,
            31,
            63,
            127,
            255,
            511,
            1023,
            2047,
            4095,
            8191,
            16383,
            32767,
            65535,
            131071,
            262143,
            524287,
            1048575,
            2097151,
            4194303,
            8388607,
            16777215
        ], Tr = 24, Ur = 32, zr = 8, Hr = [
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7
        ];
        R("Predictor0", "PredictorAdd0"), t.Predictor0 = function() {
            return 4278190080;
        }, t.Predictor1 = function(t) {
            return t;
        }, t.Predictor2 = function(t, e, r) {
            return e[r + 0];
        }, t.Predictor3 = function(t, e, r) {
            return e[r + 1];
        }, t.Predictor4 = function(t, e, r) {
            return e[r - 1];
        }, t.Predictor5 = function(t, e, r) {
            return U(U(t, e[r + 1]), e[r + 0]);
        }, t.Predictor6 = function(t, e, r) {
            return U(t, e[r - 1]);
        }, t.Predictor7 = function(t, e, r) {
            return U(t, e[r + 0]);
        }, t.Predictor8 = function(t, e, r) {
            return U(e[r - 1], e[r + 0]);
        }, t.Predictor9 = function(t, e, r) {
            return U(e[r + 0], e[r + 1]);
        }, t.Predictor10 = function(t, e, r) {
            return U(U(t, e[r - 1]), U(e[r + 0], e[r + 1]));
        }, t.Predictor11 = function(t, e, r) {
            var n = e[r + 0];
            return 0 >= W(n >> 24 & 255, t >> 24 & 255, (e = e[r - 1]) >> 24 & 255) + W(n >> 16 & 255, t >> 16 & 255, e >> 16 & 255) + W(n >> 8 & 255, t >> 8 & 255, e >> 8 & 255) + W(255 & n, 255 & t, 255 & e) ? n : t;
        }, t.Predictor12 = function(t, e, r) {
            var n = e[r + 0];
            return (z((t >> 24 & 255) + (n >> 24 & 255) - ((e = e[r - 1]) >> 24 & 255)) << 24 | z((t >> 16 & 255) + (n >> 16 & 255) - (e >> 16 & 255)) << 16 | z((t >> 8 & 255) + (n >> 8 & 255) - (e >> 8 & 255)) << 8 | z((255 & t) + (255 & n) - (255 & e))) >>> 0;
        }, t.Predictor13 = function(t, e, r) {
            var n = e[r - 1];
            return (H((t = U(t, e[r + 0])) >> 24 & 255, n >> 24 & 255) << 24 | H(t >> 16 & 255, n >> 16 & 255) << 16 | H(t >> 8 & 255, n >> 8 & 255) << 8 | H(t >> 0 & 255, n >> 0 & 255)) >>> 0;
        };
        var Wr = t.PredictorAdd0;
        t.PredictorAdd1 = V, R("Predictor2", "PredictorAdd2"), R("Predictor3", "PredictorAdd3"), R("Predictor4", "PredictorAdd4"), R("Predictor5", "PredictorAdd5"), R("Predictor6", "PredictorAdd6"), R("Predictor7", "PredictorAdd7"), R("Predictor8", "PredictorAdd8"), R("Predictor9", "PredictorAdd9"), R("Predictor10", "PredictorAdd10"), R("Predictor11", "PredictorAdd11"), R("Predictor12", "PredictorAdd12"), R("Predictor13", "PredictorAdd13");
        var Vr = t.PredictorAdd2;
        X("ColorIndexInverseTransform", "MapARGB", "32b", function(t) {
            return t >> 8 & 255;
        }, function(t) {
            return t;
        }), X("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t) {
            return t;
        }, function(t) {
            return t >> 8 & 255;
        });
        var Gr, Yr = t.ColorIndexInverseTransform, Jr = t.MapARGB, Xr = t.VP8LColorIndexInverseTransformAlpha, Kr = t.MapAlpha, Zr = t.VP8LPredictorsAdd = [];
        Zr.length = 16, (t.VP8LPredictors = []).length = 16, (t.VP8LPredictorsAdd_C = []).length = 16, (t.VP8LPredictors_C = []).length = 16;
        var $r, Qr, tn, en, rn, nn, an, on, sn, cn, un, hn, ln, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a(511), kn = a(2041), In = a(225), Fn = a(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, Un = 5, zn = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [
            2,
            3,
            7
        ], Jn = [
            3,
            3,
            11
        ], Xn = [
            280,
            256,
            256,
            256,
            40
        ], Kn = [
            0,
            1,
            1,
            1,
            0
        ], Zn = [
            17,
            18,
            0,
            1,
            2,
            3,
            4,
            5,
            16,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15
        ], $n = [
            24,
            7,
            23,
            25,
            40,
            6,
            39,
            41,
            22,
            26,
            38,
            42,
            56,
            5,
            55,
            57,
            21,
            27,
            54,
            58,
            37,
            43,
            72,
            4,
            71,
            73,
            20,
            28,
            53,
            59,
            70,
            74,
            36,
            44,
            88,
            69,
            75,
            52,
            60,
            3,
            87,
            89,
            19,
            29,
            86,
            90,
            35,
            45,
            68,
            76,
            85,
            91,
            51,
            61,
            104,
            2,
            103,
            105,
            18,
            30,
            102,
            106,
            34,
            46,
            84,
            92,
            67,
            77,
            101,
            107,
            50,
            62,
            120,
            1,
            119,
            121,
            83,
            93,
            17,
            31,
            100,
            108,
            66,
            78,
            118,
            122,
            33,
            47,
            117,
            123,
            49,
            63,
            99,
            109,
            82,
            94,
            0,
            116,
            124,
            65,
            79,
            16,
            32,
            98,
            110,
            48,
            115,
            125,
            81,
            95,
            64,
            114,
            126,
            97,
            111,
            80,
            113,
            127,
            96,
            112
        ], Qn = [
            2954,
            2956,
            2958,
            2962,
            2970,
            2986,
            3018,
            3082,
            3212,
            3468,
            3980,
            5004
        ], ti = 8, ei = [
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            17,
            18,
            19,
            20,
            20,
            21,
            21,
            22,
            22,
            23,
            23,
            24,
            25,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            91,
            93,
            95,
            96,
            98,
            100,
            101,
            102,
            104,
            106,
            108,
            110,
            112,
            114,
            116,
            118,
            122,
            124,
            126,
            128,
            130,
            132,
            134,
            136,
            138,
            140,
            143,
            145,
            148,
            151,
            154,
            157
        ], ri = [
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            60,
            62,
            64,
            66,
            68,
            70,
            72,
            74,
            76,
            78,
            80,
            82,
            84,
            86,
            88,
            90,
            92,
            94,
            96,
            98,
            100,
            102,
            104,
            106,
            108,
            110,
            112,
            114,
            116,
            119,
            122,
            125,
            128,
            131,
            134,
            137,
            140,
            143,
            146,
            149,
            152,
            155,
            158,
            161,
            164,
            167,
            170,
            173,
            177,
            181,
            185,
            189,
            193,
            197,
            201,
            205,
            209,
            213,
            217,
            221,
            225,
            229,
            234,
            239,
            245,
            249,
            254,
            259,
            264,
            269,
            274,
            279,
            284
        ], ni = null, ii = [
            [
                173,
                148,
                140,
                0
            ],
            [
                176,
                155,
                140,
                135,
                0
            ],
            [
                180,
                157,
                141,
                134,
                130,
                0
            ],
            [
                254,
                254,
                243,
                230,
                196,
                177,
                153,
                140,
                133,
                130,
                129,
                0
            ]
        ], ai = [
            0,
            1,
            4,
            8,
            5,
            2,
            3,
            6,
            9,
            12,
            13,
            10,
            7,
            11,
            14,
            15
        ], oi = [
            -0,
            1,
            -1,
            2,
            -2,
            3,
            4,
            6,
            -3,
            5,
            -4,
            -5,
            -6,
            7,
            -7,
            8,
            -8,
            -9
        ], si = [
            [
                [
                    [
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        253,
                        136,
                        254,
                        255,
                        228,
                        219,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        189,
                        129,
                        242,
                        255,
                        227,
                        213,
                        255,
                        219,
                        128,
                        128,
                        128
                    ],
                    [
                        106,
                        126,
                        227,
                        252,
                        214,
                        209,
                        255,
                        255,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        98,
                        248,
                        255,
                        236,
                        226,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        181,
                        133,
                        238,
                        254,
                        221,
                        234,
                        255,
                        154,
                        128,
                        128,
                        128
                    ],
                    [
                        78,
                        134,
                        202,
                        247,
                        198,
                        180,
                        255,
                        219,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        185,
                        249,
                        255,
                        243,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        184,
                        150,
                        247,
                        255,
                        236,
                        224,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        77,
                        110,
                        216,
                        255,
                        236,
                        230,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        101,
                        251,
                        255,
                        241,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        170,
                        139,
                        241,
                        252,
                        236,
                        209,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        37,
                        116,
                        196,
                        243,
                        228,
                        255,
                        255,
                        255,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        204,
                        254,
                        255,
                        245,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        207,
                        160,
                        250,
                        255,
                        238,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        102,
                        103,
                        231,
                        255,
                        211,
                        171,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        152,
                        252,
                        255,
                        240,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        177,
                        135,
                        243,
                        255,
                        234,
                        225,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        80,
                        129,
                        211,
                        255,
                        194,
                        224,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        1,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        246,
                        1,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ]
            ],
            [
                [
                    [
                        198,
                        35,
                        237,
                        223,
                        193,
                        187,
                        162,
                        160,
                        145,
                        155,
                        62
                    ],
                    [
                        131,
                        45,
                        198,
                        221,
                        172,
                        176,
                        220,
                        157,
                        252,
                        221,
                        1
                    ],
                    [
                        68,
                        47,
                        146,
                        208,
                        149,
                        167,
                        221,
                        162,
                        255,
                        223,
                        128
                    ]
                ],
                [
                    [
                        1,
                        149,
                        241,
                        255,
                        221,
                        224,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        184,
                        141,
                        234,
                        253,
                        222,
                        220,
                        255,
                        199,
                        128,
                        128,
                        128
                    ],
                    [
                        81,
                        99,
                        181,
                        242,
                        176,
                        190,
                        249,
                        202,
                        255,
                        255,
                        128
                    ]
                ],
                [
                    [
                        1,
                        129,
                        232,
                        253,
                        214,
                        197,
                        242,
                        196,
                        255,
                        255,
                        128
                    ],
                    [
                        99,
                        121,
                        210,
                        250,
                        201,
                        198,
                        255,
                        202,
                        128,
                        128,
                        128
                    ],
                    [
                        23,
                        91,
                        163,
                        242,
                        170,
                        187,
                        247,
                        210,
                        255,
                        255,
                        128
                    ]
                ],
                [
                    [
                        1,
                        200,
                        246,
                        255,
                        234,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        109,
                        178,
                        241,
                        255,
                        231,
                        245,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        44,
                        130,
                        201,
                        253,
                        205,
                        192,
                        255,
                        255,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        132,
                        239,
                        251,
                        219,
                        209,
                        255,
                        165,
                        128,
                        128,
                        128
                    ],
                    [
                        94,
                        136,
                        225,
                        251,
                        218,
                        190,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        22,
                        100,
                        174,
                        245,
                        186,
                        161,
                        255,
                        199,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        182,
                        249,
                        255,
                        232,
                        235,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        124,
                        143,
                        241,
                        255,
                        227,
                        234,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        35,
                        77,
                        181,
                        251,
                        193,
                        211,
                        255,
                        205,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        157,
                        247,
                        255,
                        236,
                        231,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        121,
                        141,
                        235,
                        255,
                        225,
                        227,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        45,
                        99,
                        188,
                        251,
                        195,
                        217,
                        255,
                        224,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        1,
                        251,
                        255,
                        213,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        203,
                        1,
                        248,
                        255,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        137,
                        1,
                        177,
                        255,
                        224,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ]
            ],
            [
                [
                    [
                        253,
                        9,
                        248,
                        251,
                        207,
                        208,
                        255,
                        192,
                        128,
                        128,
                        128
                    ],
                    [
                        175,
                        13,
                        224,
                        243,
                        193,
                        185,
                        249,
                        198,
                        255,
                        255,
                        128
                    ],
                    [
                        73,
                        17,
                        171,
                        221,
                        161,
                        179,
                        236,
                        167,
                        255,
                        234,
                        128
                    ]
                ],
                [
                    [
                        1,
                        95,
                        247,
                        253,
                        212,
                        183,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        239,
                        90,
                        244,
                        250,
                        211,
                        209,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        155,
                        77,
                        195,
                        248,
                        188,
                        195,
                        255,
                        255,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        24,
                        239,
                        251,
                        218,
                        219,
                        255,
                        205,
                        128,
                        128,
                        128
                    ],
                    [
                        201,
                        51,
                        219,
                        255,
                        196,
                        186,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        69,
                        46,
                        190,
                        239,
                        201,
                        218,
                        255,
                        228,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        191,
                        251,
                        255,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        223,
                        165,
                        249,
                        255,
                        213,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        141,
                        124,
                        248,
                        255,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        16,
                        248,
                        255,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        190,
                        36,
                        230,
                        255,
                        236,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        149,
                        1,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        226,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        247,
                        192,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        240,
                        128,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        134,
                        252,
                        255,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        213,
                        62,
                        250,
                        255,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        55,
                        93,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ]
            ],
            [
                [
                    [
                        202,
                        24,
                        213,
                        235,
                        186,
                        191,
                        220,
                        160,
                        240,
                        175,
                        255
                    ],
                    [
                        126,
                        38,
                        182,
                        232,
                        169,
                        184,
                        228,
                        174,
                        255,
                        187,
                        128
                    ],
                    [
                        61,
                        46,
                        138,
                        219,
                        151,
                        178,
                        240,
                        170,
                        255,
                        216,
                        128
                    ]
                ],
                [
                    [
                        1,
                        112,
                        230,
                        250,
                        199,
                        191,
                        247,
                        159,
                        255,
                        255,
                        128
                    ],
                    [
                        166,
                        109,
                        228,
                        252,
                        211,
                        215,
                        255,
                        174,
                        128,
                        128,
                        128
                    ],
                    [
                        39,
                        77,
                        162,
                        232,
                        172,
                        180,
                        245,
                        178,
                        255,
                        255,
                        128
                    ]
                ],
                [
                    [
                        1,
                        52,
                        220,
                        246,
                        198,
                        199,
                        249,
                        220,
                        255,
                        255,
                        128
                    ],
                    [
                        124,
                        74,
                        191,
                        243,
                        183,
                        193,
                        250,
                        221,
                        255,
                        255,
                        128
                    ],
                    [
                        24,
                        71,
                        130,
                        219,
                        154,
                        170,
                        243,
                        182,
                        255,
                        255,
                        128
                    ]
                ],
                [
                    [
                        1,
                        182,
                        225,
                        249,
                        219,
                        240,
                        255,
                        224,
                        128,
                        128,
                        128
                    ],
                    [
                        149,
                        150,
                        226,
                        252,
                        216,
                        205,
                        255,
                        171,
                        128,
                        128,
                        128
                    ],
                    [
                        28,
                        108,
                        170,
                        242,
                        183,
                        194,
                        254,
                        223,
                        255,
                        255,
                        128
                    ]
                ],
                [
                    [
                        1,
                        81,
                        230,
                        252,
                        204,
                        203,
                        255,
                        192,
                        128,
                        128,
                        128
                    ],
                    [
                        123,
                        102,
                        209,
                        247,
                        188,
                        196,
                        255,
                        233,
                        128,
                        128,
                        128
                    ],
                    [
                        20,
                        95,
                        153,
                        243,
                        164,
                        173,
                        255,
                        203,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        222,
                        248,
                        255,
                        216,
                        213,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        168,
                        175,
                        246,
                        252,
                        235,
                        205,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        47,
                        116,
                        215,
                        255,
                        211,
                        212,
                        255,
                        255,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        121,
                        236,
                        253,
                        212,
                        214,
                        255,
                        255,
                        128,
                        128,
                        128
                    ],
                    [
                        141,
                        84,
                        213,
                        252,
                        201,
                        202,
                        255,
                        219,
                        128,
                        128,
                        128
                    ],
                    [
                        42,
                        80,
                        160,
                        240,
                        162,
                        185,
                        255,
                        205,
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        1,
                        1,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        244,
                        1,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ],
                    [
                        238,
                        1,
                        255,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128,
                        128
                    ]
                ]
            ]
        ], ci = [
            [
                [
                    231,
                    120,
                    48,
                    89,
                    115,
                    113,
                    120,
                    152,
                    112
                ],
                [
                    152,
                    179,
                    64,
                    126,
                    170,
                    118,
                    46,
                    70,
                    95
                ],
                [
                    175,
                    69,
                    143,
                    80,
                    85,
                    82,
                    72,
                    155,
                    103
                ],
                [
                    56,
                    58,
                    10,
                    171,
                    218,
                    189,
                    17,
                    13,
                    152
                ],
                [
                    114,
                    26,
                    17,
                    163,
                    44,
                    195,
                    21,
                    10,
                    173
                ],
                [
                    121,
                    24,
                    80,
                    195,
                    26,
                    62,
                    44,
                    64,
                    85
                ],
                [
                    144,
                    71,
                    10,
                    38,
                    171,
                    213,
                    144,
                    34,
                    26
                ],
                [
                    170,
                    46,
                    55,
                    19,
                    136,
                    160,
                    33,
                    206,
                    71
                ],
                [
                    63,
                    20,
                    8,
                    114,
                    114,
                    208,
                    12,
                    9,
                    226
                ],
                [
                    81,
                    40,
                    11,
                    96,
                    182,
                    84,
                    29,
                    16,
                    36
                ]
            ],
            [
                [
                    134,
                    183,
                    89,
                    137,
                    98,
                    101,
                    106,
                    165,
                    148
                ],
                [
                    72,
                    187,
                    100,
                    130,
                    157,
                    111,
                    32,
                    75,
                    80
                ],
                [
                    66,
                    102,
                    167,
                    99,
                    74,
                    62,
                    40,
                    234,
                    128
                ],
                [
                    41,
                    53,
                    9,
                    178,
                    241,
                    141,
                    26,
                    8,
                    107
                ],
                [
                    74,
                    43,
                    26,
                    146,
                    73,
                    166,
                    49,
                    23,
                    157
                ],
                [
                    65,
                    38,
                    105,
                    160,
                    51,
                    52,
                    31,
                    115,
                    128
                ],
                [
                    104,
                    79,
                    12,
                    27,
                    217,
                    255,
                    87,
                    17,
                    7
                ],
                [
                    87,
                    68,
                    71,
                    44,
                    114,
                    51,
                    15,
                    186,
                    23
                ],
                [
                    47,
                    41,
                    14,
                    110,
                    182,
                    183,
                    21,
                    17,
                    194
                ],
                [
                    66,
                    45,
                    25,
                    102,
                    197,
                    189,
                    23,
                    18,
                    22
                ]
            ],
            [
                [
                    88,
                    88,
                    147,
                    150,
                    42,
                    46,
                    45,
                    196,
                    205
                ],
                [
                    43,
                    97,
                    183,
                    117,
                    85,
                    38,
                    35,
                    179,
                    61
                ],
                [
                    39,
                    53,
                    200,
                    87,
                    26,
                    21,
                    43,
                    232,
                    171
                ],
                [
                    56,
                    34,
                    51,
                    104,
                    114,
                    102,
                    29,
                    93,
                    77
                ],
                [
                    39,
                    28,
                    85,
                    171,
                    58,
                    165,
                    90,
                    98,
                    64
                ],
                [
                    34,
                    22,
                    116,
                    206,
                    23,
                    34,
                    43,
                    166,
                    73
                ],
                [
                    107,
                    54,
                    32,
                    26,
                    51,
                    1,
                    81,
                    43,
                    31
                ],
                [
                    68,
                    25,
                    106,
                    22,
                    64,
                    171,
                    36,
                    225,
                    114
                ],
                [
                    34,
                    19,
                    21,
                    102,
                    132,
                    188,
                    16,
                    76,
                    124
                ],
                [
                    62,
                    18,
                    78,
                    95,
                    85,
                    57,
                    50,
                    48,
                    51
                ]
            ],
            [
                [
                    193,
                    101,
                    35,
                    159,
                    215,
                    111,
                    89,
                    46,
                    111
                ],
                [
                    60,
                    148,
                    31,
                    172,
                    219,
                    228,
                    21,
                    18,
                    111
                ],
                [
                    112,
                    113,
                    77,
                    85,
                    179,
                    255,
                    38,
                    120,
                    114
                ],
                [
                    40,
                    42,
                    1,
                    196,
                    245,
                    209,
                    10,
                    25,
                    109
                ],
                [
                    88,
                    43,
                    29,
                    140,
                    166,
                    213,
                    37,
                    43,
                    154
                ],
                [
                    61,
                    63,
                    30,
                    155,
                    67,
                    45,
                    68,
                    1,
                    209
                ],
                [
                    100,
                    80,
                    8,
                    43,
                    154,
                    1,
                    51,
                    26,
                    71
                ],
                [
                    142,
                    78,
                    78,
                    16,
                    255,
                    128,
                    34,
                    197,
                    171
                ],
                [
                    41,
                    40,
                    5,
                    102,
                    211,
                    183,
                    4,
                    1,
                    221
                ],
                [
                    51,
                    50,
                    17,
                    168,
                    209,
                    192,
                    23,
                    25,
                    82
                ]
            ],
            [
                [
                    138,
                    31,
                    36,
                    171,
                    27,
                    166,
                    38,
                    44,
                    229
                ],
                [
                    67,
                    87,
                    58,
                    169,
                    82,
                    115,
                    26,
                    59,
                    179
                ],
                [
                    63,
                    59,
                    90,
                    180,
                    59,
                    166,
                    93,
                    73,
                    154
                ],
                [
                    40,
                    40,
                    21,
                    116,
                    143,
                    209,
                    34,
                    39,
                    175
                ],
                [
                    47,
                    15,
                    16,
                    183,
                    34,
                    223,
                    49,
                    45,
                    183
                ],
                [
                    46,
                    17,
                    33,
                    183,
                    6,
                    98,
                    15,
                    32,
                    183
                ],
                [
                    57,
                    46,
                    22,
                    24,
                    128,
                    1,
                    54,
                    17,
                    37
                ],
                [
                    65,
                    32,
                    73,
                    115,
                    28,
                    128,
                    23,
                    128,
                    205
                ],
                [
                    40,
                    3,
                    9,
                    115,
                    51,
                    192,
                    18,
                    6,
                    223
                ],
                [
                    87,
                    37,
                    9,
                    115,
                    59,
                    77,
                    64,
                    21,
                    47
                ]
            ],
            [
                [
                    104,
                    55,
                    44,
                    218,
                    9,
                    54,
                    53,
                    130,
                    226
                ],
                [
                    64,
                    90,
                    70,
                    205,
                    40,
                    41,
                    23,
                    26,
                    57
                ],
                [
                    54,
                    57,
                    112,
                    184,
                    5,
                    41,
                    38,
                    166,
                    213
                ],
                [
                    30,
                    34,
                    26,
                    133,
                    152,
                    116,
                    10,
                    32,
                    134
                ],
                [
                    39,
                    19,
                    53,
                    221,
                    26,
                    114,
                    32,
                    73,
                    255
                ],
                [
                    31,
                    9,
                    65,
                    234,
                    2,
                    15,
                    1,
                    118,
                    73
                ],
                [
                    75,
                    32,
                    12,
                    51,
                    192,
                    255,
                    160,
                    43,
                    51
                ],
                [
                    88,
                    31,
                    35,
                    67,
                    102,
                    85,
                    55,
                    186,
                    85
                ],
                [
                    56,
                    21,
                    23,
                    111,
                    59,
                    205,
                    45,
                    37,
                    192
                ],
                [
                    55,
                    38,
                    70,
                    124,
                    73,
                    102,
                    1,
                    34,
                    98
                ]
            ],
            [
                [
                    125,
                    98,
                    42,
                    88,
                    104,
                    85,
                    117,
                    175,
                    82
                ],
                [
                    95,
                    84,
                    53,
                    89,
                    128,
                    100,
                    113,
                    101,
                    45
                ],
                [
                    75,
                    79,
                    123,
                    47,
                    51,
                    128,
                    81,
                    171,
                    1
                ],
                [
                    57,
                    17,
                    5,
                    71,
                    102,
                    57,
                    53,
                    41,
                    49
                ],
                [
                    38,
                    33,
                    13,
                    121,
                    57,
                    73,
                    26,
                    1,
                    85
                ],
                [
                    41,
                    10,
                    67,
                    138,
                    77,
                    110,
                    90,
                    47,
                    114
                ],
                [
                    115,
                    21,
                    2,
                    10,
                    102,
                    255,
                    166,
                    23,
                    6
                ],
                [
                    101,
                    29,
                    16,
                    10,
                    85,
                    128,
                    101,
                    196,
                    26
                ],
                [
                    57,
                    18,
                    10,
                    102,
                    102,
                    213,
                    34,
                    20,
                    43
                ],
                [
                    117,
                    20,
                    15,
                    36,
                    163,
                    128,
                    68,
                    1,
                    26
                ]
            ],
            [
                [
                    102,
                    61,
                    71,
                    37,
                    34,
                    53,
                    31,
                    243,
                    192
                ],
                [
                    69,
                    60,
                    71,
                    38,
                    73,
                    119,
                    28,
                    222,
                    37
                ],
                [
                    68,
                    45,
                    128,
                    34,
                    1,
                    47,
                    11,
                    245,
                    171
                ],
                [
                    62,
                    17,
                    19,
                    70,
                    146,
                    85,
                    55,
                    62,
                    70
                ],
                [
                    37,
                    43,
                    37,
                    154,
                    100,
                    163,
                    85,
                    160,
                    1
                ],
                [
                    63,
                    9,
                    92,
                    136,
                    28,
                    64,
                    32,
                    201,
                    85
                ],
                [
                    75,
                    15,
                    9,
                    9,
                    64,
                    255,
                    184,
                    119,
                    16
                ],
                [
                    86,
                    6,
                    28,
                    5,
                    64,
                    255,
                    25,
                    248,
                    1
                ],
                [
                    56,
                    8,
                    17,
                    132,
                    137,
                    255,
                    55,
                    116,
                    128
                ],
                [
                    58,
                    15,
                    20,
                    82,
                    135,
                    57,
                    26,
                    121,
                    40
                ]
            ],
            [
                [
                    164,
                    50,
                    31,
                    137,
                    154,
                    133,
                    25,
                    35,
                    218
                ],
                [
                    51,
                    103,
                    44,
                    131,
                    131,
                    123,
                    31,
                    6,
                    158
                ],
                [
                    86,
                    40,
                    64,
                    135,
                    148,
                    224,
                    45,
                    183,
                    128
                ],
                [
                    22,
                    26,
                    17,
                    131,
                    240,
                    154,
                    14,
                    1,
                    209
                ],
                [
                    45,
                    16,
                    21,
                    91,
                    64,
                    222,
                    7,
                    1,
                    197
                ],
                [
                    56,
                    21,
                    39,
                    155,
                    60,
                    138,
                    23,
                    102,
                    213
                ],
                [
                    83,
                    12,
                    13,
                    54,
                    192,
                    255,
                    68,
                    47,
                    28
                ],
                [
                    85,
                    26,
                    85,
                    85,
                    128,
                    128,
                    32,
                    146,
                    171
                ],
                [
                    18,
                    11,
                    7,
                    63,
                    144,
                    171,
                    4,
                    4,
                    246
                ],
                [
                    35,
                    27,
                    10,
                    146,
                    174,
                    171,
                    12,
                    26,
                    128
                ]
            ],
            [
                [
                    190,
                    80,
                    35,
                    99,
                    180,
                    80,
                    126,
                    54,
                    45
                ],
                [
                    85,
                    126,
                    47,
                    87,
                    176,
                    51,
                    41,
                    20,
                    32
                ],
                [
                    101,
                    75,
                    128,
                    139,
                    118,
                    146,
                    116,
                    128,
                    85
                ],
                [
                    56,
                    41,
                    15,
                    176,
                    236,
                    85,
                    37,
                    9,
                    62
                ],
                [
                    71,
                    30,
                    17,
                    119,
                    118,
                    255,
                    17,
                    18,
                    138
                ],
                [
                    101,
                    38,
                    60,
                    138,
                    55,
                    70,
                    43,
                    26,
                    142
                ],
                [
                    146,
                    36,
                    19,
                    30,
                    171,
                    255,
                    97,
                    27,
                    20
                ],
                [
                    138,
                    45,
                    61,
                    62,
                    219,
                    1,
                    81,
                    188,
                    64
                ],
                [
                    32,
                    41,
                    20,
                    117,
                    151,
                    142,
                    20,
                    21,
                    163
                ],
                [
                    112,
                    19,
                    12,
                    61,
                    195,
                    128,
                    48,
                    4,
                    24
                ]
            ]
        ], ui = [
            [
                [
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        176,
                        246,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        223,
                        241,
                        252,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        249,
                        253,
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        244,
                        252,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        234,
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        246,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        239,
                        253,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        254,
                        255,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        248,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        251,
                        255,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        253,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        251,
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        254,
                        255,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        254,
                        253,
                        255,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        250,
                        255,
                        254,
                        255,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ]
            ],
            [
                [
                    [
                        217,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        225,
                        252,
                        241,
                        253,
                        255,
                        255,
                        254,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        234,
                        250,
                        241,
                        250,
                        253,
                        255,
                        253,
                        254,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        223,
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        238,
                        253,
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        248,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        249,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        247,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        253,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        252,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        254,
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        250,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ]
            ],
            [
                [
                    [
                        186,
                        251,
                        250,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        234,
                        251,
                        244,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        251,
                        251,
                        243,
                        253,
                        254,
                        255,
                        254,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        253,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        236,
                        253,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        251,
                        253,
                        253,
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        254,
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ]
            ],
            [
                [
                    [
                        248,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        250,
                        254,
                        252,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        248,
                        254,
                        249,
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        253,
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        246,
                        253,
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        252,
                        254,
                        251,
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        254,
                        252,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        248,
                        254,
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        253,
                        255,
                        254,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        251,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        245,
                        251,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        253,
                        253,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        251,
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        252,
                        253,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        252,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        249,
                        255,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        255,
                        253,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        250,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        254,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255
                    ]
                ]
            ]
        ], hi = [
            0,
            1,
            2,
            3,
            6,
            4,
            5,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            7,
            0
        ], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
        vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
        var bi = t.UpsampleRgbLinePair, yi = t.UpsampleBgrLinePair, wi = t.UpsampleRgbaLinePair, Ni = t.UpsampleBgraLinePair, Li = t.UpsampleArgbLinePair, Ai = t.UpsampleRgba4444LinePair, xi = t.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a(256), Oi = a(256), Bi = a(256), Mi = a(256), Ei = a(ki - Pi), qi = a(ki - Pi);
        Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
        var Di = [
            0,
            4,
            8,
            12,
            128,
            132,
            136,
            140,
            256,
            260,
            264,
            268,
            384,
            388,
            392,
            396
        ], Ri = [
            0,
            2,
            8
        ], Ti = [
            8,
            7,
            6,
            4,
            4,
            2,
            2,
            2,
            1,
            1,
            1,
            1
        ], Ui = 1;
        this.WebPDecodeRGBA = function(t, r, n, i, a) {
            var o = qn, s = new rr, c = new ot;
            s.ba = c, c.S = o, c.width = [
                c.width
            ], c.height = [
                c.height
            ];
            var u = c.width, h = c.height, l = new st;
            if (null == l || null == t) var f = 2;
            else e(null != l), f = Br(t, r, n, l.width, l.height, l.Pd, l.Qd, l.format, null);
            if (0 != f ? u = 0 : (null != u && (u[0] = l.width[0]), null != h && (h[0] = l.height[0]), u = 1), u) {
                c.width = c.width[0], c.height = c.height[0], null != i && (i[0] = c.width), null != a && (a[0] = c.height);
                t: {
                    if (i = new Gt, (a = new nr).data = t, a.w = r, a.ha = n, a.kd = 1, r = [
                        0
                    ], e(null != a), (0 == (t = Br(a.data, a.w, a.ha, null, null, null, r, null, a)) || 7 == t) && r[0] && (t = 4), 0 == (r = t)) {
                        if (e(null != s), i.data = a.data, i.w = a.w + a.offset, i.ha = a.ha - a.offset, i.put = dt, i.ac = ft, i.bc = pt, i.ma = s, a.xa) {
                            if (null == (t = kt())) {
                                s = 1;
                                break t;
                            }
                            if (function(t, r) {
                                var n = [
                                    0
                                ], i = [
                                    0
                                ], a = [
                                    0
                                ];
                                e: for(;;){
                                    if (null == t) return 0;
                                    if (null == r) return t.a = 2, 0;
                                    if (t.l = r, t.a = 0, v(t.m, r.data, r.w, r.ha), !gt(t.m, n, i, a)) {
                                        t.a = 3;
                                        break e;
                                    }
                                    if (t.xb = gi, r.width = n[0], r.height = i[0], !It(n[0], i[0], 1, t, null)) break e;
                                    return 1;
                                }
                                return e(0 != t.a), 0;
                            }(t, i)) {
                                if (i = 0 == (r = qr(i.width, i.height, s.Oa, s.ba))) {
                                    e: {
                                        i = t;
                                        r: for(;;){
                                            if (null == i) {
                                                i = 0;
                                                break e;
                                            }
                                            if (e(null != i.s.yc), e(null != i.s.Ya), e(0 < i.s.Wb), e(null != (n = i.l)), e(null != (a = n.ma)), 0 != i.xb) {
                                                if (i.ca = a.ba, i.tb = a.tb, e(null != i.ca), !Mr(a.Oa, n, Rn)) {
                                                    i.a = 2;
                                                    break r;
                                                }
                                                if (!Ft(i, n.width)) break r;
                                                if (n.da) break r;
                                                if ((n.da || nt(i.ca.S)) && mr(), 11 > i.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != i.ca.f.kb.F && mr()), i.Pb && 0 < i.s.ua && null == i.s.vb.X && !O(i.s.vb, i.s.Wa.Xa)) {
                                                    i.a = 1;
                                                    break r;
                                                }
                                                i.xb = 0;
                                            }
                                            if (!_t(i, i.V, i.Ba, i.c, i.i, n.o, Lt)) break r;
                                            a.Dc = i.Ma, i = 1;
                                            break e;
                                        }
                                        e(0 != i.a), i = 0;
                                    }
                                    i = !i;
                                }
                                i && (r = t.a);
                            } else r = t.a;
                        } else {
                            t = new Yt;
                            if (t.Fa = a.na, t.P = a.P, t.qc = a.Sa, Kt(t, i)) {
                                if (0 == (r = qr(i.width, i.height, s.Oa, s.ba))) {
                                    if (t.Aa = 0, n = s.Oa, e(null != (a = t)), null != n) {
                                        if (0 < (u = 0 > (u = n.Md) ? 0 : 100 < u ? 255 : 255 * u / 100)) {
                                            for(h = l = 0; 4 > h; ++h)12 > (f = a.pb[h]).lc && (f.ia = u * Ti[0 > f.lc ? 0 : f.lc] >> 3), l |= f.ia;
                                            l && (alert("todo:VP8InitRandom"), a.ia = 1);
                                        }
                                        a.Ga = n.Id, 100 < a.Ga ? a.Ga = 100 : 0 > a.Ga && (a.Ga = 0);
                                    }
                                    Qt(t, i) || (r = t.a);
                                }
                            } else r = t.a;
                        }
                        0 == r && null != s.Oa && s.Oa.fd && (r = Er(s.ba));
                    }
                    s = r;
                }
                o = 0 != s ? null : 11 > o ? c.f.RGBA.eb : c.f.kb.y;
            } else o = null;
            return o;
        };
        var zi = [
            3,
            4,
            3,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            1,
            1
        ];
    };
    function u(t, e) {
        for(var r = "", n = 0; n < 4; n++)r += String.fromCharCode(t[e++]);
        return r;
    }
    function h(t, e) {
        return (t[e + 0] << 0 | t[e + 1] << 8 | t[e + 2] << 16) >>> 0;
    }
    function l(t, e) {
        return (t[e + 0] << 0 | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0;
    }
    new c;
    var f = [
        0
    ], d = [
        0
    ], p = [], g = new c, m = t, v = function(t, e) {
        var r = {}, n = 0, i = !1, a = 0, o = 0;
        if (r.frames = [], !/** @license
   * Copyright (c) 2017 Dominik Homberger
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  https://webpjs.appspot.com
  WebPRiffParser dominikhlbg@gmail.com
  */ function(t, e, r, n) {
            for(var i = 0; i < n; i++)if (t[e + i] != r.charCodeAt(i)) return !0;
            return !1;
        }(t, e, "RIFF", 4)) {
            var s, c;
            l(t, e += 4);
            for(e += 8; e < t.length;){
                var f = u(t, e), d = l(t, e += 4);
                e += 4;
                var p = d + (1 & d);
                switch(f){
                    case "VP8 ":
                    case "VP8L":
                        void 0 === r.frames[n] && (r.frames[n] = {});
                        (v = r.frames[n]).src_off = i ? o : e - 8, v.src_size = a + d + 8, n++, i && (i = !1, a = 0, o = 0);
                        break;
                    case "VP8X":
                        (v = r.header = {}).feature_flags = t[e];
                        var g = e + 4;
                        v.canvas_width = 1 + h(t, g);
                        g += 3;
                        v.canvas_height = 1 + h(t, g);
                        g += 3;
                        break;
                    case "ALPH":
                        i = !0, a = p + 8, o = e - 8;
                        break;
                    case "ANIM":
                        (v = r.header).bgcolor = l(t, e);
                        g = e + 4;
                        v.loop_count = (s = t)[(c = g) + 0] << 0 | s[c + 1] << 8;
                        g += 2;
                        break;
                    case "ANMF":
                        var m, v;
                        (v = r.frames[n] = {}).offset_x = 2 * h(t, e), e += 3, v.offset_y = 2 * h(t, e), e += 3, v.width = 1 + h(t, e), e += 3, v.height = 1 + h(t, e), e += 3, v.duration = h(t, e), e += 3, m = t[e++], v.dispose = 1 & m, v.blend = m >> 1 & 1;
                }
                "ANMF" != f && (e += p);
            }
            return r;
        }
    }(m, 0);
    v.response = m, v.rgbaoutput = !0, v.dataurl = !1;
    var b = v.header ? v.header : null, y = v.frames ? v.frames : null;
    if (b) {
        b.loop_counter = b.loop_count, f = [
            b.canvas_height
        ], d = [
            b.canvas_width
        ];
        for(var w = 0; w < y.length && 0 != y[w].blend; w++);
    }
    var N = y[0], L = g.WebPDecodeRGBA(m, N.src_off, N.src_size, d, f);
    N.rgba = L, N.imgwidth = d[0], N.imgheight = f[0];
    for(var A = 0; A < d[0] * f[0] * 4; A++)p[A] = L[A];
    return this.width = d, this.height = f, this.data = p, this;
}
!function(t) {
    var r = function() {
        return "function" == typeof (0, _fflate.zlibSync);
    }, n = function(r, n, a, h) {
        var l = 4, f = s;
        switch(h){
            case t.image_compression.FAST:
                l = 1, f = o;
                break;
            case t.image_compression.MEDIUM:
                l = 6, f = c;
                break;
            case t.image_compression.SLOW:
                l = 9, f = u;
        }
        r = i(r, n, a, f);
        var d = (0, _fflate.zlibSync)(r, {
            level: l
        });
        return t.__addimage__.arrayBufferToBinaryString(d);
    }, i = function(t, e, r, n) {
        for(var i, a, o, s = t.length / e, c = new Uint8Array(t.length + s), u = l(), h = 0; h < s; h += 1){
            if (o = h * e, i = t.subarray(o, o + e), n) c.set(n(i, r, a), o + h);
            else {
                for(var d, p = u.length, g = []; d < p; d += 1)g[d] = u[d](i, r, a);
                var m = f(g.concat());
                c.set(g[m], o + h);
            }
            a = i;
        }
        return c;
    }, a = function(t) {
        var e = Array.apply([], t);
        return e.unshift(0), e;
    }, o = function(t, e) {
        var r, n = [], i = t.length;
        n[0] = 1;
        for(var a = 0; a < i; a += 1)r = t[a - e] || 0, n[a + 1] = t[a] - r + 256 & 255;
        return n;
    }, s = function(t, e, r) {
        var n, i = [], a = t.length;
        i[0] = 2;
        for(var o = 0; o < a; o += 1)n = r && r[o] || 0, i[o + 1] = t[o] - n + 256 & 255;
        return i;
    }, c = function(t, e, r) {
        var n, i, a = [], o = t.length;
        a[0] = 3;
        for(var s = 0; s < o; s += 1)n = t[s - e] || 0, i = r && r[s] || 0, a[s + 1] = t[s] + 256 - (n + i >>> 1) & 255;
        return a;
    }, u = function(t, e, r) {
        var n, i, a, o, s = [], c = t.length;
        s[0] = 4;
        for(var u = 0; u < c; u += 1)n = t[u - e] || 0, i = r && r[u] || 0, a = r && r[u - e] || 0, o = h(n, i, a), s[u + 1] = t[u] - o + 256 & 255;
        return s;
    }, h = function(t, e, r) {
        if (t === e && e === r) return t;
        var n = Math.abs(e - r), i = Math.abs(t - r), a = Math.abs(t + e - r - r);
        return n <= i && n <= a ? t : i <= a ? e : r;
    }, l = function() {
        return [
            a,
            o,
            s,
            c,
            u
        ];
    }, f = function(t) {
        var e = t.map(function(t) {
            return t.reduce(function(t, e) {
                return t + Math.abs(e);
            }, 0);
        });
        return e.indexOf(Math.min.apply(null, e));
    };
    t.processPNG = function(e, i, a, o) {
        var s, c, u, h, l, f, d, p, g, m, v, b, y, w, N, L = this.decode.FLATE_DECODE, A = "";
        if (this.__addimage__.isArrayBuffer(e) && (e = new Uint8Array(e)), this.__addimage__.isArrayBufferView(e)) {
            if (e = (u = new Kt(e)).imgData, c = u.bits, s = u.colorSpace, l = u.colors, -1 !== [
                4,
                6
            ].indexOf(u.colorType)) {
                if (8 === u.bits) {
                    g = (p = 32 == u.pixelBitlength ? new Uint32Array(u.decodePixels().buffer) : 16 == u.pixelBitlength ? new Uint16Array(u.decodePixels().buffer) : new Uint8Array(u.decodePixels().buffer)).length, v = new Uint8Array(g * u.colors), m = new Uint8Array(g);
                    var x, S = u.pixelBitlength - u.bits;
                    for(w = 0, N = 0; w < g; w++){
                        for(y = p[w], x = 0; x < S;)v[N++] = y >>> x & 255, x += u.bits;
                        m[w] = y >>> x & 255;
                    }
                }
                if (16 === u.bits) {
                    g = (p = new Uint32Array(u.decodePixels().buffer)).length, v = new Uint8Array(g * (32 / u.pixelBitlength) * u.colors), m = new Uint8Array(g * (32 / u.pixelBitlength)), b = u.colors > 1, w = 0, N = 0;
                    for(var _ = 0; w < g;)y = p[w++], v[N++] = y >>> 0 & 255, b && (v[N++] = y >>> 16 & 255, y = p[w++], v[N++] = y >>> 0 & 255), m[_++] = y >>> 16 & 255;
                    c = 8;
                }
                o !== t.image_compression.NONE && r() ? (e = n(v, u.width * u.colors, u.colors, o), d = n(m, u.width, 1, o)) : (e = v, d = m, L = void 0);
            }
            if (3 === u.colorType && (s = this.color_spaces.INDEXED, f = u.palette, u.transparency.indexed)) {
                var P = u.transparency.indexed, k = 0;
                for(w = 0, g = P.length; w < g; ++w)k += P[w];
                if ((k /= 255) === g - 1 && -1 !== P.indexOf(0)) h = [
                    P.indexOf(0)
                ];
                else if (k !== g) {
                    for(p = u.decodePixels(), m = new Uint8Array(p.length), w = 0, g = p.length; w < g; w++)m[w] = P[p[w]];
                    d = n(m, u.width, 1);
                }
            }
            var I = function(e) {
                var r;
                switch(e){
                    case t.image_compression.FAST:
                        r = 11;
                        break;
                    case t.image_compression.MEDIUM:
                        r = 13;
                        break;
                    case t.image_compression.SLOW:
                        r = 14;
                        break;
                    default:
                        r = 12;
                }
                return r;
            }(o);
            return L === this.decode.FLATE_DECODE && (A = "/Predictor " + I + " "), A += "/Colors " + l + " /BitsPerComponent " + c + " /Columns " + u.width, (this.__addimage__.isArrayBuffer(e) || this.__addimage__.isArrayBufferView(e)) && (e = this.__addimage__.arrayBufferToBinaryString(e)), (d && this.__addimage__.isArrayBuffer(d) || this.__addimage__.isArrayBufferView(d)) && (d = this.__addimage__.arrayBufferToBinaryString(d)), {
                alias: a,
                data: e,
                index: i,
                filter: L,
                decodeParameters: A,
                transparency: h,
                palette: f,
                sMask: d,
                predictor: I,
                width: u.width,
                height: u.height,
                bitsPerComponent: c,
                colorSpace: s
            };
        }
    };
}(E.API), function(t) {
    t.processGIF89A = function(e, r, n, i) {
        var a = new Zt(e), o = a.width, s = a.height, c = [];
        a.decodeAndBlitFrameRGBA(0, c);
        var u = {
            data: c,
            width: o,
            height: s
        }, h = new Qt(100).encode(u, 100);
        return t.processJPEG.call(this, h, r, n, i);
    }, t.processGIF87A = t.processGIF89A;
}(E.API), te.prototype.parseHeader = function() {
    if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
        var t = 0 === this.colors ? 1 << this.bitPP : this.colors;
        this.palette = new Array(t);
        for(var e = 0; e < t; e++){
            var r = this.datav.getUint8(this.pos++, !0), n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), a = this.datav.getUint8(this.pos++, !0);
            this.palette[e] = {
                red: i,
                green: n,
                blue: r,
                quad: a
            };
        }
    }
    this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, te.prototype.parseBGR = function() {
    this.pos = this.offset;
    try {
        var t = "bit" + this.bitPP, e = this.width * this.height * 4;
        this.data = new Uint8Array(e), this[t]();
    } catch (t) {
        a.log("bit decode error:" + t);
    }
}, te.prototype.bit1 = function() {
    var t, e = Math.ceil(this.width / 8), r = e % 4;
    for(t = this.height - 1; t >= 0; t--){
        for(var n = this.bottom_up ? t : this.height - 1 - t, i = 0; i < e; i++)for(var a = this.datav.getUint8(this.pos++, !0), o = n * this.width * 4 + 8 * i * 4, s = 0; s < 8 && 8 * i + s < this.width; s++){
            var c = this.palette[a >> 7 - s & 1];
            this.data[o + 4 * s] = c.blue, this.data[o + 4 * s + 1] = c.green, this.data[o + 4 * s + 2] = c.red, this.data[o + 4 * s + 3] = 255;
        }
        0 !== r && (this.pos += 4 - r);
    }
}, te.prototype.bit4 = function() {
    for(var t = Math.ceil(this.width / 2), e = t % 4, r = this.height - 1; r >= 0; r--){
        for(var n = this.bottom_up ? r : this.height - 1 - r, i = 0; i < t; i++){
            var a = this.datav.getUint8(this.pos++, !0), o = n * this.width * 4 + 2 * i * 4, s = a >> 4, c = 15 & a, u = this.palette[s];
            if (this.data[o] = u.blue, this.data[o + 1] = u.green, this.data[o + 2] = u.red, this.data[o + 3] = 255, 2 * i + 1 >= this.width) break;
            u = this.palette[c], this.data[o + 4] = u.blue, this.data[o + 4 + 1] = u.green, this.data[o + 4 + 2] = u.red, this.data[o + 4 + 3] = 255;
        }
        0 !== e && (this.pos += 4 - e);
    }
}, te.prototype.bit8 = function() {
    for(var t = this.width % 4, e = this.height - 1; e >= 0; e--){
        for(var r = this.bottom_up ? e : this.height - 1 - e, n = 0; n < this.width; n++){
            var i = this.datav.getUint8(this.pos++, !0), a = r * this.width * 4 + 4 * n;
            if (i < this.palette.length) {
                var o = this.palette[i];
                this.data[a] = o.red, this.data[a + 1] = o.green, this.data[a + 2] = o.blue, this.data[a + 3] = 255;
            } else this.data[a] = 255, this.data[a + 1] = 255, this.data[a + 2] = 255, this.data[a + 3] = 255;
        }
        0 !== t && (this.pos += 4 - t);
    }
}, te.prototype.bit15 = function() {
    for(var t = this.width % 3, e = parseInt("11111", 2), r = this.height - 1; r >= 0; r--){
        for(var n = this.bottom_up ? r : this.height - 1 - r, i = 0; i < this.width; i++){
            var a = this.datav.getUint16(this.pos, !0);
            this.pos += 2;
            var o = (a & e) / e * 255 | 0, s = (a >> 5 & e) / e * 255 | 0, c = (a >> 10 & e) / e * 255 | 0, u = a >> 15 ? 255 : 0, h = n * this.width * 4 + 4 * i;
            this.data[h] = c, this.data[h + 1] = s, this.data[h + 2] = o, this.data[h + 3] = u;
        }
        this.pos += t;
    }
}, te.prototype.bit16 = function() {
    for(var t = this.width % 3, e = parseInt("11111", 2), r = parseInt("111111", 2), n = this.height - 1; n >= 0; n--){
        for(var i = this.bottom_up ? n : this.height - 1 - n, a = 0; a < this.width; a++){
            var o = this.datav.getUint16(this.pos, !0);
            this.pos += 2;
            var s = (o & e) / e * 255 | 0, c = (o >> 5 & r) / r * 255 | 0, u = (o >> 11) / e * 255 | 0, h = i * this.width * 4 + 4 * a;
            this.data[h] = u, this.data[h + 1] = c, this.data[h + 2] = s, this.data[h + 3] = 255;
        }
        this.pos += t;
    }
}, te.prototype.bit24 = function() {
    for(var t = this.height - 1; t >= 0; t--){
        for(var e = this.bottom_up ? t : this.height - 1 - t, r = 0; r < this.width; r++){
            var n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), a = this.datav.getUint8(this.pos++, !0), o = e * this.width * 4 + 4 * r;
            this.data[o] = a, this.data[o + 1] = i, this.data[o + 2] = n, this.data[o + 3] = 255;
        }
        this.pos += this.width % 4;
    }
}, te.prototype.bit32 = function() {
    for(var t = this.height - 1; t >= 0; t--)for(var e = this.bottom_up ? t : this.height - 1 - t, r = 0; r < this.width; r++){
        var n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), a = this.datav.getUint8(this.pos++, !0), o = this.datav.getUint8(this.pos++, !0), s = e * this.width * 4 + 4 * r;
        this.data[s] = a, this.data[s + 1] = i, this.data[s + 2] = n, this.data[s + 3] = o;
    }
}, te.prototype.getData = function() {
    return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    t.processBMP = function(e, r, n, i) {
        var a = new te(e, !1), o = a.width, s = a.height, c = {
            data: a.getData(),
            width: o,
            height: s
        }, u = new Qt(100).encode(c, 100);
        return t.processJPEG.call(this, u, r, n, i);
    };
}(E.API), ee.prototype.getData = function() {
    return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    t.processWEBP = function(e, r, n, i) {
        var a = new ee(e, !1), o = a.width, s = a.height, c = {
            data: a.getData(),
            width: o,
            height: s
        }, u = new Qt(100).encode(c, 100);
        return t.processJPEG.call(this, u, r, n, i);
    };
}(E.API), E.API.processRGBA = function(t, e, r) {
    for(var n = t.data, i = n.length, a = new Uint8Array(i / 4 * 3), o = new Uint8Array(i / 4), s = 0, c = 0, u = 0; u < i; u += 4){
        var h = n[u], l = n[u + 1], f = n[u + 2], d = n[u + 3];
        a[s++] = h, a[s++] = l, a[s++] = f, o[c++] = d;
    }
    var p = this.__addimage__.arrayBufferToBinaryString(a);
    return {
        alpha: this.__addimage__.arrayBufferToBinaryString(o),
        data: p,
        index: e,
        alias: r,
        colorSpace: "DeviceRGB",
        bitsPerComponent: 8,
        width: t.width,
        height: t.height
    };
}, E.API.setLanguage = function(t) {
    return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), void 0 !== ({
        af: "Afrikaans",
        sq: "Albanian",
        ar: "Arabic (Standard)",
        "ar-DZ": "Arabic (Algeria)",
        "ar-BH": "Arabic (Bahrain)",
        "ar-EG": "Arabic (Egypt)",
        "ar-IQ": "Arabic (Iraq)",
        "ar-JO": "Arabic (Jordan)",
        "ar-KW": "Arabic (Kuwait)",
        "ar-LB": "Arabic (Lebanon)",
        "ar-LY": "Arabic (Libya)",
        "ar-MA": "Arabic (Morocco)",
        "ar-OM": "Arabic (Oman)",
        "ar-QA": "Arabic (Qatar)",
        "ar-SA": "Arabic (Saudi Arabia)",
        "ar-SY": "Arabic (Syria)",
        "ar-TN": "Arabic (Tunisia)",
        "ar-AE": "Arabic (U.A.E.)",
        "ar-YE": "Arabic (Yemen)",
        an: "Aragonese",
        hy: "Armenian",
        as: "Assamese",
        ast: "Asturian",
        az: "Azerbaijani",
        eu: "Basque",
        be: "Belarusian",
        bn: "Bengali",
        bs: "Bosnian",
        br: "Breton",
        bg: "Bulgarian",
        my: "Burmese",
        ca: "Catalan",
        ch: "Chamorro",
        ce: "Chechen",
        zh: "Chinese",
        "zh-HK": "Chinese (Hong Kong)",
        "zh-CN": "Chinese (PRC)",
        "zh-SG": "Chinese (Singapore)",
        "zh-TW": "Chinese (Taiwan)",
        cv: "Chuvash",
        co: "Corsican",
        cr: "Cree",
        hr: "Croatian",
        cs: "Czech",
        da: "Danish",
        nl: "Dutch (Standard)",
        "nl-BE": "Dutch (Belgian)",
        en: "English",
        "en-AU": "English (Australia)",
        "en-BZ": "English (Belize)",
        "en-CA": "English (Canada)",
        "en-IE": "English (Ireland)",
        "en-JM": "English (Jamaica)",
        "en-NZ": "English (New Zealand)",
        "en-PH": "English (Philippines)",
        "en-ZA": "English (South Africa)",
        "en-TT": "English (Trinidad & Tobago)",
        "en-GB": "English (United Kingdom)",
        "en-US": "English (United States)",
        "en-ZW": "English (Zimbabwe)",
        eo: "Esperanto",
        et: "Estonian",
        fo: "Faeroese",
        fj: "Fijian",
        fi: "Finnish",
        fr: "French (Standard)",
        "fr-BE": "French (Belgium)",
        "fr-CA": "French (Canada)",
        "fr-FR": "French (France)",
        "fr-LU": "French (Luxembourg)",
        "fr-MC": "French (Monaco)",
        "fr-CH": "French (Switzerland)",
        fy: "Frisian",
        fur: "Friulian",
        gd: "Gaelic (Scots)",
        "gd-IE": "Gaelic (Irish)",
        gl: "Galacian",
        ka: "Georgian",
        de: "German (Standard)",
        "de-AT": "German (Austria)",
        "de-DE": "German (Germany)",
        "de-LI": "German (Liechtenstein)",
        "de-LU": "German (Luxembourg)",
        "de-CH": "German (Switzerland)",
        el: "Greek",
        gu: "Gujurati",
        ht: "Haitian",
        he: "Hebrew",
        hi: "Hindi",
        hu: "Hungarian",
        is: "Icelandic",
        id: "Indonesian",
        iu: "Inuktitut",
        ga: "Irish",
        it: "Italian (Standard)",
        "it-CH": "Italian (Switzerland)",
        ja: "Japanese",
        kn: "Kannada",
        ks: "Kashmiri",
        kk: "Kazakh",
        km: "Khmer",
        ky: "Kirghiz",
        tlh: "Klingon",
        ko: "Korean",
        "ko-KP": "Korean (North Korea)",
        "ko-KR": "Korean (South Korea)",
        la: "Latin",
        lv: "Latvian",
        lt: "Lithuanian",
        lb: "Luxembourgish",
        mk: "North Macedonia",
        ms: "Malay",
        ml: "Malayalam",
        mt: "Maltese",
        mi: "Maori",
        mr: "Marathi",
        mo: "Moldavian",
        nv: "Navajo",
        ng: "Ndonga",
        ne: "Nepali",
        no: "Norwegian",
        nb: "Norwegian (Bokmal)",
        nn: "Norwegian (Nynorsk)",
        oc: "Occitan",
        or: "Oriya",
        om: "Oromo",
        fa: "Persian",
        "fa-IR": "Persian/Iran",
        pl: "Polish",
        pt: "Portuguese",
        "pt-BR": "Portuguese (Brazil)",
        pa: "Punjabi",
        "pa-IN": "Punjabi (India)",
        "pa-PK": "Punjabi (Pakistan)",
        qu: "Quechua",
        rm: "Rhaeto-Romanic",
        ro: "Romanian",
        "ro-MO": "Romanian (Moldavia)",
        ru: "Russian",
        "ru-MO": "Russian (Moldavia)",
        sz: "Sami (Lappish)",
        sg: "Sango",
        sa: "Sanskrit",
        sc: "Sardinian",
        sd: "Sindhi",
        si: "Singhalese",
        sr: "Serbian",
        sk: "Slovak",
        sl: "Slovenian",
        so: "Somani",
        sb: "Sorbian",
        es: "Spanish",
        "es-AR": "Spanish (Argentina)",
        "es-BO": "Spanish (Bolivia)",
        "es-CL": "Spanish (Chile)",
        "es-CO": "Spanish (Colombia)",
        "es-CR": "Spanish (Costa Rica)",
        "es-DO": "Spanish (Dominican Republic)",
        "es-EC": "Spanish (Ecuador)",
        "es-SV": "Spanish (El Salvador)",
        "es-GT": "Spanish (Guatemala)",
        "es-HN": "Spanish (Honduras)",
        "es-MX": "Spanish (Mexico)",
        "es-NI": "Spanish (Nicaragua)",
        "es-PA": "Spanish (Panama)",
        "es-PY": "Spanish (Paraguay)",
        "es-PE": "Spanish (Peru)",
        "es-PR": "Spanish (Puerto Rico)",
        "es-ES": "Spanish (Spain)",
        "es-UY": "Spanish (Uruguay)",
        "es-VE": "Spanish (Venezuela)",
        sx: "Sutu",
        sw: "Swahili",
        sv: "Swedish",
        "sv-FI": "Swedish (Finland)",
        "sv-SV": "Swedish (Sweden)",
        ta: "Tamil",
        tt: "Tatar",
        te: "Teluga",
        th: "Thai",
        tig: "Tigre",
        ts: "Tsonga",
        tn: "Tswana",
        tr: "Turkish",
        tk: "Turkmen",
        uk: "Ukrainian",
        hsb: "Upper Sorbian",
        ur: "Urdu",
        ve: "Venda",
        vi: "Vietnamese",
        vo: "Volapuk",
        wa: "Walloon",
        cy: "Welsh",
        xh: "Xhosa",
        ji: "Yiddish",
        zu: "Zulu"
    })[t] && (this.internal.languageSettings.languageCode = t, !1 === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
        this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
    }), this.internal.languageSettings.isSubscribed = !0)), this;
}, Vt = E.API, Gt = Vt.getCharWidthsArray = function(e, r) {
    var n, i, a = (r = r || {}).font || this.internal.getFont(), o = r.fontSize || this.internal.getFontSize(), s = r.charSpace || this.internal.getCharSpace(), c = r.widths ? r.widths : a.metadata.Unicode.widths, u = c.fof ? c.fof : 1, h = r.kerning ? r.kerning : a.metadata.Unicode.kerning, l = h.fof ? h.fof : 1, f = !1 !== r.doKerning, d = 0, p = e.length, g = 0, m = c[0] || u, v = [];
    for(n = 0; n < p; n++)i = e.charCodeAt(n), "function" == typeof a.metadata.widthOfString ? v.push((a.metadata.widthOfGlyph(a.metadata.characterToGlyph(i)) + s * (1e3 / o) || 0) / 1e3) : (d = f && "object" === (0, _typeofDefault.default)(h[i]) && !isNaN(parseInt(h[i][g], 10)) ? h[i][g] / l : 0, v.push((c[i] || m) / u + d)), g = i;
    return v;
}, Yt = Vt.getStringUnitWidth = function(t, e) {
    var r = (e = e || {}).fontSize || this.internal.getFontSize(), n = e.font || this.internal.getFont(), i = e.charSpace || this.internal.getCharSpace();
    return Vt.processArabic && (t = Vt.processArabic(t)), "function" == typeof n.metadata.widthOfString ? n.metadata.widthOfString(t, r, i) / r : Gt.apply(this, arguments).reduce(function(t, e) {
        return t + e;
    }, 0);
}, Jt = function(t, e, r, n) {
    for(var i = [], a = 0, o = t.length, s = 0; a !== o && s + e[a] < r;)s += e[a], a++;
    i.push(t.slice(0, a));
    var c = a;
    for(s = 0; a !== o;)s + e[a] > n && (i.push(t.slice(c, a)), s = 0, c = a), s += e[a], a++;
    return c !== a && i.push(t.slice(c, a)), i;
}, Xt = function(t, e, r) {
    r || (r = {});
    var n, i, a, o, s, c, u, h = [], l = [
        h
    ], f = r.textIndent || 0, d = 0, p = 0, g = t.split(" "), m = Gt.apply(this, [
        " ",
        r
    ])[0];
    if (c = -1 === r.lineIndent ? g[0].length + 2 : r.lineIndent || 0) {
        var v = Array(c).join(" "), b = [];
        g.map(function(t) {
            (t = t.split(/\s*\n/)).length > 1 ? b = b.concat(t.map(function(t, e) {
                return (e && t.length ? "\n" : "") + t;
            })) : b.push(t[0]);
        }), g = b, c = Yt.apply(this, [
            v,
            r
        ]);
    }
    for(a = 0, o = g.length; a < o; a++){
        var y = 0;
        if (n = g[a], c && "\n" == n[0] && (n = n.substr(1), y = 1), f + d + (p = (i = Gt.apply(this, [
            n,
            r
        ])).reduce(function(t, e) {
            return t + e;
        }, 0)) > e || y) {
            if (p > e) {
                for(s = Jt.apply(this, [
                    n,
                    i,
                    e - (f + d),
                    e
                ]), h.push(s.shift()), h = [
                    s.pop()
                ]; s.length;)l.push([
                    s.shift()
                ]);
                p = i.slice(n.length - (h[0] ? h[0].length : 0)).reduce(function(t, e) {
                    return t + e;
                }, 0);
            } else h = [
                n
            ];
            l.push(h), f = p + c, d = m;
        } else h.push(n), f += d + p, d = m;
    }
    return u = c ? function(t, e) {
        return (e ? v : "") + t.join(" ");
    } : function(t) {
        return t.join(" ");
    }, l.map(u);
}, Vt.splitTextToSize = function(t, e, r) {
    var n, i = (r = r || {}).fontSize || this.internal.getFontSize(), a = (function(t) {
        if (t.widths && t.kerning) return {
            widths: t.widths,
            kerning: t.kerning
        };
        var e = this.internal.getFont(t.fontName, t.fontStyle);
        return e.metadata.Unicode ? {
            widths: e.metadata.Unicode.widths || {
                0: 1
            },
            kerning: e.metadata.Unicode.kerning || {}
        } : {
            font: e.metadata,
            fontSize: this.internal.getFontSize(),
            charSpace: this.internal.getCharSpace()
        };
    }).call(this, r);
    n = Array.isArray(t) ? t : String(t).split(/\r?\n/);
    var o = 1 * this.internal.scaleFactor * e / i;
    a.textIndent = r.textIndent ? 1 * r.textIndent * this.internal.scaleFactor / i : 0, a.lineIndent = r.lineIndent;
    var s, c, u = [];
    for(s = 0, c = n.length; s < c; s++)u = u.concat(Xt.apply(this, [
        n[s],
        o,
        a
    ]));
    return u;
}, function(e) {
    e.__fontmetrics__ = e.__fontmetrics__ || {};
    for(var r = "klmnopqrstuvwxyz", n = {}, i = {}, a = 0; a < r.length; a++)n[r[a]] = "0123456789abcdef"[a], i["0123456789abcdef"[a]] = r[a];
    var o = function(t) {
        return "0x" + parseInt(t, 10).toString(16);
    }, s = e.__fontmetrics__.compress = function(e) {
        var r, n, a, c, u = [
            "{"
        ];
        for(var h in e){
            if (r = e[h], isNaN(parseInt(h, 10)) ? n = "'" + h + "'" : (h = parseInt(h, 10), n = (n = o(h).slice(2)).slice(0, -1) + i[n.slice(-1)]), "number" == typeof r) r < 0 ? (a = o(r).slice(3), c = "-") : (a = o(r).slice(2), c = ""), a = c + a.slice(0, -1) + i[a.slice(-1)];
            else {
                if ("object" !== (0, _typeofDefault.default)(r)) throw new Error("Don't know what to do with value type " + (0, _typeofDefault.default)(r) + ".");
                a = s(r);
            }
            u.push(n + a);
        }
        return u.push("}"), u.join("");
    }, c = e.__fontmetrics__.uncompress = function(t) {
        if ("string" != typeof t) throw new Error("Invalid argument passed to uncompress.");
        for(var e, r, i, a, o = {}, s = 1, c = o, u = [], h = "", l = "", f = t.length - 1, d = 1; d < f; d += 1)"'" == (a = t[d]) ? e ? (i = e.join(""), e = void 0) : e = [] : e ? e.push(a) : "{" == a ? (u.push([
            c,
            i
        ]), c = {}, i = void 0) : "}" == a ? ((r = u.pop())[0][r[1]] = c, i = void 0, c = r[0]) : "-" == a ? s = -1 : void 0 === i ? n.hasOwnProperty(a) ? (h += n[a], i = parseInt(h, 16) * s, s = 1, h = "") : h += a : n.hasOwnProperty(a) ? (l += n[a], c[i] = parseInt(l, 16) * s, s = 1, i = void 0, l = "") : l += a;
        return o;
    }, u = {
        codePages: [
            "WinAnsiEncoding"
        ],
        WinAnsiEncoding: c("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
    }, h = {
        Unicode: {
            Courier: u,
            "Courier-Bold": u,
            "Courier-BoldOblique": u,
            "Courier-Oblique": u,
            Helvetica: u,
            "Helvetica-Bold": u,
            "Helvetica-BoldOblique": u,
            "Helvetica-Oblique": u,
            "Times-Roman": u,
            "Times-Bold": u,
            "Times-BoldItalic": u,
            "Times-Italic": u
        }
    }, l = {
        Unicode: {
            "Courier-Oblique": c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
            "Times-BoldItalic": c("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),
            "Helvetica-Bold": c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
            Courier: c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
            "Courier-BoldOblique": c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
            "Times-Bold": c("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),
            Symbol: c("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"),
            Helvetica: c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),
            "Helvetica-BoldOblique": c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
            ZapfDingbats: c("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"),
            "Courier-Bold": c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
            "Times-Italic": c("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),
            "Times-Roman": c("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),
            "Helvetica-Oblique": c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
        }
    };
    e.events.push([
        "addFont",
        function(t) {
            var e = t.font, r = l.Unicode[e.postScriptName];
            r && (e.metadata.Unicode = {}, e.metadata.Unicode.widths = r.widths, e.metadata.Unicode.kerning = r.kerning);
            var n = h.Unicode[e.postScriptName];
            n && (e.metadata.Unicode.encoding = n, e.encoding = n.codePages[0]);
        }
    ]);
}(E.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    var e = function(t) {
        for(var e = t.length, r = new Uint8Array(e), n = 0; n < e; n++)r[n] = t.charCodeAt(n);
        return r;
    };
    t.API.events.push([
        "addFont",
        function(r) {
            var n = void 0, i = r.font, a = r.instance;
            if (!i.isStandardFont) {
                if (void 0 === a) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
                if ("string" != typeof (n = !1 === a.existsFileInVFS(i.postScriptName) ? a.loadFile(i.postScriptName) : a.getFileFromVFS(i.postScriptName))) throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
                !function(r, n) {
                    n = /^\x00\x01\x00\x00/.test(n) ? e(n) : e(u(n)), r.metadata = t.API.TTFFont.open(n), r.metadata.Unicode = r.metadata.Unicode || {
                        encoding: {},
                        kerning: {},
                        widths: []
                    }, r.metadata.glyIdsUsed = [
                        0
                    ];
                }(i, n);
            }
        }
    ]);
}(E), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */ function(t) {
    function e() {
        return (n.canvg ? Promise.resolve(n.canvg) : require("7ec43201f0dbcdb8")).catch(function(t) {
            return Promise.reject(new Error("Could not load canvg: " + t));
        }).then(function(t) {
            return t.default ? t.default : t;
        });
    }
    E.API.addSvgAsImage = function(t, r, n, i, o, s, c, u) {
        if (isNaN(r) || isNaN(n)) throw a.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
        if (isNaN(i) || isNaN(o)) throw a.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
        var h = document.createElement("canvas");
        h.width = i, h.height = o;
        var l = h.getContext("2d");
        l.fillStyle = "#fff", l.fillRect(0, 0, h.width, h.height);
        var f = {
            ignoreMouse: !0,
            ignoreAnimation: !0,
            ignoreDimensions: !0
        }, d = this;
        return e().then(function(e) {
            return e.fromString(l, t, f);
        }, function() {
            return Promise.reject(new Error("Could not load canvg."));
        }).then(function(t) {
            return t.render(f);
        }).then(function() {
            d.addImage(h.toDataURL("image/jpeg", 1), r, n, i, o, c, u);
        });
    };
}(), E.API.putTotalPages = function(t) {
    var e, r = 0;
    parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(t, "g"), r = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(t, this.internal.getFont()), "g"), r = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
    for(var n = 1; n <= this.internal.getNumberOfPages(); n++)for(var i = 0; i < this.internal.pages[n].length; i++)this.internal.pages[n][i] = this.internal.pages[n][i].replace(e, r);
    return this;
}, E.API.viewerPreferences = function(e, r) {
    var n;
    e = e || {}, r = r || !1;
    var i, a, o, s = {
        HideToolbar: {
            defaultValue: !1,
            value: !1,
            type: "boolean",
            explicitSet: !1,
            valueSet: [
                !0,
                !1
            ],
            pdfVersion: 1.3
        },
        HideMenubar: {
            defaultValue: !1,
            value: !1,
            type: "boolean",
            explicitSet: !1,
            valueSet: [
                !0,
                !1
            ],
            pdfVersion: 1.3
        },
        HideWindowUI: {
            defaultValue: !1,
            value: !1,
            type: "boolean",
            explicitSet: !1,
            valueSet: [
                !0,
                !1
            ],
            pdfVersion: 1.3
        },
        FitWindow: {
            defaultValue: !1,
            value: !1,
            type: "boolean",
            explicitSet: !1,
            valueSet: [
                !0,
                !1
            ],
            pdfVersion: 1.3
        },
        CenterWindow: {
            defaultValue: !1,
            value: !1,
            type: "boolean",
            explicitSet: !1,
            valueSet: [
                !0,
                !1
            ],
            pdfVersion: 1.3
        },
        DisplayDocTitle: {
            defaultValue: !1,
            value: !1,
            type: "boolean",
            explicitSet: !1,
            valueSet: [
                !0,
                !1
            ],
            pdfVersion: 1.4
        },
        NonFullScreenPageMode: {
            defaultValue: "UseNone",
            value: "UseNone",
            type: "name",
            explicitSet: !1,
            valueSet: [
                "UseNone",
                "UseOutlines",
                "UseThumbs",
                "UseOC"
            ],
            pdfVersion: 1.3
        },
        Direction: {
            defaultValue: "L2R",
            value: "L2R",
            type: "name",
            explicitSet: !1,
            valueSet: [
                "L2R",
                "R2L"
            ],
            pdfVersion: 1.3
        },
        ViewArea: {
            defaultValue: "CropBox",
            value: "CropBox",
            type: "name",
            explicitSet: !1,
            valueSet: [
                "MediaBox",
                "CropBox",
                "TrimBox",
                "BleedBox",
                "ArtBox"
            ],
            pdfVersion: 1.4
        },
        ViewClip: {
            defaultValue: "CropBox",
            value: "CropBox",
            type: "name",
            explicitSet: !1,
            valueSet: [
                "MediaBox",
                "CropBox",
                "TrimBox",
                "BleedBox",
                "ArtBox"
            ],
            pdfVersion: 1.4
        },
        PrintArea: {
            defaultValue: "CropBox",
            value: "CropBox",
            type: "name",
            explicitSet: !1,
            valueSet: [
                "MediaBox",
                "CropBox",
                "TrimBox",
                "BleedBox",
                "ArtBox"
            ],
            pdfVersion: 1.4
        },
        PrintClip: {
            defaultValue: "CropBox",
            value: "CropBox",
            type: "name",
            explicitSet: !1,
            valueSet: [
                "MediaBox",
                "CropBox",
                "TrimBox",
                "BleedBox",
                "ArtBox"
            ],
            pdfVersion: 1.4
        },
        PrintScaling: {
            defaultValue: "AppDefault",
            value: "AppDefault",
            type: "name",
            explicitSet: !1,
            valueSet: [
                "AppDefault",
                "None"
            ],
            pdfVersion: 1.6
        },
        Duplex: {
            defaultValue: "",
            value: "none",
            type: "name",
            explicitSet: !1,
            valueSet: [
                "Simplex",
                "DuplexFlipShortEdge",
                "DuplexFlipLongEdge",
                "none"
            ],
            pdfVersion: 1.7
        },
        PickTrayByPDFSize: {
            defaultValue: !1,
            value: !1,
            type: "boolean",
            explicitSet: !1,
            valueSet: [
                !0,
                !1
            ],
            pdfVersion: 1.7
        },
        PrintPageRange: {
            defaultValue: "",
            value: "",
            type: "array",
            explicitSet: !1,
            valueSet: null,
            pdfVersion: 1.7
        },
        NumCopies: {
            defaultValue: 1,
            value: 1,
            type: "integer",
            explicitSet: !1,
            valueSet: null,
            pdfVersion: 1.7
        }
    }, c = Object.keys(s), u = [], h = 0, l = 0, f = 0;
    function d(t, e) {
        var r, n = !1;
        for(r = 0; r < t.length; r += 1)t[r] === e && (n = !0);
        return n;
    }
    if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s)), this.internal.viewerpreferences.isSubscribed = !1), n = this.internal.viewerpreferences.configuration, "reset" === e || !0 === r) {
        var p = c.length;
        for(f = 0; f < p; f += 1)n[c[f]].value = n[c[f]].defaultValue, n[c[f]].explicitSet = !1;
    }
    if ("object" === (0, _typeofDefault.default)(e)) {
        for(a in e)if (o = e[a], d(c, a) && void 0 !== o) {
            if ("boolean" === n[a].type && "boolean" == typeof o) n[a].value = o;
            else if ("name" === n[a].type && d(n[a].valueSet, o)) n[a].value = o;
            else if ("integer" === n[a].type && Number.isInteger(o)) n[a].value = o;
            else if ("array" === n[a].type) {
                for(h = 0; h < o.length; h += 1)if (i = !0, 1 === o[h].length && "number" == typeof o[h][0]) u.push(String(o[h] - 1));
                else if (o[h].length > 1) {
                    for(l = 0; l < o[h].length; l += 1)"number" != typeof o[h][l] && (i = !1);
                    !0 === i && u.push([
                        o[h][0] - 1,
                        o[h][1] - 1
                    ].join(" "));
                }
                n[a].value = "[" + u.join(" ") + "]";
            } else n[a].value = n[a].defaultValue;
            n[a].explicitSet = !0;
        }
    }
    return !1 === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
        var t, e = [];
        for(t in n)!0 === n[t].explicitSet && ("name" === n[t].type ? e.push("/" + t + " /" + n[t].value) : e.push("/" + t + " " + n[t].value));
        0 !== e.length && this.internal.write("/ViewerPreferences\n<<\n" + e.join("\n") + "\n>>");
    }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = n, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */ function(t) {
    var e = function() {
        var t = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r = unescape(encodeURIComponent(t)), n = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a = unescape(encodeURIComponent("</x:xmpmeta>")), o = r.length + n.length + i.length + e.length + a.length;
        this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o + " >>"), this.internal.write("stream"), this.internal.write(e + r + n + i + a), this.internal.write("endstream"), this.internal.write("endobj");
    }, r = function() {
        this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
    };
    t.addMetadata = function(t, n) {
        return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = {
            metadata: t,
            namespaceuri: n || "http://jspdf.default.namespaceuri/"
        }, this.internal.events.subscribe("putCatalog", r), this.internal.events.subscribe("postPutResources", e)), this;
    };
}(E.API), function(t) {
    var e = t.API, r = e.pdfEscape16 = function(t, e) {
        for(var r, n = e.metadata.Unicode.widths, i = [
            "",
            "0",
            "00",
            "000",
            "0000"
        ], a = [
            ""
        ], o = 0, s = t.length; o < s; ++o){
            if (r = e.metadata.characterToGlyph(t.charCodeAt(o)), e.metadata.glyIdsUsed.push(r), e.metadata.toUnicode[r] = t.charCodeAt(o), -1 == n.indexOf(r) && (n.push(r), n.push([
                parseInt(e.metadata.widthOfGlyph(r), 10)
            ])), "0" == r) return a.join("");
            r = r.toString(16), a.push(i[4 - r.length], r);
        }
        return a.join("");
    }, n = function(t) {
        var e, r, n, i, a, o, s;
        for(a = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n = [], o = 0, s = (r = Object.keys(t).sort(function(t, e) {
            return t - e;
        })).length; o < s; o++)e = r[o], n.length >= 100 && (a += "\n" + n.length + " beginbfchar\n" + n.join("\n") + "\nendbfchar", n = []), void 0 !== t[e] && null !== t[e] && "function" == typeof t[e].toString && (i = ("0000" + t[e].toString(16)).slice(-4), e = ("0000" + (+e).toString(16)).slice(-4), n.push("<" + e + "><" + i + ">"));
        return n.length && (a += "\n" + n.length + " beginbfchar\n" + n.join("\n") + "\nendbfchar\n"), a += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    };
    e.events.push([
        "putFont",
        function(e) {
            !function(e) {
                var r = e.font, i = e.out, a = e.newObject, o = e.putStream;
                if (r.metadata instanceof t.API.TTFFont && "Identity-H" === r.encoding) {
                    for(var s = r.metadata.Unicode.widths, c = r.metadata.subset.encode(r.metadata.glyIdsUsed, 1), u = "", h = 0; h < c.length; h++)u += String.fromCharCode(c[h]);
                    var l = a();
                    o({
                        data: u,
                        addLength1: !0,
                        objectId: l
                    }), i("endobj");
                    var f = a();
                    o({
                        data: n(r.metadata.toUnicode),
                        addLength1: !0,
                        objectId: f
                    }), i("endobj");
                    var d = a();
                    i("<<"), i("/Type /FontDescriptor"), i("/FontName /" + F(r.fontName)), i("/FontFile2 " + l + " 0 R"), i("/FontBBox " + t.API.PDFObject.convert(r.metadata.bbox)), i("/Flags " + r.metadata.flags), i("/StemV " + r.metadata.stemV), i("/ItalicAngle " + r.metadata.italicAngle), i("/Ascent " + r.metadata.ascender), i("/Descent " + r.metadata.decender), i("/CapHeight " + r.metadata.capHeight), i(">>"), i("endobj");
                    var p = a();
                    i("<<"), i("/Type /Font"), i("/BaseFont /" + F(r.fontName)), i("/FontDescriptor " + d + " 0 R"), i("/W " + t.API.PDFObject.convert(s)), i("/CIDToGIDMap /Identity"), i("/DW 1000"), i("/Subtype /CIDFontType2"), i("/CIDSystemInfo"), i("<<"), i("/Supplement 0"), i("/Registry (Adobe)"), i("/Ordering (" + r.encoding + ")"), i(">>"), i(">>"), i("endobj"), r.objectNumber = a(), i("<<"), i("/Type /Font"), i("/Subtype /Type0"), i("/ToUnicode " + f + " 0 R"), i("/BaseFont /" + F(r.fontName)), i("/Encoding /" + r.encoding), i("/DescendantFonts [" + p + " 0 R]"), i(">>"), i("endobj"), r.isAlreadyPutted = !0;
                }
            }(e);
        }
    ]);
    e.events.push([
        "putFont",
        function(e) {
            !function(e) {
                var r = e.font, i = e.out, a = e.newObject, o = e.putStream;
                if (r.metadata instanceof t.API.TTFFont && "WinAnsiEncoding" === r.encoding) {
                    for(var s = r.metadata.rawData, c = "", u = 0; u < s.length; u++)c += String.fromCharCode(s[u]);
                    var h = a();
                    o({
                        data: c,
                        addLength1: !0,
                        objectId: h
                    }), i("endobj");
                    var l = a();
                    o({
                        data: n(r.metadata.toUnicode),
                        addLength1: !0,
                        objectId: l
                    }), i("endobj");
                    var f = a();
                    i("<<"), i("/Descent " + r.metadata.decender), i("/CapHeight " + r.metadata.capHeight), i("/StemV " + r.metadata.stemV), i("/Type /FontDescriptor"), i("/FontFile2 " + h + " 0 R"), i("/Flags 96"), i("/FontBBox " + t.API.PDFObject.convert(r.metadata.bbox)), i("/FontName /" + F(r.fontName)), i("/ItalicAngle " + r.metadata.italicAngle), i("/Ascent " + r.metadata.ascender), i(">>"), i("endobj"), r.objectNumber = a();
                    for(var d = 0; d < r.metadata.hmtx.widths.length; d++)r.metadata.hmtx.widths[d] = parseInt(r.metadata.hmtx.widths[d] * (1e3 / r.metadata.head.unitsPerEm));
                    i("<</Subtype/TrueType/Type/Font/ToUnicode " + l + " 0 R/BaseFont/" + F(r.fontName) + "/FontDescriptor " + f + " 0 R/Encoding/" + r.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t.API.PDFObject.convert(r.metadata.hmtx.widths) + ">>"), i("endobj"), r.isAlreadyPutted = !0;
                }
            }(e);
        }
    ]);
    var i = function(t) {
        var e, n = t.text || "", i = t.x, a = t.y, o = t.options || {}, s = t.mutex || {}, c = s.pdfEscape, u = s.activeFontKey, h = s.fonts, l = u, f = "", d = 0, p = "", g = h[l].encoding;
        if ("Identity-H" !== h[l].encoding) return {
            text: n,
            x: i,
            y: a,
            options: o,
            mutex: s
        };
        for(p = n, l = u, Array.isArray(n) && (p = n[0]), d = 0; d < p.length; d += 1)h[l].metadata.hasOwnProperty("cmap") && (e = h[l].metadata.cmap.unicode.codeMap[p[d].charCodeAt(0)]), e || p[d].charCodeAt(0) < 256 && h[l].metadata.hasOwnProperty("Unicode") ? f += p[d] : f += "";
        var m = "";
        return parseInt(l.slice(1)) < 14 || "WinAnsiEncoding" === g ? m = c(f, l).split("").map(function(t) {
            return t.charCodeAt(0).toString(16);
        }).join("") : "Identity-H" === g && (m = r(f, h[l])), s.isHex = !0, {
            text: m,
            x: i,
            y: a,
            options: o,
            mutex: s
        };
    };
    e.events.push([
        "postProcessText",
        function(t) {
            var e = t.text || "", r = [], n = {
                text: e,
                x: t.x,
                y: t.y,
                options: t.options,
                mutex: t.mutex
            };
            if (Array.isArray(e)) {
                var a = 0;
                for(a = 0; a < e.length; a += 1)Array.isArray(e[a]) && 3 === e[a].length ? r.push([
                    i(Object.assign({}, n, {
                        text: e[a][0]
                    })).text,
                    e[a][1],
                    e[a][2]
                ]) : r.push(i(Object.assign({}, n, {
                    text: e[a]
                })).text);
                t.text = r;
            } else t.text = i(Object.assign({}, n, {
                text: e
            })).text;
        }
    ]);
}(E), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */ function(t) {
    var e = function() {
        return void 0 === this.internal.vFS && (this.internal.vFS = {}), !0;
    };
    t.existsFileInVFS = function(t) {
        return e.call(this), void 0 !== this.internal.vFS[t];
    }, t.addFileToVFS = function(t, r) {
        return e.call(this), this.internal.vFS[t] = r, this;
    }, t.getFileFromVFS = function(t) {
        return e.call(this), void 0 !== this.internal.vFS[t] ? this.internal.vFS[t] : null;
    };
}(E.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */ function(t) {
    t.__bidiEngine__ = t.prototype.__bidiEngine__ = function(t) {
        var r, n, i, a, o, s, c, u = e, h = [
            [
                0,
                3,
                0,
                1,
                0,
                0,
                0
            ],
            [
                0,
                3,
                0,
                1,
                2,
                2,
                0
            ],
            [
                0,
                3,
                0,
                17,
                2,
                0,
                1
            ],
            [
                0,
                3,
                5,
                5,
                4,
                1,
                0
            ],
            [
                0,
                3,
                21,
                21,
                4,
                0,
                1
            ],
            [
                0,
                3,
                5,
                5,
                4,
                2,
                0
            ]
        ], l = [
            [
                2,
                0,
                1,
                1,
                0,
                1,
                0
            ],
            [
                2,
                0,
                1,
                1,
                0,
                2,
                0
            ],
            [
                2,
                0,
                2,
                1,
                3,
                2,
                0
            ],
            [
                2,
                0,
                2,
                33,
                3,
                1,
                1
            ]
        ], f = {
            L: 0,
            R: 1,
            EN: 2,
            AN: 3,
            N: 4,
            B: 5,
            S: 6
        }, d = {
            0: 0,
            5: 1,
            6: 2,
            7: 3,
            32: 4,
            251: 5,
            254: 6,
            255: 7
        }, p = [
            "(",
            ")",
            "(",
            "<",
            ">",
            "<",
            "[",
            "]",
            "[",
            "{",
            "}",
            "{",
            "\xab",
            "\xbb",
            "\xab",
            "\u2039",
            "\u203A",
            "\u2039",
            "\u2045",
            "\u2046",
            "\u2045",
            "\u207D",
            "\u207E",
            "\u207D",
            "\u208D",
            "\u208E",
            "\u208D",
            "\u2264",
            "\u2265",
            "\u2264",
            "\u2329",
            "\u232A",
            "\u2329",
            "\uFE59",
            "\uFE5A",
            "\uFE59",
            "\uFE5B",
            "\uFE5C",
            "\uFE5B",
            "\uFE5D",
            "\uFE5E",
            "\uFE5D",
            "\uFE64",
            "\uFE65",
            "\uFE64"
        ], g = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m = !1, v = 0;
        this.__bidiEngine__ = {};
        var b = function(t) {
            var e = t.charCodeAt(), r = e >> 8, n = d[r];
            return void 0 !== n ? u[256 * n + (255 & e)] : 252 === r || 253 === r ? "AL" : g.test(r) ? "L" : 8 === r ? "R" : "N";
        }, y = function(t) {
            for(var e, r = 0; r < t.length; r++){
                if ("L" === (e = b(t.charAt(r)))) return !1;
                if ("R" === e) return !0;
            }
            return !1;
        }, w = function(t, e, o, s) {
            var c, u, h, l, f = e[s];
            switch(f){
                case "L":
                case "R":
                    m = !1;
                    break;
                case "N":
                case "AN":
                    break;
                case "EN":
                    m && (f = "AN");
                    break;
                case "AL":
                    m = !0, f = "R";
                    break;
                case "WS":
                    f = "N";
                    break;
                case "CS":
                    s < 1 || s + 1 >= e.length || "EN" !== (c = o[s - 1]) && "AN" !== c || "EN" !== (u = e[s + 1]) && "AN" !== u ? f = "N" : m && (u = "AN"), f = u === c ? u : "N";
                    break;
                case "ES":
                    f = "EN" === (c = s > 0 ? o[s - 1] : "B") && s + 1 < e.length && "EN" === e[s + 1] ? "EN" : "N";
                    break;
                case "ET":
                    if (s > 0 && "EN" === o[s - 1]) {
                        f = "EN";
                        break;
                    }
                    if (m) {
                        f = "N";
                        break;
                    }
                    for(h = s + 1, l = e.length; h < l && "ET" === e[h];)h++;
                    f = h < l && "EN" === e[h] ? "EN" : "N";
                    break;
                case "NSM":
                    if (i && !a) {
                        for(l = e.length, h = s + 1; h < l && "NSM" === e[h];)h++;
                        if (h < l) {
                            var d = t[s], p = d >= 1425 && d <= 2303 || 64286 === d;
                            if (c = e[h], p && ("R" === c || "AL" === c)) {
                                f = "R";
                                break;
                            }
                        }
                    }
                    f = s < 1 || "B" === (c = e[s - 1]) ? "N" : o[s - 1];
                    break;
                case "B":
                    m = !1, r = !0, f = v;
                    break;
                case "S":
                    n = !0, f = "N";
                    break;
                case "LRE":
                case "RLE":
                case "LRO":
                case "RLO":
                case "PDF":
                    m = !1;
                    break;
                case "BN":
                    f = "N";
            }
            return f;
        }, N = function(t, e, r) {
            var n = t.split("");
            return r && L(n, r, {
                hiLevel: v
            }), n.reverse(), e && e.reverse(), n.join("");
        }, L = function(t, e, i) {
            var a, o, s, c, u, d = -1, p = t.length, g = 0, y = [], N = v ? l : h, L = [];
            for(m = !1, r = !1, n = !1, o = 0; o < p; o++)L[o] = b(t[o]);
            for(s = 0; s < p; s++){
                if (u = g, y[s] = w(t, L, y, s), a = 240 & (g = N[u][f[y[s]]]), g &= 15, e[s] = c = N[g][5], a > 0) {
                    if (16 === a) {
                        for(o = d; o < s; o++)e[o] = 1;
                        d = -1;
                    } else d = -1;
                }
                if (N[g][6]) -1 === d && (d = s);
                else if (d > -1) {
                    for(o = d; o < s; o++)e[o] = c;
                    d = -1;
                }
                "B" === L[s] && (e[s] = 0), i.hiLevel |= c;
            }
            n && function(t, e, r) {
                for(var n = 0; n < r; n++)if ("S" === t[n]) {
                    e[n] = v;
                    for(var i = n - 1; i >= 0 && "WS" === t[i]; i--)e[i] = v;
                }
            }(L, e, p);
        }, A = function(t, e, n, i, a) {
            if (!(a.hiLevel < t)) {
                if (1 === t && 1 === v && !r) return e.reverse(), void (n && n.reverse());
                for(var o, s, c, u, h = e.length, l = 0; l < h;){
                    if (i[l] >= t) {
                        for(c = l + 1; c < h && i[c] >= t;)c++;
                        for(u = l, s = c - 1; u < s; u++, s--)o = e[u], e[u] = e[s], e[s] = o, n && (o = n[u], n[u] = n[s], n[s] = o);
                        l = c;
                    }
                    l++;
                }
            }
        }, x = function(t, e, r) {
            var n = t.split(""), i = {
                hiLevel: v
            };
            return r || (r = []), L(n, r, i), function(t, e, r) {
                if (0 !== r.hiLevel && c) for(var n, i = 0; i < t.length; i++)1 === e[i] && (n = p.indexOf(t[i])) >= 0 && (t[i] = p[n + 1]);
            }(n, r, i), A(2, n, e, r, i), A(1, n, e, r, i), n.join("");
        };
        return this.__bidiEngine__.doBidiReorder = function(t, e, r) {
            if (function(t, e) {
                if (e) for(var r = 0; r < t.length; r++)e[r] = r;
                void 0 === a && (a = y(t)), void 0 === s && (s = y(t));
            }(t, e), i || !o || s) {
                if (i && o && a ^ s) v = a ? 1 : 0, t = N(t, e, r);
                else if (!i && o && s) v = a ? 1 : 0, t = x(t, e, r), t = N(t, e);
                else if (!i || a || o || s) {
                    if (i && !o && a ^ s) t = N(t, e), a ? (v = 0, t = x(t, e, r)) : (v = 1, t = x(t, e, r), t = N(t, e));
                    else if (i && a && !o && s) v = 1, t = x(t, e, r), t = N(t, e);
                    else if (!i && !o && a ^ s) {
                        var n = c;
                        a ? (v = 1, t = x(t, e, r), v = 0, c = !1, t = x(t, e, r), c = n) : (v = 0, t = x(t, e, r), t = N(t, e), v = 1, c = !1, t = x(t, e, r), c = n, t = N(t, e));
                    }
                } else v = 0, t = x(t, e, r);
            } else v = a ? 1 : 0, t = x(t, e, r);
            return t;
        }, this.__bidiEngine__.setOptions = function(t) {
            t && (i = t.isInputVisual, o = t.isOutputVisual, a = t.isInputRtl, s = t.isOutputRtl, c = t.isSymmetricSwapping);
        }, this.__bidiEngine__.setOptions(t), this.__bidiEngine__;
    };
    var e = [
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "S",
        "B",
        "S",
        "WS",
        "B",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "B",
        "B",
        "B",
        "S",
        "WS",
        "N",
        "N",
        "ET",
        "ET",
        "ET",
        "N",
        "N",
        "N",
        "N",
        "N",
        "ES",
        "CS",
        "ES",
        "CS",
        "CS",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "CS",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "N",
        "N",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "B",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "CS",
        "N",
        "ET",
        "ET",
        "ET",
        "ET",
        "N",
        "N",
        "N",
        "N",
        "L",
        "N",
        "N",
        "BN",
        "N",
        "N",
        "ET",
        "ET",
        "EN",
        "EN",
        "N",
        "L",
        "N",
        "N",
        "N",
        "EN",
        "L",
        "N",
        "N",
        "N",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "L",
        "N",
        "N",
        "N",
        "N",
        "N",
        "ET",
        "N",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "R",
        "NSM",
        "R",
        "NSM",
        "NSM",
        "R",
        "NSM",
        "NSM",
        "R",
        "NSM",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "N",
        "N",
        "N",
        "N",
        "N",
        "R",
        "R",
        "R",
        "R",
        "R",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "AN",
        "AN",
        "AN",
        "AN",
        "AN",
        "AN",
        "N",
        "N",
        "AL",
        "ET",
        "ET",
        "AL",
        "CS",
        "AL",
        "N",
        "N",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "AL",
        "AL",
        "N",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "AN",
        "AN",
        "AN",
        "AN",
        "AN",
        "AN",
        "AN",
        "AN",
        "AN",
        "AN",
        "ET",
        "AN",
        "AN",
        "AL",
        "AL",
        "AL",
        "NSM",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "AN",
        "N",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "AL",
        "AL",
        "NSM",
        "NSM",
        "N",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "AL",
        "AL",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "N",
        "AL",
        "AL",
        "NSM",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "N",
        "N",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "AL",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "R",
        "R",
        "N",
        "N",
        "N",
        "N",
        "R",
        "N",
        "N",
        "N",
        "N",
        "N",
        "WS",
        "WS",
        "WS",
        "WS",
        "WS",
        "WS",
        "WS",
        "WS",
        "WS",
        "WS",
        "WS",
        "BN",
        "BN",
        "BN",
        "L",
        "R",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "WS",
        "B",
        "LRE",
        "RLE",
        "PDF",
        "LRO",
        "RLO",
        "CS",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "CS",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "WS",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "N",
        "LRI",
        "RLI",
        "FSI",
        "PDI",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "BN",
        "EN",
        "L",
        "N",
        "N",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "ES",
        "ES",
        "N",
        "N",
        "N",
        "L",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "ES",
        "ES",
        "N",
        "N",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "N",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "ET",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "N",
        "N",
        "N",
        "R",
        "NSM",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "ES",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "N",
        "R",
        "R",
        "R",
        "R",
        "R",
        "N",
        "R",
        "N",
        "R",
        "R",
        "N",
        "R",
        "R",
        "N",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "R",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "NSM",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "CS",
        "N",
        "CS",
        "N",
        "N",
        "CS",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "ET",
        "N",
        "N",
        "ES",
        "ES",
        "N",
        "N",
        "N",
        "N",
        "N",
        "ET",
        "ET",
        "N",
        "N",
        "N",
        "N",
        "N",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "N",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "AL",
        "N",
        "N",
        "BN",
        "N",
        "N",
        "N",
        "ET",
        "ET",
        "ET",
        "N",
        "N",
        "N",
        "N",
        "N",
        "ES",
        "CS",
        "ES",
        "CS",
        "CS",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "EN",
        "CS",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "L",
        "L",
        "L",
        "L",
        "L",
        "L",
        "N",
        "N",
        "L",
        "L",
        "L",
        "N",
        "N",
        "N",
        "ET",
        "ET",
        "N",
        "N",
        "N",
        "ET",
        "ET",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N",
        "N"
    ], r = new t.__bidiEngine__({
        isInputVisual: !0
    });
    t.API.events.push([
        "postProcessText",
        function(t) {
            var e = t.text, n = (t.x, t.y, t.options || {}), i = (t.mutex, n.lang, []);
            if (n.isInputVisual = "boolean" != typeof n.isInputVisual || n.isInputVisual, r.setOptions(n), "[object Array]" === Object.prototype.toString.call(e)) {
                var a = 0;
                for(i = [], a = 0; a < e.length; a += 1)"[object Array]" === Object.prototype.toString.call(e[a]) ? i.push([
                    r.doBidiReorder(e[a][0]),
                    e[a][1],
                    e[a][2]
                ]) : i.push([
                    r.doBidiReorder(e[a])
                ]);
                t.text = i;
            } else t.text = r.doBidiReorder(e);
            r.setOptions({
                isInputVisual: !0
            });
        }
    ]);
}(E), E.API.TTFFont = function() {
    function t(t) {
        var e;
        if (this.rawData = t, e = this.contents = new ne(t), this.contents.pos = 4, "ttcf" === e.readString(4)) throw new Error("TTCF not supported.");
        e.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
    }
    return t.open = function(e) {
        return new t(e);
    }, t.prototype.parse = function() {
        return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [
            this.head.xMin,
            this.head.yMin,
            this.head.xMax,
            this.head.yMax
        ];
    }, t.prototype.registerTTF = function() {
        var t, e, r, n, i;
        if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
            var e, r, n, i;
            for(i = [], e = 0, r = (n = this.bbox).length; e < r; e++)t = n[e], i.push(Math.round(t * this.scaleFactor));
            return i;
        }).call(this), this.stemV = 0, this.post.exists ? (r = 255 & (n = this.post.italic_angle), 0 != (32768 & (e = n >> 16)) && (e = -(1 + (65535 ^ e))), this.italicAngle = +(e + "." + r)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i = this.familyClass) || 2 === i || 3 === i || 4 === i || 5 === i || 7 === i, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
    }, t.prototype.characterToGlyph = function(t) {
        var e;
        return (null != (e = this.cmap.unicode) ? e.codeMap[t] : void 0) || 0;
    }, t.prototype.widthOfGlyph = function(t) {
        var e;
        return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t).advance * e;
    }, t.prototype.widthOfString = function(t, e, r) {
        var n, i, a, o;
        for(a = 0, i = 0, o = (t = "" + t).length; 0 <= o ? i < o : i > o; i = 0 <= o ? ++i : --i)n = t.charCodeAt(i), a += this.widthOfGlyph(this.characterToGlyph(n)) + r * (1e3 / e) || 0;
        return a * (e / 1e3);
    }, t.prototype.lineHeight = function(t, e) {
        var r;
        return null == e && (e = !1), r = e ? this.lineGap : 0, (this.ascender + r - this.decender) / 1e3 * t;
    }, t;
}();
var re, ne = function() {
    function t(t) {
        this.data = null != t ? t : [], this.pos = 0, this.length = this.data.length;
    }
    return t.prototype.readByte = function() {
        return this.data[this.pos++];
    }, t.prototype.writeByte = function(t) {
        return this.data[this.pos++] = t;
    }, t.prototype.readUInt32 = function() {
        return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
    }, t.prototype.writeUInt32 = function(t) {
        return this.writeByte(t >>> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
    }, t.prototype.readInt32 = function() {
        var t;
        return (t = this.readUInt32()) >= 2147483648 ? t - 4294967296 : t;
    }, t.prototype.writeInt32 = function(t) {
        return t < 0 && (t += 4294967296), this.writeUInt32(t);
    }, t.prototype.readUInt16 = function() {
        return this.readByte() << 8 | this.readByte();
    }, t.prototype.writeUInt16 = function(t) {
        return this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
    }, t.prototype.readInt16 = function() {
        var t;
        return (t = this.readUInt16()) >= 32768 ? t - 65536 : t;
    }, t.prototype.writeInt16 = function(t) {
        return t < 0 && (t += 65536), this.writeUInt16(t);
    }, t.prototype.readString = function(t) {
        var e, r;
        for(r = [], e = 0; 0 <= t ? e < t : e > t; e = 0 <= t ? ++e : --e)r[e] = String.fromCharCode(this.readByte());
        return r.join("");
    }, t.prototype.writeString = function(t) {
        var e, r, n;
        for(n = [], e = 0, r = t.length; 0 <= r ? e < r : e > r; e = 0 <= r ? ++e : --e)n.push(this.writeByte(t.charCodeAt(e)));
        return n;
    }, t.prototype.readShort = function() {
        return this.readInt16();
    }, t.prototype.writeShort = function(t) {
        return this.writeInt16(t);
    }, t.prototype.readLongLong = function() {
        var t, e, r, n, i, a, o, s;
        return t = this.readByte(), e = this.readByte(), r = this.readByte(), n = this.readByte(), i = this.readByte(), a = this.readByte(), o = this.readByte(), s = this.readByte(), 128 & t ? -1 * (72057594037927940 * (255 ^ t) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ r) + 4294967296 * (255 ^ n) + 16777216 * (255 ^ i) + 65536 * (255 ^ a) + 256 * (255 ^ o) + (255 ^ s) + 1) : 72057594037927940 * t + 281474976710656 * e + 1099511627776 * r + 4294967296 * n + 16777216 * i + 65536 * a + 256 * o + s;
    }, t.prototype.writeLongLong = function(t) {
        var e, r;
        return e = Math.floor(t / 4294967296), r = 4294967295 & t, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(r >> 24 & 255), this.writeByte(r >> 16 & 255), this.writeByte(r >> 8 & 255), this.writeByte(255 & r);
    }, t.prototype.readInt = function() {
        return this.readInt32();
    }, t.prototype.writeInt = function(t) {
        return this.writeInt32(t);
    }, t.prototype.read = function(t) {
        var e, r;
        for(e = [], r = 0; 0 <= t ? r < t : r > t; r = 0 <= t ? ++r : --r)e.push(this.readByte());
        return e;
    }, t.prototype.write = function(t) {
        var e, r, n, i;
        for(i = [], r = 0, n = t.length; r < n; r++)e = t[r], i.push(this.writeByte(e));
        return i;
    }, t;
}(), ie = function() {
    var t;
    function e(t) {
        var e, r, n;
        for(this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, r = 0, n = this.tableCount; 0 <= n ? r < n : r > n; r = 0 <= n ? ++r : --r)e = {
            tag: t.readString(4),
            checksum: t.readInt(),
            offset: t.readInt(),
            length: t.readInt()
        }, this.tables[e.tag] = e;
    }
    return e.prototype.encode = function(e) {
        var r, n, i, a, o, s, c, u, h, l, f, d, p;
        for(p in f = Object.keys(e).length, s = Math.log(2), h = 16 * Math.floor(Math.log(f) / s), a = Math.floor(h / s), u = 16 * f - h, (n = new ne).writeInt(this.scalarType), n.writeShort(f), n.writeShort(h), n.writeShort(a), n.writeShort(u), i = 16 * f, c = n.pos + i, o = null, d = [], e)for(l = e[p], n.writeString(p), n.writeInt(t(l)), n.writeInt(c), n.writeInt(l.length), d = d.concat(l), "head" === p && (o = c), c += l.length; c % 4;)d.push(0), c++;
        return n.write(d), r = 2981146554 - t(n.data), n.pos = o + 8, n.writeUInt32(r), n.data;
    }, t = function(t) {
        var e, r, n, i;
        for(t = ve.call(t); t.length % 4;)t.push(0);
        for(n = new ne(t), r = 0, e = 0, i = t.length; e < i; e = e += 4)r += n.readUInt32();
        return 4294967295 & r;
    }, e;
}(), ae = {}.hasOwnProperty, oe = function(t, e) {
    for(var r in e)ae.call(e, r) && (t[r] = e[r]);
    function n() {
        this.constructor = t;
    }
    return n.prototype = e.prototype, t.prototype = new n, t.__super__ = e.prototype, t;
};
re = function() {
    function t(t) {
        var e;
        this.file = t, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
    }
    return t.prototype.parse = function() {}, t.prototype.encode = function() {}, t.prototype.raw = function() {
        return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
    }, t;
}();
var se = function(t) {
    function e() {
        return e.__super__.constructor.apply(this, arguments);
    }
    return oe(e, re), e.prototype.tag = "head", e.prototype.parse = function(t) {
        return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
    }, e.prototype.encode = function(t) {
        var e;
        return (e = new ne).writeInt(this.version), e.writeInt(this.revision), e.writeInt(this.checkSumAdjustment), e.writeInt(this.magicNumber), e.writeShort(this.flags), e.writeShort(this.unitsPerEm), e.writeLongLong(this.created), e.writeLongLong(this.modified), e.writeShort(this.xMin), e.writeShort(this.yMin), e.writeShort(this.xMax), e.writeShort(this.yMax), e.writeShort(this.macStyle), e.writeShort(this.lowestRecPPEM), e.writeShort(this.fontDirectionHint), e.writeShort(t), e.writeShort(this.glyphDataFormat), e.data;
    }, e;
}(), ce = function() {
    function t(t, e) {
        var r, n, i, a, o, s, c, u, h, l, f, d, p, g, m, v, b;
        switch(this.platformID = t.readUInt16(), this.encodingID = t.readShort(), this.offset = e + t.readInt(), h = t.pos, t.pos = this.offset, this.format = t.readUInt16(), this.length = t.readUInt16(), this.language = t.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format){
            case 0:
                for(s = 0; s < 256; ++s)this.codeMap[s] = t.readByte();
                break;
            case 4:
                for(f = t.readUInt16(), l = f / 2, t.pos += 6, i = function() {
                    var e, r;
                    for(r = [], s = e = 0; 0 <= l ? e < l : e > l; s = 0 <= l ? ++e : --e)r.push(t.readUInt16());
                    return r;
                }(), t.pos += 2, p = function() {
                    var e, r;
                    for(r = [], s = e = 0; 0 <= l ? e < l : e > l; s = 0 <= l ? ++e : --e)r.push(t.readUInt16());
                    return r;
                }(), c = function() {
                    var e, r;
                    for(r = [], s = e = 0; 0 <= l ? e < l : e > l; s = 0 <= l ? ++e : --e)r.push(t.readUInt16());
                    return r;
                }(), u = function() {
                    var e, r;
                    for(r = [], s = e = 0; 0 <= l ? e < l : e > l; s = 0 <= l ? ++e : --e)r.push(t.readUInt16());
                    return r;
                }(), n = (this.length - t.pos + this.offset) / 2, o = function() {
                    var e, r;
                    for(r = [], s = e = 0; 0 <= n ? e < n : e > n; s = 0 <= n ? ++e : --e)r.push(t.readUInt16());
                    return r;
                }(), s = m = 0, b = i.length; m < b; s = ++m)for(g = i[s], r = v = d = p[s]; d <= g ? v <= g : v >= g; r = d <= g ? ++v : --v)0 === u[s] ? a = r + c[s] : 0 !== (a = o[u[s] / 2 + (r - d) - (l - s)] || 0) && (a += c[s]), this.codeMap[r] = 65535 & a;
        }
        t.pos = h;
    }
    return t.encode = function(t, e) {
        var r, n, i, a, o, s, c, u, h, l, f, d, p, g, m, v, b, y, w, N, L, A, x, S, _, P, k, I, F, C, j, O, B, M, E, q, D, R, T, U, z, H, W, V, G, Y;
        switch(I = new ne, a = Object.keys(t).sort(function(t, e) {
            return t - e;
        }), e){
            case "macroman":
                for(p = 0, g = function() {
                    var t = [];
                    for(d = 0; d < 256; ++d)t.push(0);
                    return t;
                }(), v = {
                    0: 0
                }, i = {}, F = 0, B = a.length; F < B; F++)null == v[W = t[n = a[F]]] && (v[W] = ++p), i[n] = {
                    old: t[n],
                    new: v[t[n]]
                }, g[n] = v[t[n]];
                return I.writeUInt16(1), I.writeUInt16(0), I.writeUInt32(12), I.writeUInt16(0), I.writeUInt16(262), I.writeUInt16(0), I.write(g), {
                    charMap: i,
                    subtable: I.data,
                    maxGlyphID: p + 1
                };
            case "unicode":
                for(P = [], h = [], b = 0, v = {}, r = {}, m = c = null, C = 0, M = a.length; C < M; C++)null == v[w = t[n = a[C]]] && (v[w] = ++b), r[n] = {
                    old: w,
                    new: v[w]
                }, o = v[w] - n, null != m && o === c || (m && h.push(m), P.push(n), c = o), m = n;
                for(m && h.push(m), h.push(65535), P.push(65535), S = 2 * (x = P.length), A = 2 * Math.pow(Math.log(x) / Math.LN2, 2), l = Math.log(A / 2) / Math.LN2, L = 2 * x - A, s = [], N = [], f = [], d = j = 0, E = P.length; j < E; d = ++j){
                    if (_ = P[d], u = h[d], 65535 === _) {
                        s.push(0), N.push(0);
                        break;
                    }
                    if (_ - (k = r[_].new) >= 32768) for(s.push(0), N.push(2 * (f.length + x - d)), n = O = _; _ <= u ? O <= u : O >= u; n = _ <= u ? ++O : --O)f.push(r[n].new);
                    else s.push(k - _), N.push(0);
                }
                for(I.writeUInt16(3), I.writeUInt16(1), I.writeUInt32(12), I.writeUInt16(4), I.writeUInt16(16 + 8 * x + 2 * f.length), I.writeUInt16(0), I.writeUInt16(S), I.writeUInt16(A), I.writeUInt16(l), I.writeUInt16(L), z = 0, q = h.length; z < q; z++)n = h[z], I.writeUInt16(n);
                for(I.writeUInt16(0), H = 0, D = P.length; H < D; H++)n = P[H], I.writeUInt16(n);
                for(V = 0, R = s.length; V < R; V++)o = s[V], I.writeUInt16(o);
                for(G = 0, T = N.length; G < T; G++)y = N[G], I.writeUInt16(y);
                for(Y = 0, U = f.length; Y < U; Y++)p = f[Y], I.writeUInt16(p);
                return {
                    charMap: r,
                    subtable: I.data,
                    maxGlyphID: b + 1
                };
        }
    }, t;
}(), ue = function(t) {
    function e() {
        return e.__super__.constructor.apply(this, arguments);
    }
    return oe(e, re), e.prototype.tag = "cmap", e.prototype.parse = function(t) {
        var e, r, n;
        for(t.pos = this.offset, this.version = t.readUInt16(), n = t.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= n ? r < n : r > n; r = 0 <= n ? ++r : --r)e = new ce(t, this.offset), this.tables.push(e), e.isUnicode && null == this.unicode && (this.unicode = e);
        return !0;
    }, e.encode = function(t, e) {
        var r, n;
        return null == e && (e = "macroman"), r = ce.encode(t, e), (n = new ne).writeUInt16(0), n.writeUInt16(1), r.table = n.data.concat(r.subtable), r;
    }, e;
}(), he = function(t) {
    function e() {
        return e.__super__.constructor.apply(this, arguments);
    }
    return oe(e, re), e.prototype.tag = "hhea", e.prototype.parse = function(t) {
        return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
    }, e;
}(), le = function(t) {
    function e() {
        return e.__super__.constructor.apply(this, arguments);
    }
    return oe(e, re), e.prototype.tag = "OS/2", e.prototype.parse = function(t) {
        if (t.pos = this.offset, this.version = t.readUInt16(), this.averageCharWidth = t.readShort(), this.weightClass = t.readUInt16(), this.widthClass = t.readUInt16(), this.type = t.readShort(), this.ySubscriptXSize = t.readShort(), this.ySubscriptYSize = t.readShort(), this.ySubscriptXOffset = t.readShort(), this.ySubscriptYOffset = t.readShort(), this.ySuperscriptXSize = t.readShort(), this.ySuperscriptYSize = t.readShort(), this.ySuperscriptXOffset = t.readShort(), this.ySuperscriptYOffset = t.readShort(), this.yStrikeoutSize = t.readShort(), this.yStrikeoutPosition = t.readShort(), this.familyClass = t.readShort(), this.panose = function() {
            var e, r;
            for(r = [], e = 0; e < 10; ++e)r.push(t.readByte());
            return r;
        }(), this.charRange = function() {
            var e, r;
            for(r = [], e = 0; e < 4; ++e)r.push(t.readInt());
            return r;
        }(), this.vendorID = t.readString(4), this.selection = t.readShort(), this.firstCharIndex = t.readShort(), this.lastCharIndex = t.readShort(), this.version > 0 && (this.ascent = t.readShort(), this.descent = t.readShort(), this.lineGap = t.readShort(), this.winAscent = t.readShort(), this.winDescent = t.readShort(), this.codePageRange = function() {
            var e, r;
            for(r = [], e = 0; e < 2; e = ++e)r.push(t.readInt());
            return r;
        }(), this.version > 1)) return this.xHeight = t.readShort(), this.capHeight = t.readShort(), this.defaultChar = t.readShort(), this.breakChar = t.readShort(), this.maxContext = t.readShort();
    }, e;
}(), fe = function(t) {
    function e() {
        return e.__super__.constructor.apply(this, arguments);
    }
    return oe(e, re), e.prototype.tag = "post", e.prototype.parse = function(t) {
        var e, r, n;
        switch(t.pos = this.offset, this.format = t.readInt(), this.italicAngle = t.readInt(), this.underlinePosition = t.readShort(), this.underlineThickness = t.readShort(), this.isFixedPitch = t.readInt(), this.minMemType42 = t.readInt(), this.maxMemType42 = t.readInt(), this.minMemType1 = t.readInt(), this.maxMemType1 = t.readInt(), this.format){
            case 65536:
                break;
            case 131072:
                var i;
                for(r = t.readUInt16(), this.glyphNameIndex = [], i = 0; 0 <= r ? i < r : i > r; i = 0 <= r ? ++i : --i)this.glyphNameIndex.push(t.readUInt16());
                for(this.names = [], n = []; t.pos < this.offset + this.length;)e = t.readByte(), n.push(this.names.push(t.readString(e)));
                return n;
            case 151552:
                return r = t.readUInt16(), this.offsets = t.read(r);
            case 196608:
                break;
            case 262144:
                return this.map = (function() {
                    var e, r, n;
                    for(n = [], i = e = 0, r = this.file.maxp.numGlyphs; 0 <= r ? e < r : e > r; i = 0 <= r ? ++e : --e)n.push(t.readUInt32());
                    return n;
                }).call(this);
        }
    }, e;
}(), de = function(t, e) {
    this.raw = t, this.length = t.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, pe = function(t) {
    function e() {
        return e.__super__.constructor.apply(this, arguments);
    }
    return oe(e, re), e.prototype.tag = "name", e.prototype.parse = function(t) {
        var e, r, n, i, a, o, s, c, u, h, l;
        for(t.pos = this.offset, t.readShort(), e = t.readShort(), o = t.readShort(), r = [], i = 0; 0 <= e ? i < e : i > e; i = 0 <= e ? ++i : --i)r.push({
            platformID: t.readShort(),
            encodingID: t.readShort(),
            languageID: t.readShort(),
            nameID: t.readShort(),
            length: t.readShort(),
            offset: this.offset + o + t.readShort()
        });
        for(s = {}, i = u = 0, h = r.length; u < h; i = ++u)n = r[i], t.pos = n.offset, c = t.readString(n.length), a = new de(c, n), null == s[l = n.nameID] && (s[l] = []), s[n.nameID].push(a);
        this.strings = s, this.copyright = s[0], this.fontFamily = s[1], this.fontSubfamily = s[2], this.uniqueSubfamily = s[3], this.fontName = s[4], this.version = s[5];
        try {
            this.postscriptName = s[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
        } catch (t) {
            this.postscriptName = s[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
        }
        return this.trademark = s[7], this.manufacturer = s[8], this.designer = s[9], this.description = s[10], this.vendorUrl = s[11], this.designerUrl = s[12], this.license = s[13], this.licenseUrl = s[14], this.preferredFamily = s[15], this.preferredSubfamily = s[17], this.compatibleFull = s[18], this.sampleText = s[19];
    }, e;
}(), ge = function(t) {
    function e() {
        return e.__super__.constructor.apply(this, arguments);
    }
    return oe(e, re), e.prototype.tag = "maxp", e.prototype.parse = function(t) {
        return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
    }, e;
}(), me = function(t) {
    function e() {
        return e.__super__.constructor.apply(this, arguments);
    }
    return oe(e, re), e.prototype.tag = "hmtx", e.prototype.parse = function(t) {
        var e, r, n, i, a, o, s;
        for(t.pos = this.offset, this.metrics = [], e = 0, o = this.file.hhea.numberOfMetrics; 0 <= o ? e < o : e > o; e = 0 <= o ? ++e : --e)this.metrics.push({
            advance: t.readUInt16(),
            lsb: t.readInt16()
        });
        for(n = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
            var r, i;
            for(i = [], e = r = 0; 0 <= n ? r < n : r > n; e = 0 <= n ? ++r : --r)i.push(t.readInt16());
            return i;
        }(), this.widths = (function() {
            var t, e, r, n;
            for(n = [], t = 0, e = (r = this.metrics).length; t < e; t++)i = r[t], n.push(i.advance);
            return n;
        }).call(this), r = this.widths[this.widths.length - 1], s = [], e = a = 0; 0 <= n ? a < n : a > n; e = 0 <= n ? ++a : --a)s.push(this.widths.push(r));
        return s;
    }, e.prototype.forGlyph = function(t) {
        return t in this.metrics ? this.metrics[t] : {
            advance: this.metrics[this.metrics.length - 1].advance,
            lsb: this.leftSideBearings[t - this.metrics.length]
        };
    }, e;
}(), ve = [].slice, be = function(t) {
    function e() {
        return e.__super__.constructor.apply(this, arguments);
    }
    return oe(e, re), e.prototype.tag = "glyf", e.prototype.parse = function() {
        return this.cache = {};
    }, e.prototype.glyphFor = function(t) {
        var e, r, n, i, a, o, s, c, u, h;
        return t in this.cache ? this.cache[t] : (i = this.file.loca, e = this.file.contents, r = i.indexOf(t), 0 === (n = i.lengthOf(t)) ? this.cache[t] = null : (e.pos = this.offset + r, a = (o = new ne(e.read(n))).readShort(), c = o.readShort(), h = o.readShort(), s = o.readShort(), u = o.readShort(), this.cache[t] = -1 === a ? new we(o, c, h, s, u) : new ye(o, a, c, h, s, u), this.cache[t]));
    }, e.prototype.encode = function(t, e, r) {
        var n, i, a, o, s;
        for(a = [], i = [], o = 0, s = e.length; o < s; o++)n = t[e[o]], i.push(a.length), n && (a = a.concat(n.encode(r)));
        return i.push(a.length), {
            table: a,
            offsets: i
        };
    }, e;
}(), ye = function() {
    function t(t, e, r, n, i, a) {
        this.raw = t, this.numberOfContours = e, this.xMin = r, this.yMin = n, this.xMax = i, this.yMax = a, this.compound = !1;
    }
    return t.prototype.encode = function() {
        return this.raw.data;
    }, t;
}(), we = function() {
    function t(t, e, r, n, i) {
        var a, o;
        for(this.raw = t, this.xMin = e, this.yMin = r, this.xMax = n, this.yMax = i, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], a = this.raw; o = a.readShort(), this.glyphOffsets.push(a.pos), this.glyphIDs.push(a.readUInt16()), 32 & o;)a.pos += 1 & o ? 4 : 2, 128 & o ? a.pos += 8 : 64 & o ? a.pos += 4 : 8 & o && (a.pos += 2);
    }
    return t.prototype.encode = function() {
        var t, e, r;
        for(e = new ne(ve.call(this.raw.data)), t = 0, r = this.glyphIDs.length; t < r; ++t)e.pos = this.glyphOffsets[t];
        return e.data;
    }, t;
}(), Ne = function(t) {
    function e() {
        return e.__super__.constructor.apply(this, arguments);
    }
    return oe(e, re), e.prototype.tag = "loca", e.prototype.parse = function(t) {
        var e, r;
        return t.pos = this.offset, e = this.file.head.indexToLocFormat, this.offsets = 0 === e ? (function() {
            var e, n;
            for(n = [], r = 0, e = this.length; r < e; r += 2)n.push(2 * t.readUInt16());
            return n;
        }).call(this) : (function() {
            var e, n;
            for(n = [], r = 0, e = this.length; r < e; r += 4)n.push(t.readUInt32());
            return n;
        }).call(this);
    }, e.prototype.indexOf = function(t) {
        return this.offsets[t];
    }, e.prototype.lengthOf = function(t) {
        return this.offsets[t + 1] - this.offsets[t];
    }, e.prototype.encode = function(t, e) {
        for(var r = new Uint32Array(this.offsets.length), n = 0, i = 0, a = 0; a < r.length; ++a)if (r[a] = n, i < e.length && e[i] == a) {
            ++i, r[a] = n;
            var o = this.offsets[a], s = this.offsets[a + 1] - o;
            s > 0 && (n += s);
        }
        for(var c = new Array(4 * r.length), u = 0; u < r.length; ++u)c[4 * u + 3] = 255 & r[u], c[4 * u + 2] = (65280 & r[u]) >> 8, c[4 * u + 1] = (16711680 & r[u]) >> 16, c[4 * u] = (4278190080 & r[u]) >> 24;
        return c;
    }, e;
}(), Le = function() {
    function t(t) {
        this.font = t, this.subset = {}, this.unicodes = {}, this.next = 33;
    }
    return t.prototype.generateCmap = function() {
        var t, e, r, n, i;
        for(e in n = this.font.cmap.tables[0].codeMap, t = {}, i = this.subset)r = i[e], t[e] = n[r];
        return t;
    }, t.prototype.glyphsFor = function(t) {
        var e, r, n, i, a, o, s;
        for(n = {}, a = 0, o = t.length; a < o; a++)n[i = t[a]] = this.font.glyf.glyphFor(i);
        for(i in e = [], n)(null != (r = n[i]) ? r.compound : void 0) && e.push.apply(e, r.glyphIDs);
        if (e.length > 0) for(i in s = this.glyphsFor(e))r = s[i], n[i] = r;
        return n;
    }, t.prototype.encode = function(t, e) {
        var r, n, i, a, o, s, c, u, h, l, f, d, p, g, m;
        for(n in r = ue.encode(this.generateCmap(), "unicode"), a = this.glyphsFor(t), f = {
            0: 0
        }, m = r.charMap)f[(s = m[n]).old] = s.new;
        for(d in l = r.maxGlyphID, a)d in f || (f[d] = l++);
        return u = function(t) {
            var e, r;
            for(e in r = {}, t)r[t[e]] = e;
            return r;
        }(f), h = Object.keys(u).sort(function(t, e) {
            return t - e;
        }), p = function() {
            var t, e, r;
            for(r = [], t = 0, e = h.length; t < e; t++)o = h[t], r.push(u[o]);
            return r;
        }(), i = this.font.glyf.encode(a, p, f), c = this.font.loca.encode(i.offsets, p), g = {
            cmap: this.font.cmap.raw(),
            glyf: i.table,
            loca: c,
            hmtx: this.font.hmtx.raw(),
            hhea: this.font.hhea.raw(),
            maxp: this.font.maxp.raw(),
            post: this.font.post.raw(),
            name: this.font.name.raw(),
            head: this.font.head.encode(e)
        }, this.font.os2.exists && (g["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g);
    }, t;
}();
E.API.PDFObject = function() {
    var t;
    function e() {}
    return t = function(t, e) {
        return (Array(e + 1).join("0") + t).slice(-e);
    }, e.convert = function(r) {
        var n, i, a, o;
        if (Array.isArray(r)) return "[" + (function() {
            var t, i, a;
            for(a = [], t = 0, i = r.length; t < i; t++)n = r[t], a.push(e.convert(n));
            return a;
        })().join(" ") + "]";
        if ("string" == typeof r) return "/" + r;
        if (null != r ? r.isString : void 0) return "(" + r + ")";
        if (r instanceof Date) return "(D:" + t(r.getUTCFullYear(), 4) + t(r.getUTCMonth(), 2) + t(r.getUTCDate(), 2) + t(r.getUTCHours(), 2) + t(r.getUTCMinutes(), 2) + t(r.getUTCSeconds(), 2) + "Z)";
        if ("[object Object]" === ({}).toString.call(r)) {
            for(i in a = [
                "<<"
            ], r)o = r[i], a.push("/" + i + " " + e.convert(o));
            return a.push(">>"), a.join("\n");
        }
        return "" + r;
    }, e;
}();
exports.default = E;

},{"@babel/runtime/helpers/typeof":"7EL9t","fflate":"5YPy3","e35ed7d1af132742":"6knHn","fd4d839f94e36dff":"qpTWL","7ec43201f0dbcdb8":"97tTU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7EL9t":[function(require,module,exports,__globalThis) {
function _typeof(o) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"5YPy3":[function(require,module,exports,__globalThis) {
// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
// https://tools.ietf.org/html/rfc1951
// You may also wish to take a look at the guide I made about this program:
// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
// Some of the following code is similar to that of UZIP.js:
// https://github.com/photopea/UZIP.js
// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
// is better for memory in most engines (I *think*).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FlateErrorCode", ()=>FlateErrorCode);
parcelHelpers.export(exports, "Deflate", ()=>Deflate);
parcelHelpers.export(exports, "AsyncDeflate", ()=>AsyncDeflate);
parcelHelpers.export(exports, "deflate", ()=>deflate);
/**
 * Compresses data with DEFLATE without any wrapper
 * @param data The data to compress
 * @param opts The compression options
 * @returns The deflated version of the data
 */ parcelHelpers.export(exports, "deflateSync", ()=>deflateSync);
parcelHelpers.export(exports, "Inflate", ()=>Inflate);
parcelHelpers.export(exports, "AsyncInflate", ()=>AsyncInflate);
parcelHelpers.export(exports, "inflate", ()=>inflate);
/**
 * Expands DEFLATE data with no wrapper
 * @param data The data to decompress
 * @param opts The decompression options
 * @returns The decompressed version of the data
 */ parcelHelpers.export(exports, "inflateSync", ()=>inflateSync);
parcelHelpers.export(exports, "Gzip", ()=>Gzip);
parcelHelpers.export(exports, "AsyncGzip", ()=>AsyncGzip);
parcelHelpers.export(exports, "gzip", ()=>gzip);
/**
 * Compresses data with GZIP
 * @param data The data to compress
 * @param opts The compression options
 * @returns The gzipped version of the data
 */ parcelHelpers.export(exports, "gzipSync", ()=>gzipSync);
parcelHelpers.export(exports, "Gunzip", ()=>Gunzip);
parcelHelpers.export(exports, "AsyncGunzip", ()=>AsyncGunzip);
parcelHelpers.export(exports, "gunzip", ()=>gunzip);
/**
 * Expands GZIP data
 * @param data The data to decompress
 * @param opts The decompression options
 * @returns The decompressed version of the data
 */ parcelHelpers.export(exports, "gunzipSync", ()=>gunzipSync);
parcelHelpers.export(exports, "Zlib", ()=>Zlib);
parcelHelpers.export(exports, "AsyncZlib", ()=>AsyncZlib);
parcelHelpers.export(exports, "zlib", ()=>zlib);
/**
 * Compress data with Zlib
 * @param data The data to compress
 * @param opts The compression options
 * @returns The zlib-compressed version of the data
 */ parcelHelpers.export(exports, "zlibSync", ()=>zlibSync);
parcelHelpers.export(exports, "Unzlib", ()=>Unzlib);
parcelHelpers.export(exports, "AsyncUnzlib", ()=>AsyncUnzlib);
parcelHelpers.export(exports, "unzlib", ()=>unzlib);
/**
 * Expands Zlib data
 * @param data The data to decompress
 * @param opts The decompression options
 * @returns The decompressed version of the data
 */ parcelHelpers.export(exports, "unzlibSync", ()=>unzlibSync);
// Default algorithm for compression (used because having a known output size allows faster decompression)
parcelHelpers.export(exports, "compress", ()=>gzip);
parcelHelpers.export(exports, "AsyncCompress", ()=>AsyncGzip);
parcelHelpers.export(exports, "compressSync", ()=>gzipSync);
parcelHelpers.export(exports, "Compress", ()=>Gzip);
parcelHelpers.export(exports, "Decompress", ()=>Decompress);
parcelHelpers.export(exports, "AsyncDecompress", ()=>AsyncDecompress);
parcelHelpers.export(exports, "decompress", ()=>decompress);
/**
 * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format
 * @param data The data to decompress
 * @param opts The decompression options
 * @returns The decompressed version of the data
 */ parcelHelpers.export(exports, "decompressSync", ()=>decompressSync);
parcelHelpers.export(exports, "DecodeUTF8", ()=>DecodeUTF8);
parcelHelpers.export(exports, "EncodeUTF8", ()=>EncodeUTF8);
/**
 * Converts a string into a Uint8Array for use with compression/decompression methods
 * @param str The string to encode
 * @param latin1 Whether or not to interpret the data as Latin-1. This should
 *               not need to be true unless decoding a binary string.
 * @returns The string encoded in UTF-8/Latin-1 binary
 */ parcelHelpers.export(exports, "strToU8", ()=>strToU8);
/**
 * Converts a Uint8Array to a string
 * @param dat The data to decode to string
 * @param latin1 Whether or not to interpret the data as Latin-1. This should
 *               not need to be true unless encoding to binary string.
 * @returns The original UTF-8/Latin-1 string
 */ parcelHelpers.export(exports, "strFromU8", ()=>strFromU8);
parcelHelpers.export(exports, "ZipPassThrough", ()=>ZipPassThrough);
parcelHelpers.export(exports, "ZipDeflate", ()=>ZipDeflate);
parcelHelpers.export(exports, "AsyncZipDeflate", ()=>AsyncZipDeflate);
parcelHelpers.export(exports, "Zip", ()=>Zip);
parcelHelpers.export(exports, "zip", ()=>zip);
/**
 * Synchronously creates a ZIP file. Prefer using `zip` for better performance
 * with more than one file.
 * @param data The directory structure for the ZIP archive
 * @param opts The main options, merged with per-file options
 * @returns The generated ZIP archive
 */ parcelHelpers.export(exports, "zipSync", ()=>zipSync);
parcelHelpers.export(exports, "UnzipPassThrough", ()=>UnzipPassThrough);
parcelHelpers.export(exports, "UnzipInflate", ()=>UnzipInflate);
parcelHelpers.export(exports, "AsyncUnzipInflate", ()=>AsyncUnzipInflate);
parcelHelpers.export(exports, "Unzip", ()=>Unzip);
parcelHelpers.export(exports, "unzip", ()=>unzip);
/**
 * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
 * performance with more than one file.
 * @param data The raw compressed ZIP file
 * @param opts The ZIP extraction options
 * @returns The decompressed files
 */ parcelHelpers.export(exports, "unzipSync", ()=>unzipSync);
var ch2 = {};
var wk = function(c, id, msg, transfer, cb) {
    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
        c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
    ], {
        type: 'text/javascript'
    }))));
    w.onmessage = function(e) {
        var d = e.data, ed = d.$e$;
        if (ed) {
            var err = new Error(ed[0]);
            err['code'] = ed[1];
            err.stack = ed[2];
            cb(err, null);
        } else cb(null, d);
    };
    w.postMessage(msg, transfer);
    return w;
};
// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
// fixed length extra bits
var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */ 0,
    0,
    /* impossible */ 0
]);
// fixed distance extra bits
var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */ 0,
    0
]);
// code length index map
var clim = new u8([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]);
// get base, reverse index map from extra bits
var freb = function(eb, start) {
    var b = new u16(31);
    for(var i = 0; i < 31; ++i)b[i] = start += 1 << eb[i - 1];
    // numbers here are at max 18 bits
    var r = new i32(b[30]);
    for(var i = 1; i < 30; ++i)for(var j = b[i]; j < b[i + 1]; ++j)r[j] = j - b[i] << 5 | i;
    return {
        b: b,
        r: r
    };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for(var i = 0; i < 32768; ++i){
    // reverse table algorithm from SO
    var x = (i & 0xAAAA) >> 1 | (i & 0x5555) << 1;
    x = (x & 0xCCCC) >> 2 | (x & 0x3333) << 2;
    x = (x & 0xF0F0) >> 4 | (x & 0x0F0F) << 4;
    rev[i] = ((x & 0xFF00) >> 8 | (x & 0x00FF) << 8) >> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = function(cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for(; i < s; ++i)if (cd[i]) ++l[cd[i] - 1];
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for(i = 1; i < mb; ++i)le[i] = le[i - 1] + l[i - 1] << 1;
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for(i = 0; i < s; ++i)// ignore 0 lengths
        if (cd[i]) {
            // num encoding both symbol and bits read
            var sv = i << 4 | cd[i];
            // free bits
            var r_1 = mb - cd[i];
            // start value
            var v = le[cd[i] - 1]++ << r_1;
            // m is end value
            for(var m = v | (1 << r_1) - 1; v <= m; ++v)// every 16 bit value starting with the code yields the same result
            co[rev[v] >> rvb] = sv;
        }
    } else {
        co = new u16(s);
        for(i = 0; i < s; ++i)if (cd[i]) co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
    }
    return co;
};
// fixed length tree
var flt = new u8(288);
for(var i = 0; i < 144; ++i)flt[i] = 8;
for(var i = 144; i < 256; ++i)flt[i] = 9;
for(var i = 256; i < 280; ++i)flt[i] = 7;
for(var i = 280; i < 288; ++i)flt[i] = 8;
// fixed distance tree
var fdt = new u8(32);
for(var i = 0; i < 32; ++i)fdt[i] = 5;
// fixed length map
var flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);
// fixed distance map
var fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
// find max of array
var max = function(a) {
    var m = a[0];
    for(var i = 1; i < a.length; ++i)if (a[i] > m) m = a[i];
    return m;
};
// read d, starting at bit p and mask with m
var bits = function(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
// read d, starting at bit p continuing for at least 16 bits
var bits16 = function(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
// get end of byte
var shft = function(p) {
    return (p + 7) / 8 | 0;
};
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function(v, s, e) {
    if (s == null || s < 0) s = 0;
    if (e == null || e > v.length) e = v.length;
    // can't use .constructor in case user-supplied
    return new u8(v.subarray(s, e));
};
var FlateErrorCode = {
    UnexpectedEOF: 0,
    InvalidBlockType: 1,
    InvalidLengthLiteral: 2,
    InvalidDistance: 3,
    StreamFinished: 4,
    NoStreamHandler: 5,
    InvalidHeader: 6,
    NoCallback: 7,
    InvalidUTF8: 8,
    ExtraFieldTooLong: 9,
    InvalidDate: 10,
    FilenameTooLong: 11,
    StreamFinishing: 12,
    InvalidZipData: 13,
    UnknownCompressionMethod: 14
};
// error codes
var ec = [
    'unexpected EOF',
    'invalid block type',
    'invalid length/literal',
    'invalid distance',
    'stream finished',
    'no stream handler',
    ,
    'no callback',
    'invalid UTF-8 data',
    'extra field too long',
    'date not in range 1980-2099',
    'filename too long',
    'stream finishing',
    'invalid zip data'
];
var err = function(ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace) Error.captureStackTrace(e, err);
    if (!nt) throw e;
    return e;
};
// expands raw DEFLATE data
var inflt = function(dat, st, buf, dict) {
    // source length       dict length
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l) return buf || new u8(0);
    var noBuf = !buf;
    // have to estimate size
    var resize = noBuf || st.i != 2;
    // no state
    var noSt = st.i;
    // Assumes roughly 33% compression ratio average
    if (noBuf) buf = new u8(sl * 3);
    // ensure buffer can fit at least l elements
    var cbuf = function(l) {
        var bl = buf.length;
        // need to increase size to fit
        if (l > bl) {
            // Double or set to necessary, whichever is greater
            var nbuf = new u8(Math.max(bl * 2, l));
            nbuf.set(buf);
            buf = nbuf;
        }
    };
    //  last chunk         bitpos           bytes
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    // total bits
    var tbts = sl * 8;
    do {
        if (!lm) {
            // BFINAL - this is only 1 when last chunk is next
            final = bits(dat, pos, 1);
            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
                // go to end of byte boundary
                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
                if (t > sl) {
                    if (noSt) err(0);
                    break;
                }
                // ensure size
                if (resize) cbuf(bt + l);
                // Copy over uncompressed data
                buf.set(dat.subarray(s, t), bt);
                // Get new bitpos, update byte count
                st.b = bt += l, st.p = pos = t * 8, st.f = final;
                continue;
            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
                //  literal                            lengths
                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                var tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14;
                // length+distance tree
                var ldt = new u8(tl);
                // code length tree
                var clt = new u8(19);
                for(var i = 0; i < hcLen; ++i)// use index map to get real code
                clt[clim[i]] = bits(dat, pos + i * 3, 7);
                pos += hcLen * 3;
                // code lengths bits
                var clb = max(clt), clbmsk = (1 << clb) - 1;
                // code lengths map
                var clm = hMap(clt, clb, 1);
                for(var i = 0; i < tl;){
                    var r = clm[bits(dat, pos, clbmsk)];
                    // bits read
                    pos += r & 15;
                    // symbol
                    var s = r >> 4;
                    // code length to copy
                    if (s < 16) ldt[i++] = s;
                    else {
                        //  copy   count
                        var c = 0, n = 0;
                        if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                        else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;
                        else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;
                        while(n--)ldt[i++] = c;
                    }
                }
                //    length tree                 distance tree
                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                // max length bits
                lbt = max(lt);
                // max dist bits
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
            } else err(1);
            if (pos > tbts) {
                if (noSt) err(0);
                break;
            }
        }
        // Make sure the buffer can hold this + the largest possible addition
        // Maximum chunk size (practically, theoretically infinite) is 2^17
        if (resize) cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for(;; lpos = pos){
            // bits read, code
            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
            pos += c & 15;
            if (pos > tbts) {
                if (noSt) err(0);
                break;
            }
            if (!c) err(2);
            if (sym < 256) buf[bt++] = sym;
            else if (sym == 256) {
                lpos = pos, lm = null;
                break;
            } else {
                var add = sym - 254;
                // no extra bits needed if less
                if (sym > 264) {
                    // index
                    var i = sym - 257, b = fleb[i];
                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
                    pos += b;
                }
                // dist
                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
                if (!d) err(3);
                pos += d & 15;
                var dt = fd[dsym];
                if (dsym > 3) {
                    var b = fdeb[dsym];
                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
                }
                if (pos > tbts) {
                    if (noSt) err(0);
                    break;
                }
                if (resize) cbuf(bt + 131072);
                var end = bt + add;
                if (bt < dt) {
                    var shift = dl - dt, dend = Math.min(dt, end);
                    if (shift + bt < 0) err(3);
                    for(; bt < dend; ++bt)buf[bt] = dict[shift + bt];
                }
                for(; bt < end; ++bt)buf[bt] = buf[bt - dt];
            }
        }
        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    }while (!final);
    // don't reallocate for streams or user buffers
    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
// starting at p, write the minimum number of bits that can hold v to d
var wbits = function(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
};
// starting at p, write the minimum number of bits (>8) that can hold v to d
var wbits16 = function(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
    d[o + 2] |= v >> 16;
};
// creates code lengths from a frequency table
var hTree = function(d, mb) {
    // Need extra info to make a tree
    var t = [];
    for(var i = 0; i < d.length; ++i)if (d[i]) t.push({
        s: i,
        f: d[i]
    });
    var s = t.length;
    var t2 = t.slice();
    if (!s) return {
        t: et,
        l: 0
    };
    if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return {
            t: v,
            l: 1
        };
    }
    t.sort(function(a, b) {
        return a.f - b.f;
    });
    // after i2 reaches last ind, will be stopped
    // freq must be greater than largest possible number of symbols
    t.push({
        s: -1,
        f: 25001
    });
    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
    t[0] = {
        s: -1,
        f: l.f + r.f,
        l: l,
        r: r
    };
    // efficient algorithm from UZIP.js
    // i0 is lookbehind, i2 is lookahead - after processing two low-freq
    // symbols that combined have high freq, will start processing i2 (high-freq,
    // non-composite) symbols instead
    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
    while(i1 != s - 1){
        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
        t[i1++] = {
            s: -1,
            f: l.f + r.f,
            l: l,
            r: r
        };
    }
    var maxSym = t2[0].s;
    for(var i = 1; i < s; ++i)if (t2[i].s > maxSym) maxSym = t2[i].s;
    // code lengths
    var tr = new u16(maxSym + 1);
    // max bits in tree
    var mbt = ln(t[i1 - 1], tr, 0);
    if (mbt > mb) {
        // more algorithms from UZIP.js
        // TODO: find out how this code works (debt)
        //  ind    debt
        var i = 0, dt = 0;
        //    left            cost
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function(a, b) {
            return tr[b.s] - tr[a.s] || a.f - b.f;
        });
        for(; i < s; ++i){
            var i2_1 = t2[i].s;
            if (tr[i2_1] > mb) {
                dt += cst - (1 << mbt - tr[i2_1]);
                tr[i2_1] = mb;
            } else break;
        }
        dt >>= lft;
        while(dt > 0){
            var i2_2 = t2[i].s;
            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;
            else ++i;
        }
        for(; i >= 0 && dt; --i){
            var i2_3 = t2[i].s;
            if (tr[i2_3] == mb) {
                --tr[i2_3];
                ++dt;
            }
        }
        mbt = mb;
    }
    return {
        t: new u8(tr),
        l: mbt
    };
};
// get the max length and assign length codes
var ln = function(n, l, d) {
    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
// length codes generation
var lc = function(c) {
    var s = c.length;
    // Note that the semicolon was intentional
    while(s && !c[--s]);
    var cl = new u16(++s);
    //  ind      num         streak
    var cli = 0, cln = c[0], cls = 1;
    var w = function(v) {
        cl[cli++] = v;
    };
    for(var i = 1; i <= s; ++i)if (c[i] == cln && i != s) ++cls;
    else {
        if (!cln && cls > 2) {
            for(; cls > 138; cls -= 138)w(32754);
            if (cls > 2) {
                w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
                cls = 0;
            }
        } else if (cls > 3) {
            w(cln), --cls;
            for(; cls > 6; cls -= 6)w(8304);
            if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
        }
        while(cls--)w(cln);
        cls = 1;
        cln = c[i];
    }
    return {
        c: cl.subarray(0, cli),
        n: s
    };
};
// calculate the length of output from tree, code lengths
var clen = function(cf, cl) {
    var l = 0;
    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];
    return l;
};
// writes a fixed block
// returns the new bit pos
var wfblk = function(out, pos, dat) {
    // no need to write 00 as type: TypedArray defaults to 0
    var s = dat.length;
    var o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
};
// writes a block
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
    wbits(out, p++, final);
    ++lf[256];
    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;
    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;
    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
    var lcfreq = new u16(19);
    for(var i = 0; i < lclt.length; ++i)++lcfreq[lclt[i] & 31];
    for(var i = 0; i < lcdt.length; ++i)++lcfreq[lcdt[i] & 31];
    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
    var nlcc = 19;
    for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);
    var flen = bl + 5 << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
    if (bs >= 0 && flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);
        p += 3 * nlcc;
        var lcts = [
            lclt,
            lcdt
        ];
        for(var it = 0; it < 2; ++it){
            var clct = lcts[it];
            for(var i = 0; i < clct.length; ++i){
                var len = clct[i] & 31;
                wbits(out, p, llm[len]), p += lct[len];
                if (len > 15) wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
            }
        }
    } else lm = flm, ll = flt, dm = fdm, dl = fdt;
    for(var i = 0; i < li; ++i){
        var sym = syms[i];
        if (sym > 255) {
            var len = sym >> 18 & 31;
            wbits16(out, p, lm[len + 257]), p += ll[len + 257];
            if (len > 7) wbits(out, p, sym >> 23 & 31), p += fleb[len];
            var dst = sym & 31;
            wbits16(out, p, dm[dst]), p += dl[dst];
            if (dst > 3) wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
        } else wbits16(out, p, lm[sym]), p += ll[sym];
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
};
// deflate options (nice << 13) | chain
var deo = /*#__PURE__*/ new i32([
    65540,
    131080,
    131088,
    131104,
    262176,
    1048704,
    1048832,
    2114560,
    2117632
]);
// empty
var et = /*#__PURE__*/ new u8(0);
// compresses data into a raw DEFLATE buffer
var dflt = function(dat, lvl, plvl, pre, post, st) {
    var s = st.z || dat.length;
    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
    // writing to this writes to the output buffer
    var w = o.subarray(pre, o.length - post);
    var lst = st.l;
    var pos = (st.r || 0) & 7;
    if (lvl) {
        if (pos) w[0] = st.r >> 3;
        var opt = deo[lvl - 1];
        var n = opt >> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        //    prev 2-byte val map    curr 2-byte val map
        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function(i) {
            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;
        };
        // 24576 is an arbitrary number of maximum symbols per block
        // 424 buffer for last block
        var syms = new i32(25000);
        // length/literal freq   distance freq
        var lf = new u16(288), df = new u16(32);
        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos
        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
        for(; i + 2 < s; ++i){
            // hash value
            var hv = hsh(i);
            // index mod 32768    previous index mod
            var imod = i & 32767, pimod = head[hv];
            prev[imod] = pimod;
            head[hv] = imod;
            // We always should modify head and prev, but only add symbols if
            // this data is not yet processed ("wait" for wait index)
            if (wi <= i) {
                // bytes remaining
                var rem = s - i;
                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {
                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                    li = lc_1 = eb = 0, bs = i;
                    for(var j = 0; j < 286; ++j)lf[j] = 0;
                    for(var j = 0; j < 30; ++j)df[j] = 0;
                }
                //  len    dist   chain
                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
                if (rem > 2 && hv == hsh(i - dif)) {
                    var maxn = Math.min(n, rem) - 1;
                    var maxd = Math.min(32767, i);
                    // max possible length
                    // not capped at dif because decompressors implement "rolling" index population
                    var ml = Math.min(258, rem);
                    while(dif <= maxd && --ch_1 && imod != pimod){
                        if (dat[i + l] == dat[i + l - dif]) {
                            var nl = 0;
                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);
                            if (nl > l) {
                                l = nl, d = dif;
                                // break out early when we reach "nice" (we are satisfied enough)
                                if (nl > maxn) break;
                                // now, find the rarest 2-byte sequence within this
                                // length of literals and search for that instead.
                                // Much faster than just using the start
                                var mmd = Math.min(dif, nl - 2);
                                var md = 0;
                                for(var j = 0; j < mmd; ++j){
                                    var ti = i - dif + j & 32767;
                                    var pti = prev[ti];
                                    var cd = ti - pti & 32767;
                                    if (cd > md) md = cd, pimod = ti;
                                }
                            }
                        }
                        // check the previous match
                        imod = pimod, pimod = prev[imod];
                        dif += imod - pimod & 32767;
                    }
                }
                // d will be nonzero only when a match was found
                if (d) {
                    // store both dist and len data in one int32
                    // Make sure this is recognized as a len/dist with 28th bit (2^28)
                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
                    var lin = revfl[l] & 31, din = revfd[d] & 31;
                    eb += fleb[lin] + fdeb[din];
                    ++lf[257 + lin];
                    ++df[din];
                    wi = i + l;
                    ++lc_1;
                } else {
                    syms[li++] = dat[i];
                    ++lf[dat[i]];
                }
            }
        }
        for(i = Math.max(i, wi); i < s; ++i){
            syms[li++] = dat[i];
            ++lf[dat[i]];
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
        if (!lst) {
            st.r = pos & 7 | w[pos / 8 | 0] << 3;
            // shft(pos) now 1 less if pos & 7 != 0
            pos -= 7;
            st.h = head, st.p = prev, st.i = i, st.w = wi;
        }
    } else {
        for(var i = st.w || 0; i < s + lst; i += 65535){
            // end
            var e = i + 65535;
            if (e >= s) {
                // write final block
                w[pos / 8 | 0] = lst;
                e = s;
            }
            pos = wfblk(w, pos + 1, dat.subarray(i, e));
        }
        st.i = s;
    }
    return slc(o, 0, pre + shft(pos) + post);
};
// CRC32 table
var crct = /*#__PURE__*/ function() {
    var t = new Int32Array(256);
    for(var i = 0; i < 256; ++i){
        var c = i, k = 9;
        while(--k)c = (c & 1 && -306674912) ^ c >>> 1;
        t[i] = c;
    }
    return t;
}();
// CRC32
var crc = function() {
    var c = -1;
    return {
        p: function(d) {
            // closures have awful performance
            var cr = c;
            for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
            c = cr;
        },
        d: function() {
            return ~c;
        }
    };
};
// Adler32
var adler = function() {
    var a = 1, b = 0;
    return {
        p: function(d) {
            // closures have awful performance
            var n = a, m = b;
            var l = d.length | 0;
            for(var i = 0; i != l;){
                var e = Math.min(i + 2655, l);
                for(; i < e; ++i)m += n += d[i];
                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
            }
            a = n, b = m;
        },
        d: function() {
            a %= 65521, b %= 65521;
            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | b >> 8;
        }
    };
};
// deflate with opts
var dopt = function(dat, opt, pre, post, st) {
    if (!st) {
        st = {
            l: 1
        };
        if (opt.dictionary) {
            var dict = opt.dictionary.subarray(-32768);
            var newDat = new u8(dict.length + dat.length);
            newDat.set(dict);
            newDat.set(dat, dict.length);
            dat = newDat;
            st.w = dict.length;
        }
    }
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
};
// Walmart object spread
var mrg = function(a, b) {
    var o = {};
    for(var k in a)o[k] = a[k];
    for(var k in b)o[k] = b[k];
    return o;
};
// worker clone
// This is possibly the craziest part of the entire codebase, despite how simple it may seem.
// The only parameter to this function is a closure that returns an array of variables outside of the function scope.
// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
// This took me three weeks to figure out how to do.
var wcln = function(fn, fnStr, td) {
    var dt = fn();
    var st = fn.toString();
    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\s+/g, '').split(',');
    for(var i = 0; i < dt.length; ++i){
        var v = dt[i], k = ks[i];
        if (typeof v == 'function') {
            fnStr += ';' + k + '=';
            var st_1 = v.toString();
            if (v.prototype) {
                // for global objects
                if (st_1.indexOf('[native code]') != -1) {
                    var spInd = st_1.indexOf(' ', 8) + 1;
                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));
                } else {
                    fnStr += st_1;
                    for(var t in v.prototype)fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();
                }
            } else fnStr += st_1;
        } else td[k] = v;
    }
    return fnStr;
};
var ch = [];
// clone bufs
var cbfs = function(v) {
    var tl = [];
    for(var k in v)if (v[k].buffer) tl.push((v[k] = new v[k].constructor(v[k])).buffer);
    return tl;
};
// use a worker to execute code
var wrkr = function(fns, init, id, cb) {
    if (!ch[id]) {
        var fnStr = '', td_1 = {}, m = fns.length - 1;
        for(var i = 0; i < m; ++i)fnStr = wcln(fns[i], fnStr, td_1);
        ch[id] = {
            c: wcln(fns[m], fnStr, td_1),
            e: td_1
        };
    }
    var td = mrg({}, ch[id].e);
    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);
};
// base async inflate fn
var bInflt = function() {
    return [
        u8,
        u16,
        i32,
        fleb,
        fdeb,
        clim,
        fl,
        fd,
        flrm,
        fdrm,
        rev,
        ec,
        hMap,
        max,
        bits,
        bits16,
        shft,
        slc,
        err,
        inflt,
        inflateSync,
        pbf,
        gopt
    ];
};
var bDflt = function() {
    return [
        u8,
        u16,
        i32,
        fleb,
        fdeb,
        clim,
        revfl,
        revfd,
        flm,
        flt,
        fdm,
        fdt,
        rev,
        deo,
        et,
        hMap,
        wbits,
        wbits16,
        hTree,
        ln,
        lc,
        clen,
        wfblk,
        wblk,
        shft,
        slc,
        dflt,
        dopt,
        deflateSync,
        pbf
    ];
};
// gzip extra
var gze = function() {
    return [
        gzh,
        gzhl,
        wbytes,
        crc,
        crct
    ];
};
// gunzip extra
var guze = function() {
    return [
        gzs,
        gzl
    ];
};
// zlib extra
var zle = function() {
    return [
        zlh,
        wbytes,
        adler
    ];
};
// unzlib extra
var zule = function() {
    return [
        zls
    ];
};
// post buf
var pbf = function(msg) {
    return postMessage(msg, [
        msg.buffer
    ]);
};
// get opts
var gopt = function(o) {
    return o && {
        out: o.size && new u8(o.size),
        dictionary: o.dictionary
    };
};
// async helper
var cbify = function(dat, opts, fns, init, id, cb) {
    var w = wrkr(fns, init, id, function(err, dat) {
        w.terminate();
        cb(err, dat);
    });
    w.postMessage([
        dat,
        opts
    ], opts.consume ? [
        dat.buffer
    ] : []);
    return function() {
        w.terminate();
    };
};
// auto stream
var astrm = function(strm) {
    strm.ondata = function(dat, final) {
        return postMessage([
            dat,
            final
        ], [
            dat.buffer
        ]);
    };
    return function(ev) {
        if (ev.data.length) {
            strm.push(ev.data[0], ev.data[1]);
            postMessage([
                ev.data[0].length
            ]);
        } else strm.flush();
    };
};
// async stream attach
var astrmify = function(fns, strm, opts, init, id, flush, ext) {
    var t;
    var w = wrkr(fns, init, id, function(err, dat) {
        if (err) w.terminate(), strm.ondata.call(strm, err);
        else if (!Array.isArray(dat)) ext(dat);
        else if (dat.length == 1) {
            strm.queuedSize -= dat[0];
            if (strm.ondrain) strm.ondrain(dat[0]);
        } else {
            if (dat[1]) w.terminate();
            strm.ondata.call(strm, err, dat[0], dat[1]);
        }
    });
    w.postMessage(opts);
    strm.queuedSize = 0;
    strm.push = function(d, f) {
        if (!strm.ondata) err(5);
        if (t) strm.ondata(err(4, 0, 1), null, !!f);
        strm.queuedSize += d.length;
        w.postMessage([
            d,
            t = f
        ], [
            d.buffer
        ]);
    };
    strm.terminate = function() {
        w.terminate();
    };
    if (flush) strm.flush = function() {
        w.postMessage([]);
    };
};
// read 2 bytes
var b2 = function(d, b) {
    return d[b] | d[b + 1] << 8;
};
// read 4 bytes
var b4 = function(d, b) {
    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
    return b4(d, b) + b4(d, b + 4) * 4294967296;
};
// write bytes
var wbytes = function(d, b, v) {
    for(; v; ++b)d[b] = v, v >>>= 8;
};
// gzip header
var gzh = function(c, o) {
    var fn = o.filename;
    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix
    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));
    if (fn) {
        c[3] = 8;
        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);
    }
};
// gzip footer: -8 to -4 = CRC, -4 to -0 is length
// gzip start
var gzs = function(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8) err(6, 'invalid gzip data');
    var flg = d[3];
    var st = 10;
    if (flg & 4) st += (d[10] | d[11] << 8) + 2;
    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);
    return st + (flg & 2);
};
// gzip length
var gzl = function(d) {
    var l = d.length;
    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
// gzip header length
var gzhl = function(o) {
    return 10 + (o.filename ? o.filename.length + 1 : 0);
};
// zlib header
var zlh = function(c, o) {
    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
    c[0] = 120, c[1] = fl << 6 | (o.dictionary && 32);
    c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
    if (o.dictionary) {
        var h = adler();
        h.p(o.dictionary);
        wbytes(c, 2, h.d());
    }
};
// zlib start
var zls = function(d, dict) {
    if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31) err(6, 'invalid zlib data');
    if ((d[1] >> 5 & 1) == +!dict) err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');
    return (d[1] >> 3 & 4) + 2;
};
function StrmOpt(opts, cb) {
    if (typeof opts == 'function') cb = opts, opts = {};
    this.ondata = cb;
    return opts;
}
/**
 * Streaming DEFLATE compression
 */ var Deflate = /*#__PURE__*/ function() {
    function Deflate(opts, cb) {
        if (typeof opts == 'function') cb = opts, opts = {};
        this.ondata = cb;
        this.o = opts || {};
        this.s = {
            l: 0,
            i: 32768,
            w: 32768,
            z: 32768
        };
        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev
        // 98304 = 32768 (lookback) + 65536 (common chunk size)
        this.b = new u8(98304);
        if (this.o.dictionary) {
            var dict = this.o.dictionary.subarray(-32768);
            this.b.set(dict, 32768 - dict.length);
            this.s.i = 32768 - dict.length;
        }
    }
    Deflate.prototype.p = function(c, f) {
        this.ondata(dopt(c, this.o, 0, 0, this.s), f);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Deflate.prototype.push = function(chunk, final) {
        if (!this.ondata) err(5);
        if (this.s.l) err(4);
        var endLen = chunk.length + this.s.z;
        if (endLen > this.b.length) {
            if (endLen > 2 * this.b.length - 32768) {
                var newBuf = new u8(endLen & -32768);
                newBuf.set(this.b.subarray(0, this.s.z));
                this.b = newBuf;
            }
            var split = this.b.length - this.s.z;
            this.b.set(chunk.subarray(0, split), this.s.z);
            this.s.z = this.b.length;
            this.p(this.b, false);
            this.b.set(this.b.subarray(-32768));
            this.b.set(chunk.subarray(split), 32768);
            this.s.z = chunk.length - split + 32768;
            this.s.i = 32766, this.s.w = 32768;
        } else {
            this.b.set(chunk, this.s.z);
            this.s.z += chunk.length;
        }
        this.s.l = final & 1;
        if (this.s.z > this.s.w + 8191 || final) {
            this.p(this.b, final || false);
            this.s.w = this.s.i, this.s.i -= 2;
        }
    };
    /**
     * Flushes buffered uncompressed data. Useful to immediately retrieve the
     * deflated output for small inputs.
     */ Deflate.prototype.flush = function() {
        if (!this.ondata) err(5);
        if (this.s.l) err(4);
        this.p(this.b, false);
        this.s.w = this.s.i, this.s.i -= 2;
    };
    return Deflate;
}();
/**
 * Asynchronous streaming DEFLATE compression
 */ var AsyncDeflate = /*#__PURE__*/ function() {
    function AsyncDeflate(opts, cb) {
        astrmify([
            bDflt,
            function() {
                return [
                    astrm,
                    Deflate
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Deflate(ev.data);
            onmessage = astrm(strm);
        }, 6, 1);
    }
    return AsyncDeflate;
}();
function deflate(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bDflt
    ], function(ev) {
        return pbf(deflateSync(ev.data[0], ev.data[1]));
    }, 0, cb);
}
function deflateSync(data, opts) {
    return dopt(data, opts || {}, 0, 0);
}
/**
 * Streaming DEFLATE decompression
 */ var Inflate = /*#__PURE__*/ function() {
    function Inflate(opts, cb) {
        // no StrmOpt here to avoid adding to workerizer
        if (typeof opts == 'function') cb = opts, opts = {};
        this.ondata = cb;
        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
        this.s = {
            i: 0,
            b: dict ? dict.length : 0
        };
        this.o = new u8(32768);
        this.p = new u8(0);
        if (dict) this.o.set(dict);
    }
    Inflate.prototype.e = function(c) {
        if (!this.ondata) err(5);
        if (this.d) err(4);
        if (!this.p.length) this.p = c;
        else if (c.length) {
            var n = new u8(this.p.length + c.length);
            n.set(this.p), n.set(c, this.p.length), this.p = n;
        }
    };
    Inflate.prototype.c = function(final) {
        this.s.i = +(this.d = final || false);
        var bts = this.s.b;
        var dt = inflt(this.p, this.s, this.o);
        this.ondata(slc(dt, bts, this.s.b), this.d);
        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    };
    /**
     * Pushes a chunk to be inflated
     * @param chunk The chunk to push
     * @param final Whether this is the final chunk
     */ Inflate.prototype.push = function(chunk, final) {
        this.e(chunk), this.c(final);
    };
    return Inflate;
}();
/**
 * Asynchronous streaming DEFLATE decompression
 */ var AsyncInflate = /*#__PURE__*/ function() {
    function AsyncInflate(opts, cb) {
        astrmify([
            bInflt,
            function() {
                return [
                    astrm,
                    Inflate
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Inflate(ev.data);
            onmessage = astrm(strm);
        }, 7, 0);
    }
    return AsyncInflate;
}();
function inflate(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bInflt
    ], function(ev) {
        return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));
    }, 1, cb);
}
function inflateSync(data, opts) {
    return inflt(data, {
        i: 2
    }, opts && opts.out, opts && opts.dictionary);
}
// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.
/**
 * Streaming GZIP compression
 */ var Gzip = /*#__PURE__*/ function() {
    function Gzip(opts, cb) {
        this.c = crc();
        this.l = 0;
        this.v = 1;
        Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be GZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Gzip.prototype.push = function(chunk, final) {
        this.c.p(chunk);
        this.l += chunk.length;
        Deflate.prototype.push.call(this, chunk, final);
    };
    Gzip.prototype.p = function(c, f) {
        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);
        if (this.v) gzh(raw, this.o), this.v = 0;
        if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
        this.ondata(raw, f);
    };
    /**
     * Flushes buffered uncompressed data. Useful to immediately retrieve the
     * GZIPped output for small inputs.
     */ Gzip.prototype.flush = function() {
        Deflate.prototype.flush.call(this);
    };
    return Gzip;
}();
/**
 * Asynchronous streaming GZIP compression
 */ var AsyncGzip = /*#__PURE__*/ function() {
    function AsyncGzip(opts, cb) {
        astrmify([
            bDflt,
            gze,
            function() {
                return [
                    astrm,
                    Deflate,
                    Gzip
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Gzip(ev.data);
            onmessage = astrm(strm);
        }, 8, 1);
    }
    return AsyncGzip;
}();
function gzip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bDflt,
        gze,
        function() {
            return [
                gzipSync
            ];
        }
    ], function(ev) {
        return pbf(gzipSync(ev.data[0], ev.data[1]));
    }, 2, cb);
}
function gzipSync(data, opts) {
    if (!opts) opts = {};
    var c = crc(), l = data.length;
    c.p(data);
    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
/**
 * Streaming single or multi-member GZIP decompression
 */ var Gunzip = /*#__PURE__*/ function() {
    function Gunzip(opts, cb) {
        this.v = 1;
        this.r = 0;
        Inflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be GUNZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Gunzip.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        this.r += chunk.length;
        if (this.v) {
            var p = this.p.subarray(this.v - 1);
            var s = p.length > 3 ? gzs(p) : 4;
            if (s > p.length) {
                if (!final) return;
            } else if (this.v > 1 && this.onmember) this.onmember(this.r - p.length);
            this.p = p.subarray(s), this.v = 0;
        }
        // necessary to prevent TS from using the closure value
        // This allows for workerization to function correctly
        Inflate.prototype.c.call(this, final);
        // process concatenated GZIP
        if (this.s.f && !this.s.l && !final) {
            this.v = shft(this.s.p) + 9;
            this.s = {
                i: 0
            };
            this.o = new u8(0);
            this.push(new u8(0), final);
        }
    };
    return Gunzip;
}();
/**
 * Asynchronous streaming single or multi-member GZIP decompression
 */ var AsyncGunzip = /*#__PURE__*/ function() {
    function AsyncGunzip(opts, cb) {
        var _this = this;
        astrmify([
            bInflt,
            guze,
            function() {
                return [
                    astrm,
                    Inflate,
                    Gunzip
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Gunzip(ev.data);
            strm.onmember = function(offset) {
                return postMessage(offset);
            };
            onmessage = astrm(strm);
        }, 9, 0, function(offset) {
            return _this.onmember && _this.onmember(offset);
        });
    }
    return AsyncGunzip;
}();
function gunzip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bInflt,
        guze,
        function() {
            return [
                gunzipSync
            ];
        }
    ], function(ev) {
        return pbf(gunzipSync(ev.data[0], ev.data[1]));
    }, 3, cb);
}
function gunzipSync(data, opts) {
    var st = gzs(data);
    if (st + 8 > data.length) err(6, 'invalid gzip data');
    return inflt(data.subarray(st, -8), {
        i: 2
    }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
/**
 * Streaming Zlib compression
 */ var Zlib = /*#__PURE__*/ function() {
    function Zlib(opts, cb) {
        this.c = adler();
        this.v = 1;
        Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be zlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Zlib.prototype.push = function(chunk, final) {
        this.c.p(chunk);
        Deflate.prototype.push.call(this, chunk, final);
    };
    Zlib.prototype.p = function(c, f) {
        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);
        if (this.v) zlh(raw, this.o), this.v = 0;
        if (f) wbytes(raw, raw.length - 4, this.c.d());
        this.ondata(raw, f);
    };
    /**
     * Flushes buffered uncompressed data. Useful to immediately retrieve the
     * zlibbed output for small inputs.
     */ Zlib.prototype.flush = function() {
        Deflate.prototype.flush.call(this);
    };
    return Zlib;
}();
/**
 * Asynchronous streaming Zlib compression
 */ var AsyncZlib = /*#__PURE__*/ function() {
    function AsyncZlib(opts, cb) {
        astrmify([
            bDflt,
            zle,
            function() {
                return [
                    astrm,
                    Deflate,
                    Zlib
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Zlib(ev.data);
            onmessage = astrm(strm);
        }, 10, 1);
    }
    return AsyncZlib;
}();
function zlib(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bDflt,
        zle,
        function() {
            return [
                zlibSync
            ];
        }
    ], function(ev) {
        return pbf(zlibSync(ev.data[0], ev.data[1]));
    }, 4, cb);
}
function zlibSync(data, opts) {
    if (!opts) opts = {};
    var a = adler();
    a.p(data);
    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
}
/**
 * Streaming Zlib decompression
 */ var Unzlib = /*#__PURE__*/ function() {
    function Unzlib(opts, cb) {
        Inflate.call(this, opts, cb);
        this.v = opts && opts.dictionary ? 2 : 1;
    }
    /**
     * Pushes a chunk to be unzlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Unzlib.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
            if (this.p.length < 6 && !final) return;
            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
        }
        if (final) {
            if (this.p.length < 4) err(6, 'invalid zlib data');
            this.p = this.p.subarray(0, -4);
        }
        // necessary to prevent TS from using the closure value
        // This allows for workerization to function correctly
        Inflate.prototype.c.call(this, final);
    };
    return Unzlib;
}();
/**
 * Asynchronous streaming Zlib decompression
 */ var AsyncUnzlib = /*#__PURE__*/ function() {
    function AsyncUnzlib(opts, cb) {
        astrmify([
            bInflt,
            zule,
            function() {
                return [
                    astrm,
                    Inflate,
                    Unzlib
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Unzlib(ev.data);
            onmessage = astrm(strm);
        }, 11, 0);
    }
    return AsyncUnzlib;
}();
function unzlib(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bInflt,
        zule,
        function() {
            return [
                unzlibSync
            ];
        }
    ], function(ev) {
        return pbf(unzlibSync(ev.data[0], gopt(ev.data[1])));
    }, 5, cb);
}
function unzlibSync(data, opts) {
    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), {
        i: 2
    }, opts && opts.out, opts && opts.dictionary);
}
/**
 * Streaming GZIP, Zlib, or raw DEFLATE decompression
 */ var Decompress = /*#__PURE__*/ function() {
    function Decompress(opts, cb) {
        this.o = StrmOpt.call(this, opts, cb) || {};
        this.G = Gunzip;
        this.I = Inflate;
        this.Z = Unzlib;
    }
    // init substream
    // overriden by AsyncDecompress
    Decompress.prototype.i = function() {
        var _this = this;
        this.s.ondata = function(dat, final) {
            _this.ondata(dat, final);
        };
    };
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Decompress.prototype.push = function(chunk, final) {
        if (!this.ondata) err(5);
        if (!this.s) {
            if (this.p && this.p.length) {
                var n = new u8(this.p.length + chunk.length);
                n.set(this.p), n.set(chunk, this.p.length);
            } else this.p = chunk;
            if (this.p.length > 2) {
                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
                this.i();
                this.s.push(this.p, final);
                this.p = null;
            }
        } else this.s.push(chunk, final);
    };
    return Decompress;
}();
/**
 * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
 */ var AsyncDecompress = /*#__PURE__*/ function() {
    function AsyncDecompress(opts, cb) {
        Decompress.call(this, opts, cb);
        this.queuedSize = 0;
        this.G = AsyncGunzip;
        this.I = AsyncInflate;
        this.Z = AsyncUnzlib;
    }
    AsyncDecompress.prototype.i = function() {
        var _this = this;
        this.s.ondata = function(err, dat, final) {
            _this.ondata(err, dat, final);
        };
        this.s.ondrain = function(size) {
            _this.queuedSize -= size;
            if (_this.ondrain) _this.ondrain(size);
        };
    };
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ AsyncDecompress.prototype.push = function(chunk, final) {
        this.queuedSize += chunk.length;
        Decompress.prototype.push.call(this, chunk, final);
    };
    return AsyncDecompress;
}();
function decompress(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);
}
function decompressSync(data, opts) {
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
// flatten a directory structure
var fltn = function(d, p, t, o) {
    for(var k in d){
        var val = d[k], n = p + k, op = o;
        if (Array.isArray(val)) op = mrg(o, val[1]), val = val[0];
        if (val instanceof u8) t[n] = [
            val,
            op
        ];
        else {
            t[n += '/'] = [
                new u8(0),
                op
            ];
            fltn(val, n, t, o);
        }
    }
};
// text encoder
var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et, {
        stream: true
    });
    tds = 1;
} catch (e) {}
// decode UTF8
var dutf8 = function(d) {
    for(var r = '', i = 0;;){
        var c = d[i++];
        var eb = (c > 127) + (c > 223) + (c > 239);
        if (i + eb > d.length) return {
            s: r,
            r: slc(d, i - 1)
        };
        if (!eb) r += String.fromCharCode(c);
        else if (eb == 3) c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
    }
};
/**
 * Streaming UTF-8 decoding
 */ var DecodeUTF8 = /*#__PURE__*/ function() {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is decoded
     */ function DecodeUTF8(cb) {
        this.ondata = cb;
        if (tds) this.t = new TextDecoder();
        else this.p = et;
    }
    /**
     * Pushes a chunk to be decoded from UTF-8 binary
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ DecodeUTF8.prototype.push = function(chunk, final) {
        if (!this.ondata) err(5);
        final = !!final;
        if (this.t) {
            this.ondata(this.t.decode(chunk, {
                stream: true
            }), final);
            if (final) {
                if (this.t.decode().length) err(8);
                this.t = null;
            }
            return;
        }
        if (!this.p) err(4);
        var dat = new u8(this.p.length + chunk.length);
        dat.set(this.p);
        dat.set(chunk, this.p.length);
        var _a = dutf8(dat), s = _a.s, r = _a.r;
        if (final) {
            if (r.length) err(8);
            this.p = null;
        } else this.p = r;
        this.ondata(s, final);
    };
    return DecodeUTF8;
}();
/**
 * Streaming UTF-8 encoding
 */ var EncodeUTF8 = /*#__PURE__*/ function() {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is encoded
     */ function EncodeUTF8(cb) {
        this.ondata = cb;
    }
    /**
     * Pushes a chunk to be encoded to UTF-8
     * @param chunk The string data to push
     * @param final Whether this is the last chunk
     */ EncodeUTF8.prototype.push = function(chunk, final) {
        if (!this.ondata) err(5);
        if (this.d) err(4);
        this.ondata(strToU8(chunk), this.d = final || false);
    };
    return EncodeUTF8;
}();
function strToU8(str, latin1) {
    if (latin1) {
        var ar_1 = new u8(str.length);
        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);
        return ar_1;
    }
    if (te) return te.encode(str);
    var l = str.length;
    var ar = new u8(str.length + (str.length >> 1));
    var ai = 0;
    var w = function(v) {
        ar[ai++] = v;
    };
    for(var i = 0; i < l; ++i){
        if (ai + 5 > ar.length) {
            var n = new u8(ai + 8 + (l - i << 1));
            n.set(ar);
            ar = n;
        }
        var c = str.charCodeAt(i);
        if (c < 128 || latin1) w(c);
        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);
        else if (c > 55295 && c < 57344) c = 65536 + (c & 1047552) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
    }
    return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
    if (latin1) {
        var r = '';
        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
        return r;
    } else if (td) return td.decode(dat);
    else {
        var _a = dutf8(dat), s = _a.s, r = _a.r;
        if (r.length) err(8);
        return s;
    }
}
// deflate bit flag
var dbf = function(l) {
    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
// skip local zip header
var slzh = function(d, b) {
    return b + 30 + b2(d, b + 26) + b2(d, b + 28);
};
// read zip header
var zh = function(d, b, z) {
    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
    var _a = z && bs == 4294967295 ? z64e(d, es) : [
        bs,
        b4(d, b + 24),
        b4(d, b + 42)
    ], sc = _a[0], su = _a[1], off = _a[2];
    return [
        b2(d, b + 10),
        sc,
        su,
        fn,
        es + b2(d, b + 30) + b2(d, b + 32),
        off
    ];
};
// read zip64 extra field
var z64e = function(d, b) {
    for(; b2(d, b) != 1; b += 4 + b2(d, b + 2));
    return [
        b8(d, b + 12),
        b8(d, b + 4),
        b8(d, b + 20)
    ];
};
// extra field length
var exfl = function(ex) {
    var le = 0;
    if (ex) for(var k in ex){
        var l = ex[k].length;
        if (l > 65535) err(9);
        le += l + 4;
    }
    return le;
};
// write zip header
var wzh = function(d, b, f, fn, u, c, ce, co) {
    var fl = fn.length, ex = f.extra, col = co && co.length;
    var exl = exfl(ex);
    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
    if (ce != null) d[b++] = 20, d[b++] = f.os;
    d[b] = 20, b += 2; // spec compliance? what's that?
    d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
    if (y < 0 || y > 119) err(10);
    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
    if (c != -1) {
        wbytes(d, b, f.crc);
        wbytes(d, b + 4, c < 0 ? -c - 2 : c);
        wbytes(d, b + 8, f.size);
    }
    wbytes(d, b + 12, fl);
    wbytes(d, b + 14, exl), b += 16;
    if (ce != null) {
        wbytes(d, b, col);
        wbytes(d, b + 6, f.attrs);
        wbytes(d, b + 10, ce), b += 14;
    }
    d.set(fn, b);
    b += fl;
    if (exl) for(var k in ex){
        var exf = ex[k], l = exf.length;
        wbytes(d, b, +k);
        wbytes(d, b + 2, l);
        d.set(exf, b + 4), b += 4 + l;
    }
    if (col) d.set(co, b), b += col;
    return b;
};
// write zip footer (end of central directory)
var wzf = function(o, b, c, d, e) {
    wbytes(o, b, 0x6054B50); // skip disk
    wbytes(o, b + 8, c);
    wbytes(o, b + 10, c);
    wbytes(o, b + 12, d);
    wbytes(o, b + 16, e);
};
/**
 * A pass-through stream to keep data uncompressed in a ZIP archive.
 */ var ZipPassThrough = /*#__PURE__*/ function() {
    /**
     * Creates a pass-through stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     */ function ZipPassThrough(filename) {
        this.filename = filename;
        this.c = crc();
        this.size = 0;
        this.compression = 0;
    }
    /**
     * Processes a chunk and pushes to the output stream. You can override this
     * method in a subclass for custom behavior, but by default this passes
     * the data through. You must call this.ondata(err, chunk, final) at some
     * point in this method.
     * @param chunk The chunk to process
     * @param final Whether this is the last chunk
     */ ZipPassThrough.prototype.process = function(chunk, final) {
        this.ondata(null, chunk, final);
    };
    /**
     * Pushes a chunk to be added. If you are subclassing this with a custom
     * compression algorithm, note that you must push data from the source
     * file only, pre-compression.
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ ZipPassThrough.prototype.push = function(chunk, final) {
        if (!this.ondata) err(5);
        this.c.p(chunk);
        this.size += chunk.length;
        if (final) this.crc = this.c.d();
        this.process(chunk, final || false);
    };
    return ZipPassThrough;
}();
// I don't extend because TypeScript extension adds 1kB of runtime bloat
/**
 * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate
 * for better performance
 */ var ZipDeflate = /*#__PURE__*/ function() {
    /**
     * Creates a DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */ function ZipDeflate(filename, opts) {
        var _this = this;
        if (!opts) opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new Deflate(opts, function(dat, final) {
            _this.ondata(null, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
    }
    ZipDeflate.prototype.process = function(chunk, final) {
        try {
            this.d.push(chunk, final);
        } catch (e) {
            this.ondata(e, null, final);
        }
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ ZipDeflate.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
    };
    return ZipDeflate;
}();
/**
 * Asynchronous streaming DEFLATE compression for ZIP archives
 */ var AsyncZipDeflate = /*#__PURE__*/ function() {
    /**
     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */ function AsyncZipDeflate(filename, opts) {
        var _this = this;
        if (!opts) opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new AsyncDeflate(opts, function(err, dat, final) {
            _this.ondata(err, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
        this.terminate = this.d.terminate;
    }
    AsyncZipDeflate.prototype.process = function(chunk, final) {
        this.d.push(chunk, final);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ AsyncZipDeflate.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
    };
    return AsyncZipDeflate;
}();
// TODO: Better tree shaking
/**
 * A zippable archive to which files can incrementally be added
 */ var Zip = /*#__PURE__*/ function() {
    /**
     * Creates an empty ZIP archive to which files can be added
     * @param cb The callback to call whenever data for the generated ZIP archive
     *           is available
     */ function Zip(cb) {
        this.ondata = cb;
        this.u = [];
        this.d = 1;
    }
    /**
     * Adds a file to the ZIP archive
     * @param file The file stream to add
     */ Zip.prototype.add = function(file) {
        var _this = this;
        if (!this.ondata) err(5);
        // finishing or finished
        if (this.d & 2) this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
        else {
            var f = strToU8(file.filename), fl_1 = f.length;
            var com = file.comment, o = com && strToU8(com);
            var u = fl_1 != file.filename.length || o && com.length != o.length;
            var hl_1 = fl_1 + exfl(file.extra) + 30;
            if (fl_1 > 65535) this.ondata(err(11, 0, 1), null, false);
            var header = new u8(hl_1);
            wzh(header, 0, file, f, u, -1);
            var chks_1 = [
                header
            ];
            var pAll_1 = function() {
                for(var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++){
                    var chk = chks_2[_i];
                    _this.ondata(null, chk, false);
                }
                chks_1 = [];
            };
            var tr_1 = this.d;
            this.d = 0;
            var ind_1 = this.u.length;
            var uf_1 = mrg(file, {
                f: f,
                u: u,
                o: o,
                t: function() {
                    if (file.terminate) file.terminate();
                },
                r: function() {
                    pAll_1();
                    if (tr_1) {
                        var nxt = _this.u[ind_1 + 1];
                        if (nxt) nxt.r();
                        else _this.d = 1;
                    }
                    tr_1 = 1;
                }
            });
            var cl_1 = 0;
            file.ondata = function(err, dat, final) {
                if (err) {
                    _this.ondata(err, dat, final);
                    _this.terminate();
                } else {
                    cl_1 += dat.length;
                    chks_1.push(dat);
                    if (final) {
                        var dd = new u8(16);
                        wbytes(dd, 0, 0x8074B50);
                        wbytes(dd, 4, file.crc);
                        wbytes(dd, 8, cl_1);
                        wbytes(dd, 12, file.size);
                        chks_1.push(dd);
                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
                        if (tr_1) uf_1.r();
                        tr_1 = 1;
                    } else if (tr_1) pAll_1();
                }
            };
            this.u.push(uf_1);
        }
    };
    /**
     * Ends the process of adding files and prepares to emit the final chunks.
     * This *must* be called after adding all desired files for the resulting
     * ZIP file to work properly.
     */ Zip.prototype.end = function() {
        var _this = this;
        if (this.d & 2) {
            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
            return;
        }
        if (this.d) this.e();
        else this.u.push({
            r: function() {
                if (!(_this.d & 1)) return;
                _this.u.splice(-1, 1);
                _this.e();
            },
            t: function() {}
        });
        this.d = 3;
    };
    Zip.prototype.e = function() {
        var bt = 0, l = 0, tl = 0;
        for(var _i = 0, _a = this.u; _i < _a.length; _i++){
            var f = _a[_i];
            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
        }
        var out = new u8(tl + 22);
        for(var _b = 0, _c = this.u; _b < _c.length; _b++){
            var f = _c[_b];
            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);
            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
        }
        wzf(out, bt, this.u.length, tl, l);
        this.ondata(null, out, true);
        this.d = 2;
    };
    /**
     * A method to terminate any internal workers used by the stream. Subsequent
     * calls to add() will fail.
     */ Zip.prototype.terminate = function() {
        for(var _i = 0, _a = this.u; _i < _a.length; _i++){
            var f = _a[_i];
            f.t();
        }
        this.d = 2;
    };
    return Zip;
}();
function zip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    var r = {};
    fltn(data, '', r, opts);
    var k = Object.keys(r);
    var lft = k.length, o = 0, tot = 0;
    var slft = lft, files = new Array(lft);
    var term = [];
    var tAll = function() {
        for(var i = 0; i < term.length; ++i)term[i]();
    };
    var cbd = function(a, b) {
        mt(function() {
            cb(a, b);
        });
    };
    mt(function() {
        cbd = cb;
    });
    var cbf = function() {
        var out = new u8(tot + 22), oe = o, cdl = tot - o;
        tot = 0;
        for(var i = 0; i < slft; ++i){
            var f = files[i];
            try {
                var l = f.c.length;
                wzh(out, tot, f, f.f, f.u, l);
                var badd = 30 + f.f.length + exfl(f.extra);
                var loc = tot + badd;
                out.set(f.c, loc);
                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;
            } catch (e) {
                return cbd(e, null);
            }
        }
        wzf(out, o, files.length, cdl, oe);
        cbd(null, out);
    };
    if (!lft) cbf();
    var _loop_1 = function(i) {
        var fn = k[i];
        var _a = r[fn], file = _a[0], p = _a[1];
        var c = crc(), size = file.length;
        c.p(file);
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        var compression = p.level == 0 ? 0 : 8;
        var cbl = function(e, d) {
            if (e) {
                tAll();
                cbd(e, null);
            } else {
                var l = d.length;
                files[i] = mrg(p, {
                    size: size,
                    crc: c.d(),
                    c: d,
                    f: f,
                    m: m,
                    u: s != fn.length || m && com.length != ms,
                    compression: compression
                });
                o += 30 + s + exl + l;
                tot += 76 + 2 * (s + exl) + (ms || 0) + l;
                if (!--lft) cbf();
            }
        };
        if (s > 65535) cbl(err(11, 0, 1), null);
        if (!compression) cbl(null, file);
        else if (size < 160000) try {
            cbl(null, deflateSync(file, p));
        } catch (e) {
            cbl(e, null);
        }
        else term.push(deflate(file, p, cbl));
    };
    // Cannot use lft because it can decrease
    for(var i = 0; i < slft; ++i)_loop_1(i);
    return tAll;
}
function zipSync(data, opts) {
    if (!opts) opts = {};
    var r = {};
    var files = [];
    fltn(data, '', r, opts);
    var o = 0;
    var tot = 0;
    for(var fn in r){
        var _a = r[fn], file = _a[0], p = _a[1];
        var compression = p.level == 0 ? 0 : 8;
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        if (s > 65535) err(11);
        var d = compression ? deflateSync(file, p) : file, l = d.length;
        var c = crc();
        c.p(file);
        files.push(mrg(p, {
            size: file.length,
            crc: c.d(),
            c: d,
            f: f,
            m: m,
            u: s != fn.length || m && com.length != ms,
            o: o,
            compression: compression
        }));
        o += 30 + s + exl + l;
        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
    }
    var out = new u8(tot + 22), oe = o, cdl = tot - o;
    for(var i = 0; i < files.length; ++i){
        var f = files[i];
        wzh(out, f.o, f, f.f, f.u, f.c.length);
        var badd = 30 + f.f.length + exfl(f.extra);
        out.set(f.c, f.o + badd);
        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
    }
    wzf(out, o, files.length, cdl, oe);
    return out;
}
/**
 * Streaming pass-through decompression for ZIP archives
 */ var UnzipPassThrough = /*#__PURE__*/ function() {
    function UnzipPassThrough() {}
    UnzipPassThrough.prototype.push = function(data, final) {
        this.ondata(null, data, final);
    };
    UnzipPassThrough.compression = 0;
    return UnzipPassThrough;
}();
/**
 * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for
 * better performance.
 */ var UnzipInflate = /*#__PURE__*/ function() {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */ function UnzipInflate() {
        var _this = this;
        this.i = new Inflate(function(dat, final) {
            _this.ondata(null, dat, final);
        });
    }
    UnzipInflate.prototype.push = function(data, final) {
        try {
            this.i.push(data, final);
        } catch (e) {
            this.ondata(e, null, final);
        }
    };
    UnzipInflate.compression = 8;
    return UnzipInflate;
}();
/**
 * Asynchronous streaming DEFLATE decompression for ZIP archives
 */ var AsyncUnzipInflate = /*#__PURE__*/ function() {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */ function AsyncUnzipInflate(_, sz) {
        var _this = this;
        if (sz < 320000) this.i = new Inflate(function(dat, final) {
            _this.ondata(null, dat, final);
        });
        else {
            this.i = new AsyncInflate(function(err, dat, final) {
                _this.ondata(err, dat, final);
            });
            this.terminate = this.i.terminate;
        }
    }
    AsyncUnzipInflate.prototype.push = function(data, final) {
        if (this.i.terminate) data = slc(data, 0);
        this.i.push(data, final);
    };
    AsyncUnzipInflate.compression = 8;
    return AsyncUnzipInflate;
}();
/**
 * A ZIP archive decompression stream that emits files as they are discovered
 */ var Unzip = /*#__PURE__*/ function() {
    /**
     * Creates a ZIP decompression stream
     * @param cb The callback to call whenever a file in the ZIP archive is found
     */ function Unzip(cb) {
        this.onfile = cb;
        this.k = [];
        this.o = {
            0: UnzipPassThrough
        };
        this.p = et;
    }
    /**
     * Pushes a chunk to be unzipped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Unzip.prototype.push = function(chunk, final) {
        var _this = this;
        if (!this.onfile) err(5);
        if (!this.p) err(4);
        if (this.c > 0) {
            var len = Math.min(this.c, chunk.length);
            var toAdd = chunk.subarray(0, len);
            this.c -= len;
            if (this.d) this.d.push(toAdd, !this.c);
            else this.k[0].push(toAdd);
            chunk = chunk.subarray(len);
            if (chunk.length) return this.push(chunk, final);
        } else {
            var f = 0, i = 0, is = void 0, buf = void 0;
            if (!this.p.length) buf = chunk;
            else if (!chunk.length) buf = this.p;
            else {
                buf = new u8(this.p.length + chunk.length);
                buf.set(this.p), buf.set(chunk, this.p.length);
            }
            var l = buf.length, oc = this.c, add = oc && this.d;
            var _loop_2 = function() {
                var _a;
                var sig = b4(buf, i);
                if (sig == 0x4034B50) {
                    f = 1, is = i;
                    this_1.d = null;
                    this_1.c = 0;
                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
                    if (l > i + 30 + fnl + es) {
                        var chks_3 = [];
                        this_1.k.unshift(chks_3);
                        f = 2;
                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
                        if (sc_1 == 4294967295) _a = dd ? [
                            -2
                        ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];
                        else if (dd) sc_1 = -1;
                        i += es;
                        this_1.c = sc_1;
                        var d_1;
                        var file_1 = {
                            name: fn_1,
                            compression: cmp_1,
                            start: function() {
                                if (!file_1.ondata) err(5);
                                if (!sc_1) file_1.ondata(null, et, true);
                                else {
                                    var ctr = _this.o[cmp_1];
                                    if (!ctr) file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);
                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                                    d_1.ondata = function(err, dat, final) {
                                        file_1.ondata(err, dat, final);
                                    };
                                    for(var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++){
                                        var dat = chks_4[_i];
                                        d_1.push(dat, false);
                                    }
                                    if (_this.k[0] == chks_3 && _this.c) _this.d = d_1;
                                    else d_1.push(et, true);
                                }
                            },
                            terminate: function() {
                                if (d_1 && d_1.terminate) d_1.terminate();
                            }
                        };
                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;
                        this_1.onfile(file_1);
                    }
                    return "break";
                } else if (oc) {
                    if (sig == 0x8074B50) {
                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
                        return "break";
                    } else if (sig == 0x2014B50) {
                        is = i -= 4, f = 3, this_1.c = 0;
                        return "break";
                    }
                }
            };
            var this_1 = this;
            for(; i < l - 4; ++i){
                var state_1 = _loop_2();
                if (state_1 === "break") break;
            }
            this.p = et;
            if (oc < 0) {
                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);
                if (add) add.push(dat, !!f);
                else this.k[+(f == 2)].push(dat);
            }
            if (f & 2) return this.push(buf.subarray(i), final);
            this.p = buf.subarray(i);
        }
        if (final) {
            if (this.c) err(13);
            this.p = null;
        }
    };
    /**
     * Registers a decoder with the stream, allowing for files compressed with
     * the compression type provided to be expanded correctly
     * @param decoder The decoder constructor
     */ Unzip.prototype.register = function(decoder) {
        this.o[decoder.compression] = decoder;
    };
    return Unzip;
}();
var mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function(fn) {
    fn();
};
function unzip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    var term = [];
    var tAll = function() {
        for(var i = 0; i < term.length; ++i)term[i]();
    };
    var files = {};
    var cbd = function(a, b) {
        mt(function() {
            cb(a, b);
        });
    };
    mt(function() {
        cbd = cb;
    });
    var e = data.length - 22;
    for(; b4(data, e) != 0x6054B50; --e)if (!e || data.length - e > 65558) {
        cbd(err(13, 0, 1), null);
        return tAll;
    }
    var lft = b2(data, e + 8);
    if (lft) {
        var c = lft;
        var o = b4(data, e + 16);
        var z = o == 4294967295 || c == 65535;
        if (z) {
            var ze = b4(data, e - 12);
            z = b4(data, ze) == 0x6064B50;
            if (z) {
                c = lft = b4(data, ze + 32);
                o = b4(data, ze + 48);
            }
        }
        var fltr = opts && opts.filter;
        var _loop_3 = function(i) {
            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
            o = no;
            var cbl = function(e, d) {
                if (e) {
                    tAll();
                    cbd(e, null);
                } else {
                    if (d) files[fn] = d;
                    if (!--lft) cbd(null, files);
                }
            };
            if (!fltr || fltr({
                name: fn,
                size: sc,
                originalSize: su,
                compression: c_1
            })) {
                if (!c_1) cbl(null, slc(data, b, b + sc));
                else if (c_1 == 8) {
                    var infl = data.subarray(b, b + sc);
                    // Synchronously decompress under 512KB, or barely-compressed data
                    if (su < 524288 || sc > 0.8 * su) try {
                        cbl(null, inflateSync(infl, {
                            out: new u8(su)
                        }));
                    } catch (e) {
                        cbl(e, null);
                    }
                    else term.push(inflate(infl, {
                        size: su
                    }, cbl));
                } else cbl(err(14, 'unknown compression type ' + c_1, 1), null);
            } else cbl(null, null);
        };
        for(var i = 0; i < c; ++i)_loop_3(i);
    } else cbd(null, {});
    return tAll;
}
function unzipSync(data, opts) {
    var files = {};
    var e = data.length - 22;
    for(; b4(data, e) != 0x6054B50; --e)if (!e || data.length - e > 65558) err(13);
    var c = b2(data, e + 8);
    if (!c) return {};
    var o = b4(data, e + 16);
    var z = o == 4294967295 || c == 65535;
    if (z) {
        var ze = b4(data, e - 12);
        z = b4(data, ze) == 0x6064B50;
        if (z) {
            c = b4(data, ze + 32);
            o = b4(data, ze + 48);
        }
    }
    var fltr = opts && opts.filter;
    for(var i = 0; i < c; ++i){
        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
        o = no;
        if (!fltr || fltr({
            name: fn,
            size: sc,
            originalSize: su,
            compression: c_2
        })) {
            if (!c_2) files[fn] = slc(data, b, b + sc);
            else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), {
                out: new u8(su)
            });
            else err(14, 'unknown compression type ' + c_2);
        }
    }
    return files;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jnFvT":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"6knHn":[function(require,module,exports,__globalThis) {
module.exports = import("./html2canvas.4d90174c.js").then(()=>module.bundle.root('jgq02'));

},{"jgq02":"jgq02"}],"qpTWL":[function(require,module,exports,__globalThis) {
module.exports = import("./purify.f659f139.js").then(()=>module.bundle.root('1IHUz'));

},{"1IHUz":"1IHUz"}],"97tTU":[function(require,module,exports,__globalThis) {
module.exports = import("./index.es.34fb467d.js").then(()=>module.bundle.root('63Yt8'));

},{"63Yt8":"63Yt8"}],"aVBNV":[function(require,module,exports,__globalThis) {
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */ /******/ // The require scope
/******/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbortException", ()=>__webpack_exports__AbortException);
parcelHelpers.export(exports, "AnnotationEditorLayer", ()=>__webpack_exports__AnnotationEditorLayer);
parcelHelpers.export(exports, "AnnotationEditorParamsType", ()=>__webpack_exports__AnnotationEditorParamsType);
parcelHelpers.export(exports, "AnnotationEditorType", ()=>__webpack_exports__AnnotationEditorType);
parcelHelpers.export(exports, "AnnotationEditorUIManager", ()=>__webpack_exports__AnnotationEditorUIManager);
parcelHelpers.export(exports, "AnnotationLayer", ()=>__webpack_exports__AnnotationLayer);
parcelHelpers.export(exports, "AnnotationMode", ()=>__webpack_exports__AnnotationMode);
parcelHelpers.export(exports, "ColorPicker", ()=>__webpack_exports__ColorPicker);
parcelHelpers.export(exports, "DOMSVGFactory", ()=>__webpack_exports__DOMSVGFactory);
parcelHelpers.export(exports, "DrawLayer", ()=>__webpack_exports__DrawLayer);
parcelHelpers.export(exports, "FeatureTest", ()=>__webpack_exports__FeatureTest);
parcelHelpers.export(exports, "GlobalWorkerOptions", ()=>__webpack_exports__GlobalWorkerOptions);
parcelHelpers.export(exports, "ImageKind", ()=>__webpack_exports__ImageKind);
parcelHelpers.export(exports, "InvalidPDFException", ()=>__webpack_exports__InvalidPDFException);
parcelHelpers.export(exports, "MissingPDFException", ()=>__webpack_exports__MissingPDFException);
parcelHelpers.export(exports, "OPS", ()=>__webpack_exports__OPS);
parcelHelpers.export(exports, "OutputScale", ()=>__webpack_exports__OutputScale);
parcelHelpers.export(exports, "PDFDataRangeTransport", ()=>__webpack_exports__PDFDataRangeTransport);
parcelHelpers.export(exports, "PDFDateString", ()=>__webpack_exports__PDFDateString);
parcelHelpers.export(exports, "PDFWorker", ()=>__webpack_exports__PDFWorker);
parcelHelpers.export(exports, "PasswordResponses", ()=>__webpack_exports__PasswordResponses);
parcelHelpers.export(exports, "PermissionFlag", ()=>__webpack_exports__PermissionFlag);
parcelHelpers.export(exports, "PixelsPerInch", ()=>__webpack_exports__PixelsPerInch);
parcelHelpers.export(exports, "RenderingCancelledException", ()=>__webpack_exports__RenderingCancelledException);
parcelHelpers.export(exports, "TextLayer", ()=>__webpack_exports__TextLayer);
parcelHelpers.export(exports, "TouchManager", ()=>__webpack_exports__TouchManager);
parcelHelpers.export(exports, "UnexpectedResponseException", ()=>__webpack_exports__UnexpectedResponseException);
parcelHelpers.export(exports, "Util", ()=>__webpack_exports__Util);
parcelHelpers.export(exports, "VerbosityLevel", ()=>__webpack_exports__VerbosityLevel);
parcelHelpers.export(exports, "XfaLayer", ()=>__webpack_exports__XfaLayer);
parcelHelpers.export(exports, "build", ()=>__webpack_exports__build);
parcelHelpers.export(exports, "createValidAbsoluteUrl", ()=>__webpack_exports__createValidAbsoluteUrl);
parcelHelpers.export(exports, "fetchData", ()=>__webpack_exports__fetchData);
parcelHelpers.export(exports, "getDocument", ()=>__webpack_exports__getDocument);
parcelHelpers.export(exports, "getFilenameFromUrl", ()=>__webpack_exports__getFilenameFromUrl);
parcelHelpers.export(exports, "getPdfFilenameFromUrl", ()=>__webpack_exports__getPdfFilenameFromUrl);
parcelHelpers.export(exports, "getXfaPageViewport", ()=>__webpack_exports__getXfaPageViewport);
parcelHelpers.export(exports, "isDataScheme", ()=>__webpack_exports__isDataScheme);
parcelHelpers.export(exports, "isPdfFile", ()=>__webpack_exports__isPdfFile);
parcelHelpers.export(exports, "noContextMenu", ()=>__webpack_exports__noContextMenu);
parcelHelpers.export(exports, "normalizeUnicode", ()=>__webpack_exports__normalizeUnicode);
parcelHelpers.export(exports, "setLayerDimensions", ()=>__webpack_exports__setLayerDimensions);
parcelHelpers.export(exports, "shadow", ()=>__webpack_exports__shadow);
parcelHelpers.export(exports, "stopEvent", ()=>__webpack_exports__stopEvent);
parcelHelpers.export(exports, "version", ()=>__webpack_exports__version);
var process = require("dac986d78ccfd4c4");
var Buffer = require("2c902924488e9bb7").Buffer;
var __webpack_require__ = {};
/******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition)=>{
        /******/ for(var key in definition)/******/ if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
        });
    /******/ };
/******/ })();
/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
    /******/ __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
/******/ })();
/******/ /************************************************************************/ var __webpack_exports__ = globalThis.pdfjsLib = {};
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
    AbortException: ()=>/* reexport */ AbortException,
    AnnotationEditorLayer: ()=>/* reexport */ AnnotationEditorLayer,
    AnnotationEditorParamsType: ()=>/* reexport */ AnnotationEditorParamsType,
    AnnotationEditorType: ()=>/* reexport */ AnnotationEditorType,
    AnnotationEditorUIManager: ()=>/* reexport */ AnnotationEditorUIManager,
    AnnotationLayer: ()=>/* reexport */ AnnotationLayer,
    AnnotationMode: ()=>/* reexport */ AnnotationMode,
    ColorPicker: ()=>/* reexport */ ColorPicker,
    DOMSVGFactory: ()=>/* reexport */ DOMSVGFactory,
    DrawLayer: ()=>/* reexport */ DrawLayer,
    FeatureTest: ()=>/* reexport */ util_FeatureTest,
    GlobalWorkerOptions: ()=>/* reexport */ GlobalWorkerOptions,
    ImageKind: ()=>/* reexport */ util_ImageKind,
    InvalidPDFException: ()=>/* reexport */ InvalidPDFException,
    MissingPDFException: ()=>/* reexport */ MissingPDFException,
    OPS: ()=>/* reexport */ OPS,
    OutputScale: ()=>/* reexport */ OutputScale,
    PDFDataRangeTransport: ()=>/* reexport */ PDFDataRangeTransport,
    PDFDateString: ()=>/* reexport */ PDFDateString,
    PDFWorker: ()=>/* reexport */ PDFWorker,
    PasswordResponses: ()=>/* reexport */ PasswordResponses,
    PermissionFlag: ()=>/* reexport */ PermissionFlag,
    PixelsPerInch: ()=>/* reexport */ PixelsPerInch,
    RenderingCancelledException: ()=>/* reexport */ RenderingCancelledException,
    TextLayer: ()=>/* reexport */ TextLayer,
    TouchManager: ()=>/* reexport */ TouchManager,
    UnexpectedResponseException: ()=>/* reexport */ UnexpectedResponseException,
    Util: ()=>/* reexport */ Util,
    VerbosityLevel: ()=>/* reexport */ VerbosityLevel,
    XfaLayer: ()=>/* reexport */ XfaLayer,
    build: ()=>/* reexport */ build,
    createValidAbsoluteUrl: ()=>/* reexport */ createValidAbsoluteUrl,
    fetchData: ()=>/* reexport */ fetchData,
    getDocument: ()=>/* reexport */ getDocument,
    getFilenameFromUrl: ()=>/* reexport */ getFilenameFromUrl,
    getPdfFilenameFromUrl: ()=>/* reexport */ getPdfFilenameFromUrl,
    getXfaPageViewport: ()=>/* reexport */ getXfaPageViewport,
    isDataScheme: ()=>/* reexport */ isDataScheme,
    isPdfFile: ()=>/* reexport */ isPdfFile,
    noContextMenu: ()=>/* reexport */ noContextMenu,
    normalizeUnicode: ()=>/* reexport */ normalizeUnicode,
    setLayerDimensions: ()=>/* reexport */ setLayerDimensions,
    shadow: ()=>/* reexport */ shadow,
    stopEvent: ()=>/* reexport */ stopEvent,
    version: ()=>/* reexport */ version
});
const isNodeJS = false;
const IDENTITY_MATRIX = [
    1,
    0,
    0,
    1,
    0,
    0
];
const FONT_IDENTITY_MATRIX = [
    0.001,
    0,
    0,
    0.001,
    0,
    0
];
const MAX_IMAGE_SIZE_TO_CACHE = 10e6;
const LINE_FACTOR = 1.35;
const LINE_DESCENT_FACTOR = 0.35;
const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
const RenderingIntentFlag = {
    ANY: 0x01,
    DISPLAY: 0x02,
    PRINT: 0x04,
    SAVE: 0x08,
    ANNOTATIONS_FORMS: 0x10,
    ANNOTATIONS_STORAGE: 0x20,
    ANNOTATIONS_DISABLE: 0x40,
    IS_EDITING: 0x80,
    OPLIST: 0x100
};
const AnnotationMode = {
    DISABLE: 0,
    ENABLE: 1,
    ENABLE_FORMS: 2,
    ENABLE_STORAGE: 3
};
const AnnotationEditorPrefix = "pdfjs_internal_editor_";
const AnnotationEditorType = {
    DISABLE: -1,
    NONE: 0,
    FREETEXT: 3,
    HIGHLIGHT: 9,
    STAMP: 13,
    INK: 15
};
const AnnotationEditorParamsType = {
    RESIZE: 1,
    CREATE: 2,
    FREETEXT_SIZE: 11,
    FREETEXT_COLOR: 12,
    FREETEXT_OPACITY: 13,
    INK_COLOR: 21,
    INK_THICKNESS: 22,
    INK_OPACITY: 23,
    HIGHLIGHT_COLOR: 31,
    HIGHLIGHT_DEFAULT_COLOR: 32,
    HIGHLIGHT_THICKNESS: 33,
    HIGHLIGHT_FREE: 34,
    HIGHLIGHT_SHOW_ALL: 35,
    DRAW_STEP: 41
};
const PermissionFlag = {
    PRINT: 0x04,
    MODIFY_CONTENTS: 0x08,
    COPY: 0x10,
    MODIFY_ANNOTATIONS: 0x20,
    FILL_INTERACTIVE_FORMS: 0x100,
    COPY_FOR_ACCESSIBILITY: 0x200,
    ASSEMBLE: 0x400,
    PRINT_HIGH_QUALITY: 0x800
};
const TextRenderingMode = {
    FILL: 0,
    STROKE: 1,
    FILL_STROKE: 2,
    INVISIBLE: 3,
    FILL_ADD_TO_PATH: 4,
    STROKE_ADD_TO_PATH: 5,
    FILL_STROKE_ADD_TO_PATH: 6,
    ADD_TO_PATH: 7,
    FILL_STROKE_MASK: 3,
    ADD_TO_PATH_FLAG: 4
};
const util_ImageKind = {
    GRAYSCALE_1BPP: 1,
    RGB_24BPP: 2,
    RGBA_32BPP: 3
};
const AnnotationType = {
    TEXT: 1,
    LINK: 2,
    FREETEXT: 3,
    LINE: 4,
    SQUARE: 5,
    CIRCLE: 6,
    POLYGON: 7,
    POLYLINE: 8,
    HIGHLIGHT: 9,
    UNDERLINE: 10,
    SQUIGGLY: 11,
    STRIKEOUT: 12,
    STAMP: 13,
    CARET: 14,
    INK: 15,
    POPUP: 16,
    FILEATTACHMENT: 17,
    SOUND: 18,
    MOVIE: 19,
    WIDGET: 20,
    SCREEN: 21,
    PRINTERMARK: 22,
    TRAPNET: 23,
    WATERMARK: 24,
    THREED: 25,
    REDACT: 26
};
const AnnotationReplyType = {
    GROUP: "Group",
    REPLY: "R"
};
const AnnotationFlag = {
    INVISIBLE: 0x01,
    HIDDEN: 0x02,
    PRINT: 0x04,
    NOZOOM: 0x08,
    NOROTATE: 0x10,
    NOVIEW: 0x20,
    READONLY: 0x40,
    LOCKED: 0x80,
    TOGGLENOVIEW: 0x100,
    LOCKEDCONTENTS: 0x200
};
const AnnotationFieldFlag = {
    READONLY: 0x0000001,
    REQUIRED: 0x0000002,
    NOEXPORT: 0x0000004,
    MULTILINE: 0x0001000,
    PASSWORD: 0x0002000,
    NOTOGGLETOOFF: 0x0004000,
    RADIO: 0x0008000,
    PUSHBUTTON: 0x0010000,
    COMBO: 0x0020000,
    EDIT: 0x0040000,
    SORT: 0x0080000,
    FILESELECT: 0x0100000,
    MULTISELECT: 0x0200000,
    DONOTSPELLCHECK: 0x0400000,
    DONOTSCROLL: 0x0800000,
    COMB: 0x1000000,
    RICHTEXT: 0x2000000,
    RADIOSINUNISON: 0x2000000,
    COMMITONSELCHANGE: 0x4000000
};
const AnnotationBorderStyleType = {
    SOLID: 1,
    DASHED: 2,
    BEVELED: 3,
    INSET: 4,
    UNDERLINE: 5
};
const AnnotationActionEventType = {
    E: "Mouse Enter",
    X: "Mouse Exit",
    D: "Mouse Down",
    U: "Mouse Up",
    Fo: "Focus",
    Bl: "Blur",
    PO: "PageOpen",
    PC: "PageClose",
    PV: "PageVisible",
    PI: "PageInvisible",
    K: "Keystroke",
    F: "Format",
    V: "Validate",
    C: "Calculate"
};
const DocumentActionEventType = {
    WC: "WillClose",
    WS: "WillSave",
    DS: "DidSave",
    WP: "WillPrint",
    DP: "DidPrint"
};
const PageActionEventType = {
    O: "PageOpen",
    C: "PageClose"
};
const VerbosityLevel = {
    ERRORS: 0,
    WARNINGS: 1,
    INFOS: 5
};
const OPS = {
    dependency: 1,
    setLineWidth: 2,
    setLineCap: 3,
    setLineJoin: 4,
    setMiterLimit: 5,
    setDash: 6,
    setRenderingIntent: 7,
    setFlatness: 8,
    setGState: 9,
    save: 10,
    restore: 11,
    transform: 12,
    moveTo: 13,
    lineTo: 14,
    curveTo: 15,
    curveTo2: 16,
    curveTo3: 17,
    closePath: 18,
    rectangle: 19,
    stroke: 20,
    closeStroke: 21,
    fill: 22,
    eoFill: 23,
    fillStroke: 24,
    eoFillStroke: 25,
    closeFillStroke: 26,
    closeEOFillStroke: 27,
    endPath: 28,
    clip: 29,
    eoClip: 30,
    beginText: 31,
    endText: 32,
    setCharSpacing: 33,
    setWordSpacing: 34,
    setHScale: 35,
    setLeading: 36,
    setFont: 37,
    setTextRenderingMode: 38,
    setTextRise: 39,
    moveText: 40,
    setLeadingMoveText: 41,
    setTextMatrix: 42,
    nextLine: 43,
    showText: 44,
    showSpacedText: 45,
    nextLineShowText: 46,
    nextLineSetSpacingShowText: 47,
    setCharWidth: 48,
    setCharWidthAndBounds: 49,
    setStrokeColorSpace: 50,
    setFillColorSpace: 51,
    setStrokeColor: 52,
    setStrokeColorN: 53,
    setFillColor: 54,
    setFillColorN: 55,
    setStrokeGray: 56,
    setFillGray: 57,
    setStrokeRGBColor: 58,
    setFillRGBColor: 59,
    setStrokeCMYKColor: 60,
    setFillCMYKColor: 61,
    shadingFill: 62,
    beginInlineImage: 63,
    beginImageData: 64,
    endInlineImage: 65,
    paintXObject: 66,
    markPoint: 67,
    markPointProps: 68,
    beginMarkedContent: 69,
    beginMarkedContentProps: 70,
    endMarkedContent: 71,
    beginCompat: 72,
    endCompat: 73,
    paintFormXObjectBegin: 74,
    paintFormXObjectEnd: 75,
    beginGroup: 76,
    endGroup: 77,
    beginAnnotation: 80,
    endAnnotation: 81,
    paintImageMaskXObject: 83,
    paintImageMaskXObjectGroup: 84,
    paintImageXObject: 85,
    paintInlineImageXObject: 86,
    paintInlineImageXObjectGroup: 87,
    paintImageXObjectRepeat: 88,
    paintImageMaskXObjectRepeat: 89,
    paintSolidColorImageMask: 90,
    constructPath: 91,
    setStrokeTransparent: 92,
    setFillTransparent: 93
};
const PasswordResponses = {
    NEED_PASSWORD: 1,
    INCORRECT_PASSWORD: 2
};
let verbosity = VerbosityLevel.WARNINGS;
function setVerbosityLevel(level) {
    if (Number.isInteger(level)) verbosity = level;
}
function getVerbosityLevel() {
    return verbosity;
}
function info(msg) {
    if (verbosity >= VerbosityLevel.INFOS) console.log(`Info: ${msg}`);
}
function warn(msg) {
    if (verbosity >= VerbosityLevel.WARNINGS) console.log(`Warning: ${msg}`);
}
function unreachable(msg) {
    throw new Error(msg);
}
function assert(cond, msg) {
    if (!cond) unreachable(msg);
}
function _isValidProtocol(url) {
    switch(url?.protocol){
        case "http:":
        case "https:":
        case "ftp:":
        case "mailto:":
        case "tel:":
            return true;
        default:
            return false;
    }
}
function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
    if (!url) return null;
    try {
        if (options && typeof url === "string") {
            if (options.addDefaultProtocol && url.startsWith("www.")) {
                const dots = url.match(/\./g);
                if (dots?.length >= 2) url = `http://${url}`;
            }
            if (options.tryConvertEncoding) try {
                url = stringToUTF8String(url);
            } catch  {}
        }
        const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
        if (_isValidProtocol(absoluteUrl)) return absoluteUrl;
    } catch  {}
    return null;
}
function shadow(obj, prop, value, nonSerializable = false) {
    Object.defineProperty(obj, prop, {
        value,
        enumerable: !nonSerializable,
        configurable: true,
        writable: false
    });
    return value;
}
const BaseException = function BaseExceptionClosure() {
    function BaseException(message, name) {
        this.message = message;
        this.name = name;
    }
    BaseException.prototype = new Error();
    BaseException.constructor = BaseException;
    return BaseException;
}();
class PasswordException extends BaseException {
    constructor(msg, code){
        super(msg, "PasswordException");
        this.code = code;
    }
}
class UnknownErrorException extends BaseException {
    constructor(msg, details){
        super(msg, "UnknownErrorException");
        this.details = details;
    }
}
class InvalidPDFException extends BaseException {
    constructor(msg){
        super(msg, "InvalidPDFException");
    }
}
class MissingPDFException extends BaseException {
    constructor(msg){
        super(msg, "MissingPDFException");
    }
}
class UnexpectedResponseException extends BaseException {
    constructor(msg, status){
        super(msg, "UnexpectedResponseException");
        this.status = status;
    }
}
class FormatError extends BaseException {
    constructor(msg){
        super(msg, "FormatError");
    }
}
class AbortException extends BaseException {
    constructor(msg){
        super(msg, "AbortException");
    }
}
function bytesToString(bytes) {
    if (typeof bytes !== "object" || bytes?.length === undefined) unreachable("Invalid argument for bytesToString");
    const length = bytes.length;
    const MAX_ARGUMENT_COUNT = 8192;
    if (length < MAX_ARGUMENT_COUNT) return String.fromCharCode.apply(null, bytes);
    const strBuf = [];
    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){
        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
        const chunk = bytes.subarray(i, chunkEnd);
        strBuf.push(String.fromCharCode.apply(null, chunk));
    }
    return strBuf.join("");
}
function stringToBytes(str) {
    if (typeof str !== "string") unreachable("Invalid argument for stringToBytes");
    const length = str.length;
    const bytes = new Uint8Array(length);
    for(let i = 0; i < length; ++i)bytes[i] = str.charCodeAt(i) & 0xff;
    return bytes;
}
function string32(value) {
    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}
function objectSize(obj) {
    return Object.keys(obj).length;
}
function objectFromMap(map) {
    const obj = Object.create(null);
    for (const [key, value] of map)obj[key] = value;
    return obj;
}
function isLittleEndian() {
    const buffer8 = new Uint8Array(4);
    buffer8[0] = 1;
    const view32 = new Uint32Array(buffer8.buffer, 0, 1);
    return view32[0] === 1;
}
function isEvalSupported() {
    try {
        new Function("");
        return true;
    } catch  {
        return false;
    }
}
class util_FeatureTest {
    static get isLittleEndian() {
        return shadow(this, "isLittleEndian", isLittleEndian());
    }
    static get isEvalSupported() {
        return shadow(this, "isEvalSupported", isEvalSupported());
    }
    static get isOffscreenCanvasSupported() {
        return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
    }
    static get isImageDecoderSupported() {
        return shadow(this, "isImageDecoderSupported", typeof ImageDecoder !== "undefined");
    }
    static get platform() {
        if (typeof navigator !== "undefined" && typeof navigator?.platform === "string") return shadow(this, "platform", {
            isMac: navigator.platform.includes("Mac"),
            isWindows: navigator.platform.includes("Win"),
            isFirefox: typeof navigator?.userAgent === "string" && navigator.userAgent.includes("Firefox")
        });
        return shadow(this, "platform", {
            isMac: false,
            isWindows: false,
            isFirefox: false
        });
    }
    static get isCSSRoundSupported() {
        return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
    }
}
const hexNumbers = Array.from(Array(256).keys(), (n)=>n.toString(16).padStart(2, "0"));
class Util {
    static makeHexColor(r, g, b) {
        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
    }
    static scaleMinMax(transform, minMax) {
        let temp;
        if (transform[0]) {
            if (transform[0] < 0) {
                temp = minMax[0];
                minMax[0] = minMax[2];
                minMax[2] = temp;
            }
            minMax[0] *= transform[0];
            minMax[2] *= transform[0];
            if (transform[3] < 0) {
                temp = minMax[1];
                minMax[1] = minMax[3];
                minMax[3] = temp;
            }
            minMax[1] *= transform[3];
            minMax[3] *= transform[3];
        } else {
            temp = minMax[0];
            minMax[0] = minMax[1];
            minMax[1] = temp;
            temp = minMax[2];
            minMax[2] = minMax[3];
            minMax[3] = temp;
            if (transform[1] < 0) {
                temp = minMax[1];
                minMax[1] = minMax[3];
                minMax[3] = temp;
            }
            minMax[1] *= transform[1];
            minMax[3] *= transform[1];
            if (transform[2] < 0) {
                temp = minMax[0];
                minMax[0] = minMax[2];
                minMax[2] = temp;
            }
            minMax[0] *= transform[2];
            minMax[2] *= transform[2];
        }
        minMax[0] += transform[4];
        minMax[1] += transform[5];
        minMax[2] += transform[4];
        minMax[3] += transform[5];
    }
    static transform(m1, m2) {
        return [
            m1[0] * m2[0] + m1[2] * m2[1],
            m1[1] * m2[0] + m1[3] * m2[1],
            m1[0] * m2[2] + m1[2] * m2[3],
            m1[1] * m2[2] + m1[3] * m2[3],
            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
        ];
    }
    static applyTransform(p, m) {
        const xt = p[0] * m[0] + p[1] * m[2] + m[4];
        const yt = p[0] * m[1] + p[1] * m[3] + m[5];
        return [
            xt,
            yt
        ];
    }
    static applyInverseTransform(p, m) {
        const d = m[0] * m[3] - m[1] * m[2];
        const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
        const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
        return [
            xt,
            yt
        ];
    }
    static getAxialAlignedBoundingBox(r, m) {
        const p1 = this.applyTransform(r, m);
        const p2 = this.applyTransform(r.slice(2, 4), m);
        const p3 = this.applyTransform([
            r[0],
            r[3]
        ], m);
        const p4 = this.applyTransform([
            r[2],
            r[1]
        ], m);
        return [
            Math.min(p1[0], p2[0], p3[0], p4[0]),
            Math.min(p1[1], p2[1], p3[1], p4[1]),
            Math.max(p1[0], p2[0], p3[0], p4[0]),
            Math.max(p1[1], p2[1], p3[1], p4[1])
        ];
    }
    static inverseTransform(m) {
        const d = m[0] * m[3] - m[1] * m[2];
        return [
            m[3] / d,
            -m[1] / d,
            -m[2] / d,
            m[0] / d,
            (m[2] * m[5] - m[4] * m[3]) / d,
            (m[4] * m[1] - m[5] * m[0]) / d
        ];
    }
    static singularValueDecompose2dScale(m) {
        const transpose = [
            m[0],
            m[2],
            m[1],
            m[3]
        ];
        const a = m[0] * transpose[0] + m[1] * transpose[2];
        const b = m[0] * transpose[1] + m[1] * transpose[3];
        const c = m[2] * transpose[0] + m[3] * transpose[2];
        const d = m[2] * transpose[1] + m[3] * transpose[3];
        const first = (a + d) / 2;
        const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
        const sx = first + second || 1;
        const sy = first - second || 1;
        return [
            Math.sqrt(sx),
            Math.sqrt(sy)
        ];
    }
    static normalizeRect(rect) {
        const r = rect.slice(0);
        if (rect[0] > rect[2]) {
            r[0] = rect[2];
            r[2] = rect[0];
        }
        if (rect[1] > rect[3]) {
            r[1] = rect[3];
            r[3] = rect[1];
        }
        return r;
    }
    static intersect(rect1, rect2) {
        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
        if (xLow > xHigh) return null;
        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
        if (yLow > yHigh) return null;
        return [
            xLow,
            yLow,
            xHigh,
            yHigh
        ];
    }
    static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {
        if (t <= 0 || t >= 1) return;
        const mt = 1 - t;
        const tt = t * t;
        const ttt = tt * t;
        const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;
        const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;
        minMax[0] = Math.min(minMax[0], x);
        minMax[1] = Math.min(minMax[1], y);
        minMax[2] = Math.max(minMax[2], x);
        minMax[3] = Math.max(minMax[3], y);
    }
    static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {
        if (Math.abs(a) < 1e-12) {
            if (Math.abs(b) >= 1e-12) this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);
            return;
        }
        const delta = b ** 2 - 4 * c * a;
        if (delta < 0) return;
        const sqrtDelta = Math.sqrt(delta);
        const a2 = 2 * a;
        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);
        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);
    }
    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
        if (minMax) {
            minMax[0] = Math.min(minMax[0], x0, x3);
            minMax[1] = Math.min(minMax[1], y0, y3);
            minMax[2] = Math.max(minMax[2], x0, x3);
            minMax[3] = Math.max(minMax[3], y0, y3);
        } else minMax = [
            Math.min(x0, x3),
            Math.min(y0, y3),
            Math.max(x0, x3),
            Math.max(y0, y3)
        ];
        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);
        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);
        return minMax;
    }
}
const PDFStringTranslateTable = /* unused pure expression or super */ null;
function stringToPDFString(str) {
    if (str[0] >= "\xEF") {
        let encoding;
        if (str[0] === "\xFE" && str[1] === "\xFF") {
            encoding = "utf-16be";
            if (str.length % 2 === 1) str = str.slice(0, -1);
        } else if (str[0] === "\xFF" && str[1] === "\xFE") {
            encoding = "utf-16le";
            if (str.length % 2 === 1) str = str.slice(0, -1);
        } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") encoding = "utf-8";
        if (encoding) try {
            const decoder = new TextDecoder(encoding, {
                fatal: true
            });
            const buffer = stringToBytes(str);
            const decoded = decoder.decode(buffer);
            if (!decoded.includes("\x1b")) return decoded;
            return decoded.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "");
        } catch (ex) {
            warn(`stringToPDFString: "${ex}".`);
        }
    }
    const strBuf = [];
    for(let i = 0, ii = str.length; i < ii; i++){
        const charCode = str.charCodeAt(i);
        if (charCode === 0x1b) {
            while(++i < ii && str.charCodeAt(i) !== 0x1b);
            continue;
        }
        const code = PDFStringTranslateTable[charCode];
        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
    return strBuf.join("");
}
function stringToUTF8String(str) {
    return decodeURIComponent(escape(str));
}
function utf8StringToString(str) {
    return unescape(encodeURIComponent(str));
}
function isArrayEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) return false;
    for(let i = 0, ii = arr1.length; i < ii; i++){
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}
function getModificationDate(date = new Date()) {
    const buffer = [
        date.getUTCFullYear().toString(),
        (date.getUTCMonth() + 1).toString().padStart(2, "0"),
        date.getUTCDate().toString().padStart(2, "0"),
        date.getUTCHours().toString().padStart(2, "0"),
        date.getUTCMinutes().toString().padStart(2, "0"),
        date.getUTCSeconds().toString().padStart(2, "0")
    ];
    return buffer.join("");
}
let NormalizeRegex = null;
let NormalizationMap = null;
function normalizeUnicode(str) {
    if (!NormalizeRegex) {
        NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
        NormalizationMap = new Map([
            [
                "\uFB05",
                "\u017Ft"
            ]
        ]);
    }
    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2));
}
function getUuid() {
    if (typeof crypto.randomUUID === "function") return crypto.randomUUID();
    const buf = new Uint8Array(32);
    crypto.getRandomValues(buf);
    return bytesToString(buf);
}
const AnnotationPrefix = "pdfjs_internal_id_";
function toHexUtil(arr) {
    if (Uint8Array.prototype.toHex) return arr.toHex();
    return Array.from(arr, (num)=>hexNumbers[num]).join("");
}
function toBase64Util(arr) {
    if (Uint8Array.prototype.toBase64) return arr.toBase64();
    return btoa(bytesToString(arr));
}
function fromBase64Util(str) {
    if (Uint8Array.fromBase64) return Uint8Array.fromBase64(str);
    return stringToBytes(atob(str));
}
if (typeof Promise.try !== "function") Promise.try = function(fn, ...args) {
    return new Promise((resolve)=>{
        resolve(fn(...args));
    });
};
const SVG_NS = "http://www.w3.org/2000/svg";
class PixelsPerInch {
    static CSS = 96.0;
    static PDF = 72.0;
    static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
}
async function fetchData(url, type = "text") {
    if (isValidFetchUrl(url, document.baseURI)) {
        const response = await fetch(url);
        if (!response.ok) throw new Error(response.statusText);
        switch(type){
            case "arraybuffer":
                return response.arrayBuffer();
            case "blob":
                return response.blob();
            case "json":
                return response.json();
        }
        return response.text();
    }
    return new Promise((resolve, reject)=>{
        const request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.responseType = type;
        request.onreadystatechange = ()=>{
            if (request.readyState !== XMLHttpRequest.DONE) return;
            if (request.status === 200 || request.status === 0) {
                switch(type){
                    case "arraybuffer":
                    case "blob":
                    case "json":
                        resolve(request.response);
                        return;
                }
                resolve(request.responseText);
                return;
            }
            reject(new Error(request.statusText));
        };
        request.send(null);
    });
}
class PageViewport {
    constructor({ viewBox, userUnit, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){
        this.viewBox = viewBox;
        this.userUnit = userUnit;
        this.scale = scale;
        this.rotation = rotation;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        scale *= userUnit;
        const centerX = (viewBox[2] + viewBox[0]) / 2;
        const centerY = (viewBox[3] + viewBox[1]) / 2;
        let rotateA, rotateB, rotateC, rotateD;
        rotation %= 360;
        if (rotation < 0) rotation += 360;
        switch(rotation){
            case 180:
                rotateA = -1;
                rotateB = 0;
                rotateC = 0;
                rotateD = 1;
                break;
            case 90:
                rotateA = 0;
                rotateB = 1;
                rotateC = 1;
                rotateD = 0;
                break;
            case 270:
                rotateA = 0;
                rotateB = -1;
                rotateC = -1;
                rotateD = 0;
                break;
            case 0:
                rotateA = 1;
                rotateB = 0;
                rotateC = 0;
                rotateD = -1;
                break;
            default:
                throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
        }
        if (dontFlip) {
            rotateC = -rotateC;
            rotateD = -rotateD;
        }
        let offsetCanvasX, offsetCanvasY;
        let width, height;
        if (rotateA === 0) {
            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
            width = (viewBox[3] - viewBox[1]) * scale;
            height = (viewBox[2] - viewBox[0]) * scale;
        } else {
            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
            width = (viewBox[2] - viewBox[0]) * scale;
            height = (viewBox[3] - viewBox[1]) * scale;
        }
        this.transform = [
            rotateA * scale,
            rotateB * scale,
            rotateC * scale,
            rotateD * scale,
            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,
            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY
        ];
        this.width = width;
        this.height = height;
    }
    get rawDims() {
        const { userUnit, viewBox } = this;
        const dims = viewBox.map((x)=>x * userUnit);
        return shadow(this, "rawDims", {
            pageWidth: dims[2] - dims[0],
            pageHeight: dims[3] - dims[1],
            pageX: dims[0],
            pageY: dims[1]
        });
    }
    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {
        return new PageViewport({
            viewBox: this.viewBox.slice(),
            userUnit: this.userUnit,
            scale,
            rotation,
            offsetX,
            offsetY,
            dontFlip
        });
    }
    convertToViewportPoint(x, y) {
        return Util.applyTransform([
            x,
            y
        ], this.transform);
    }
    convertToViewportRectangle(rect) {
        const topLeft = Util.applyTransform([
            rect[0],
            rect[1]
        ], this.transform);
        const bottomRight = Util.applyTransform([
            rect[2],
            rect[3]
        ], this.transform);
        return [
            topLeft[0],
            topLeft[1],
            bottomRight[0],
            bottomRight[1]
        ];
    }
    convertToPdfPoint(x, y) {
        return Util.applyInverseTransform([
            x,
            y
        ], this.transform);
    }
}
class RenderingCancelledException extends BaseException {
    constructor(msg, extraDelay = 0){
        super(msg, "RenderingCancelledException");
        this.extraDelay = extraDelay;
    }
}
function isDataScheme(url) {
    const ii = url.length;
    let i = 0;
    while(i < ii && url[i].trim() === "")i++;
    return url.substring(i, i + 5).toLowerCase() === "data:";
}
function isPdfFile(filename) {
    return typeof filename === "string" && /\.pdf$/i.test(filename);
}
function getFilenameFromUrl(url) {
    [url] = url.split(/[#?]/, 1);
    return url.substring(url.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
    if (typeof url !== "string") return defaultFilename;
    if (isDataScheme(url)) {
        warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
        return defaultFilename;
    }
    const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
    const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
    const splitURI = reURI.exec(url);
    let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
    if (suggestedFilename) {
        suggestedFilename = suggestedFilename[0];
        if (suggestedFilename.includes("%")) try {
            suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
        } catch  {}
    }
    return suggestedFilename || defaultFilename;
}
class StatTimer {
    started = Object.create(null);
    times = [];
    time(name) {
        if (name in this.started) warn(`Timer is already running for ${name}`);
        this.started[name] = Date.now();
    }
    timeEnd(name) {
        if (!(name in this.started)) warn(`Timer has not been started for ${name}`);
        this.times.push({
            name,
            start: this.started[name],
            end: Date.now()
        });
        delete this.started[name];
    }
    toString() {
        const outBuf = [];
        let longest = 0;
        for (const { name } of this.times)longest = Math.max(name.length, longest);
        for (const { name, start, end } of this.times)outBuf.push(`${name.padEnd(longest)} ${end - start}ms\n`);
        return outBuf.join("");
    }
}
function isValidFetchUrl(url, baseUrl) {
    try {
        const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url);
        return protocol === "http:" || protocol === "https:";
    } catch  {
        return false;
    }
}
function noContextMenu(e) {
    e.preventDefault();
}
function stopEvent(e) {
    e.preventDefault();
    e.stopPropagation();
}
function deprecated(details) {
    console.log("Deprecated API usage: " + details);
}
class PDFDateString {
    static #regex;
    static toDateObject(input) {
        if (!input || typeof input !== "string") return null;
        this.#regex ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
        const matches = this.#regex.exec(input);
        if (!matches) return null;
        const year = parseInt(matches[1], 10);
        let month = parseInt(matches[2], 10);
        month = month >= 1 && month <= 12 ? month - 1 : 0;
        let day = parseInt(matches[3], 10);
        day = day >= 1 && day <= 31 ? day : 1;
        let hour = parseInt(matches[4], 10);
        hour = hour >= 0 && hour <= 23 ? hour : 0;
        let minute = parseInt(matches[5], 10);
        minute = minute >= 0 && minute <= 59 ? minute : 0;
        let second = parseInt(matches[6], 10);
        second = second >= 0 && second <= 59 ? second : 0;
        const universalTimeRelation = matches[7] || "Z";
        let offsetHour = parseInt(matches[8], 10);
        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
        let offsetMinute = parseInt(matches[9], 10) || 0;
        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
        if (universalTimeRelation === "-") {
            hour += offsetHour;
            minute += offsetMinute;
        } else if (universalTimeRelation === "+") {
            hour -= offsetHour;
            minute -= offsetMinute;
        }
        return new Date(Date.UTC(year, month, day, hour, minute, second));
    }
}
function getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {
    const { width, height } = xfaPage.attributes.style;
    const viewBox = [
        0,
        0,
        parseInt(width),
        parseInt(height)
    ];
    return new PageViewport({
        viewBox,
        userUnit: 1,
        scale,
        rotation
    });
}
function getRGB(color) {
    if (color.startsWith("#")) {
        const colorRGB = parseInt(color.slice(1), 16);
        return [
            (colorRGB & 0xff0000) >> 16,
            (colorRGB & 0x00ff00) >> 8,
            colorRGB & 0x0000ff
        ];
    }
    if (color.startsWith("rgb(")) return color.slice(4, -1).split(",").map((x)=>parseInt(x));
    if (color.startsWith("rgba(")) return color.slice(5, -1).split(",").map((x)=>parseInt(x)).slice(0, 3);
    warn(`Not a valid color format: "${color}"`);
    return [
        0,
        0,
        0
    ];
}
function getColorValues(colors) {
    const span = document.createElement("span");
    span.style.visibility = "hidden";
    document.body.append(span);
    for (const name of colors.keys()){
        span.style.color = name;
        const computedColor = window.getComputedStyle(span).color;
        colors.set(name, getRGB(computedColor));
    }
    span.remove();
}
function getCurrentTransform(ctx) {
    const { a, b, c, d, e, f } = ctx.getTransform();
    return [
        a,
        b,
        c,
        d,
        e,
        f
    ];
}
function getCurrentTransformInverse(ctx) {
    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();
    return [
        a,
        b,
        c,
        d,
        e,
        f
    ];
}
function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
    if (viewport instanceof PageViewport) {
        const { pageWidth, pageHeight } = viewport.rawDims;
        const { style } = div;
        const useRound = util_FeatureTest.isCSSRoundSupported;
        const w = `var(--scale-factor) * ${pageWidth}px`, h = `var(--scale-factor) * ${pageHeight}px`;
        const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x, 1px))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y, 1px))` : `calc(${h})`;
        if (!mustFlip || viewport.rotation % 180 === 0) {
            style.width = widthStr;
            style.height = heightStr;
        } else {
            style.width = heightStr;
            style.height = widthStr;
        }
    }
    if (mustRotate) div.setAttribute("data-main-rotation", viewport.rotation);
}
class OutputScale {
    constructor(){
        const pixelRatio = window.devicePixelRatio || 1;
        this.sx = pixelRatio;
        this.sy = pixelRatio;
    }
    get scaled() {
        return this.sx !== 1 || this.sy !== 1;
    }
    get symmetric() {
        return this.sx === this.sy;
    }
}
class EditorToolbar {
    #toolbar = null;
    #colorPicker = null;
    #editor;
    #buttons = null;
    #altText = null;
    static #l10nRemove = null;
    constructor(editor){
        this.#editor = editor;
        EditorToolbar.#l10nRemove ||= Object.freeze({
            freetext: "pdfjs-editor-remove-freetext-button",
            highlight: "pdfjs-editor-remove-highlight-button",
            ink: "pdfjs-editor-remove-ink-button",
            stamp: "pdfjs-editor-remove-stamp-button"
        });
    }
    render() {
        const editToolbar = this.#toolbar = document.createElement("div");
        editToolbar.classList.add("editToolbar", "hidden");
        editToolbar.setAttribute("role", "toolbar");
        const signal = this.#editor._uiManager._signal;
        editToolbar.addEventListener("contextmenu", noContextMenu, {
            signal
        });
        editToolbar.addEventListener("pointerdown", EditorToolbar.#pointerDown, {
            signal
        });
        const buttons = this.#buttons = document.createElement("div");
        buttons.className = "buttons";
        editToolbar.append(buttons);
        const position = this.#editor.toolbarPosition;
        if (position) {
            const { style } = editToolbar;
            const x = this.#editor._uiManager.direction === "ltr" ? 1 - position[0] : position[0];
            style.insetInlineEnd = `${100 * x}%`;
            style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;
        }
        this.#addDeleteButton();
        return editToolbar;
    }
    get div() {
        return this.#toolbar;
    }
    static #pointerDown(e) {
        e.stopPropagation();
    }
    #focusIn(e) {
        this.#editor._focusEventsAllowed = false;
        stopEvent(e);
    }
    #focusOut(e) {
        this.#editor._focusEventsAllowed = true;
        stopEvent(e);
    }
    #addListenersToElement(element) {
        const signal = this.#editor._uiManager._signal;
        element.addEventListener("focusin", this.#focusIn.bind(this), {
            capture: true,
            signal
        });
        element.addEventListener("focusout", this.#focusOut.bind(this), {
            capture: true,
            signal
        });
        element.addEventListener("contextmenu", noContextMenu, {
            signal
        });
    }
    hide() {
        this.#toolbar.classList.add("hidden");
        this.#colorPicker?.hideDropdown();
    }
    show() {
        this.#toolbar.classList.remove("hidden");
        this.#altText?.shown();
    }
    #addDeleteButton() {
        const { editorType, _uiManager } = this.#editor;
        const button = document.createElement("button");
        button.className = "delete";
        button.tabIndex = 0;
        button.setAttribute("data-l10n-id", EditorToolbar.#l10nRemove[editorType]);
        this.#addListenersToElement(button);
        button.addEventListener("click", (e)=>{
            _uiManager.delete();
        }, {
            signal: _uiManager._signal
        });
        this.#buttons.append(button);
    }
    get #divider() {
        const divider = document.createElement("div");
        divider.className = "divider";
        return divider;
    }
    async addAltText(altText) {
        const button = await altText.render();
        this.#addListenersToElement(button);
        this.#buttons.prepend(button, this.#divider);
        this.#altText = altText;
    }
    addColorPicker(colorPicker) {
        this.#colorPicker = colorPicker;
        const button = colorPicker.renderButton();
        this.#addListenersToElement(button);
        this.#buttons.prepend(button, this.#divider);
    }
    remove() {
        this.#toolbar.remove();
        this.#colorPicker?.destroy();
        this.#colorPicker = null;
    }
}
class HighlightToolbar {
    #buttons = null;
    #toolbar = null;
    #uiManager;
    constructor(uiManager){
        this.#uiManager = uiManager;
    }
    #render() {
        const editToolbar = this.#toolbar = document.createElement("div");
        editToolbar.className = "editToolbar";
        editToolbar.setAttribute("role", "toolbar");
        editToolbar.addEventListener("contextmenu", noContextMenu, {
            signal: this.#uiManager._signal
        });
        const buttons = this.#buttons = document.createElement("div");
        buttons.className = "buttons";
        editToolbar.append(buttons);
        this.#addHighlightButton();
        return editToolbar;
    }
    #getLastPoint(boxes, isLTR) {
        let lastY = 0;
        let lastX = 0;
        for (const box of boxes){
            const y = box.y + box.height;
            if (y < lastY) continue;
            const x = box.x + (isLTR ? box.width : 0);
            if (y > lastY) {
                lastX = x;
                lastY = y;
                continue;
            }
            if (isLTR) {
                if (x > lastX) lastX = x;
            } else if (x < lastX) lastX = x;
        }
        return [
            isLTR ? 1 - lastX : lastX,
            lastY
        ];
    }
    show(parent, boxes, isLTR) {
        const [x, y] = this.#getLastPoint(boxes, isLTR);
        const { style } = this.#toolbar ||= this.#render();
        parent.append(this.#toolbar);
        style.insetInlineEnd = `${100 * x}%`;
        style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;
    }
    hide() {
        this.#toolbar.remove();
    }
    #addHighlightButton() {
        const button = document.createElement("button");
        button.className = "highlightButton";
        button.tabIndex = 0;
        button.setAttribute("data-l10n-id", `pdfjs-highlight-floating-button1`);
        const span = document.createElement("span");
        button.append(span);
        span.className = "visuallyHidden";
        span.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
        const signal = this.#uiManager._signal;
        button.addEventListener("contextmenu", noContextMenu, {
            signal
        });
        button.addEventListener("click", ()=>{
            this.#uiManager.highlightSelection("floating_button");
        }, {
            signal
        });
        this.#buttons.append(button);
    }
}
function bindEvents(obj, element, names) {
    for (const name of names)element.addEventListener(name, obj[name].bind(obj));
}
function opacityToHex(opacity) {
    return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
}
class IdManager {
    #id = 0;
    get id() {
        return `${AnnotationEditorPrefix}${this.#id++}`;
    }
}
class ImageManager {
    #baseId = getUuid();
    #id = 0;
    #cache = null;
    static get _isSVGFittingCanvas() {
        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
        const canvas = new OffscreenCanvas(1, 3);
        const ctx = canvas.getContext("2d", {
            willReadFrequently: true
        });
        const image = new Image();
        image.src = svg;
        const promise = image.decode().then(()=>{
            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
        });
        return shadow(this, "_isSVGFittingCanvas", promise);
    }
    async #get(key, rawData) {
        this.#cache ||= new Map();
        let data = this.#cache.get(key);
        if (data === null) return null;
        if (data?.bitmap) {
            data.refCounter += 1;
            return data;
        }
        try {
            data ||= {
                bitmap: null,
                id: `image_${this.#baseId}_${this.#id++}`,
                refCounter: 0,
                isSvg: false
            };
            let image;
            if (typeof rawData === "string") {
                data.url = rawData;
                image = await fetchData(rawData, "blob");
            } else if (rawData instanceof File) image = data.file = rawData;
            else if (rawData instanceof Blob) image = rawData;
            if (image.type === "image/svg+xml") {
                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;
                const fileReader = new FileReader();
                const imageElement = new Image();
                const imagePromise = new Promise((resolve, reject)=>{
                    imageElement.onload = ()=>{
                        data.bitmap = imageElement;
                        data.isSvg = true;
                        resolve();
                    };
                    fileReader.onload = async ()=>{
                        const url = data.svgUrl = fileReader.result;
                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;
                    };
                    imageElement.onerror = fileReader.onerror = reject;
                });
                fileReader.readAsDataURL(image);
                await imagePromise;
            } else data.bitmap = await createImageBitmap(image);
            data.refCounter = 1;
        } catch (e) {
            warn(e);
            data = null;
        }
        this.#cache.set(key, data);
        if (data) this.#cache.set(data.id, data);
        return data;
    }
    async getFromFile(file) {
        const { lastModified, name, size, type } = file;
        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
    }
    async getFromUrl(url) {
        return this.#get(url, url);
    }
    async getFromBlob(id, blobPromise) {
        const blob = await blobPromise;
        return this.#get(id, blob);
    }
    async getFromId(id) {
        this.#cache ||= new Map();
        const data = this.#cache.get(id);
        if (!data) return null;
        if (data.bitmap) {
            data.refCounter += 1;
            return data;
        }
        if (data.file) return this.getFromFile(data.file);
        if (data.blobPromise) {
            const { blobPromise } = data;
            delete data.blobPromise;
            return this.getFromBlob(data.id, blobPromise);
        }
        return this.getFromUrl(data.url);
    }
    getFromCanvas(id, canvas) {
        this.#cache ||= new Map();
        let data = this.#cache.get(id);
        if (data?.bitmap) {
            data.refCounter += 1;
            return data;
        }
        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
        const ctx = offscreen.getContext("2d");
        ctx.drawImage(canvas, 0, 0);
        data = {
            bitmap: offscreen.transferToImageBitmap(),
            id: `image_${this.#baseId}_${this.#id++}`,
            refCounter: 1,
            isSvg: false
        };
        this.#cache.set(id, data);
        this.#cache.set(data.id, data);
        return data;
    }
    getSvgUrl(id) {
        const data = this.#cache.get(id);
        if (!data?.isSvg) return null;
        return data.svgUrl;
    }
    deleteId(id) {
        this.#cache ||= new Map();
        const data = this.#cache.get(id);
        if (!data) return;
        data.refCounter -= 1;
        if (data.refCounter !== 0) return;
        const { bitmap } = data;
        if (!data.url && !data.file) {
            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
            const ctx = canvas.getContext("bitmaprenderer");
            ctx.transferFromImageBitmap(bitmap);
            data.blobPromise = canvas.convertToBlob();
        }
        bitmap.close?.();
        data.bitmap = null;
    }
    isValidId(id) {
        return id.startsWith(`image_${this.#baseId}_`);
    }
}
class CommandManager {
    #commands = [];
    #locked = false;
    #maxSize;
    #position = -1;
    constructor(maxSize = 128){
        this.#maxSize = maxSize;
    }
    add({ cmd, undo, post, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {
        if (mustExec) cmd();
        if (this.#locked) return;
        const save = {
            cmd,
            undo,
            post,
            type
        };
        if (this.#position === -1) {
            if (this.#commands.length > 0) this.#commands.length = 0;
            this.#position = 0;
            this.#commands.push(save);
            return;
        }
        if (overwriteIfSameType && this.#commands[this.#position].type === type) {
            if (keepUndo) save.undo = this.#commands[this.#position].undo;
            this.#commands[this.#position] = save;
            return;
        }
        const next = this.#position + 1;
        if (next === this.#maxSize) this.#commands.splice(0, 1);
        else {
            this.#position = next;
            if (next < this.#commands.length) this.#commands.splice(next);
        }
        this.#commands.push(save);
    }
    undo() {
        if (this.#position === -1) return;
        this.#locked = true;
        const { undo, post } = this.#commands[this.#position];
        undo();
        post?.();
        this.#locked = false;
        this.#position -= 1;
    }
    redo() {
        if (this.#position < this.#commands.length - 1) {
            this.#position += 1;
            this.#locked = true;
            const { cmd, post } = this.#commands[this.#position];
            cmd();
            post?.();
            this.#locked = false;
        }
    }
    hasSomethingToUndo() {
        return this.#position !== -1;
    }
    hasSomethingToRedo() {
        return this.#position < this.#commands.length - 1;
    }
    cleanType(type) {
        if (this.#position === -1) return;
        for(let i = this.#position; i >= 0; i--)if (this.#commands[i].type !== type) {
            this.#commands.splice(i + 1, this.#position - i);
            this.#position = i;
            return;
        }
        this.#commands.length = 0;
        this.#position = -1;
    }
    destroy() {
        this.#commands = null;
    }
}
class KeyboardManager {
    constructor(callbacks){
        this.buffer = [];
        this.callbacks = new Map();
        this.allKeys = new Set();
        const { isMac } = util_FeatureTest.platform;
        for (const [keys, callback, options = {}] of callbacks)for (const key of keys){
            const isMacKey = key.startsWith("mac+");
            if (isMac && isMacKey) {
                this.callbacks.set(key.slice(4), {
                    callback,
                    options
                });
                this.allKeys.add(key.split("+").at(-1));
            } else if (!isMac && !isMacKey) {
                this.callbacks.set(key, {
                    callback,
                    options
                });
                this.allKeys.add(key.split("+").at(-1));
            }
        }
    }
    #serialize(event) {
        if (event.altKey) this.buffer.push("alt");
        if (event.ctrlKey) this.buffer.push("ctrl");
        if (event.metaKey) this.buffer.push("meta");
        if (event.shiftKey) this.buffer.push("shift");
        this.buffer.push(event.key);
        const str = this.buffer.join("+");
        this.buffer.length = 0;
        return str;
    }
    exec(self, event) {
        if (!this.allKeys.has(event.key)) return;
        const info = this.callbacks.get(this.#serialize(event));
        if (!info) return;
        const { callback, options: { bubbles = false, args = [], checker = null } } = info;
        if (checker && !checker(self, event)) return;
        callback.bind(self, ...args, event)();
        if (!bubbles) stopEvent(event);
    }
}
class ColorManager {
    static _colorsMapping = new Map([
        [
            "CanvasText",
            [
                0,
                0,
                0
            ]
        ],
        [
            "Canvas",
            [
                255,
                255,
                255
            ]
        ]
    ]);
    get _colors() {
        const colors = new Map([
            [
                "CanvasText",
                null
            ],
            [
                "Canvas",
                null
            ]
        ]);
        getColorValues(colors);
        return shadow(this, "_colors", colors);
    }
    convert(color) {
        const rgb = getRGB(color);
        if (!window.matchMedia("(forced-colors: active)").matches) return rgb;
        for (const [name, RGB] of this._colors){
            if (RGB.every((x, i)=>x === rgb[i])) return ColorManager._colorsMapping.get(name);
        }
        return rgb;
    }
    getHexCode(name) {
        const rgb = this._colors.get(name);
        if (!rgb) return name;
        return Util.makeHexColor(...rgb);
    }
}
class AnnotationEditorUIManager {
    #abortController = new AbortController();
    #activeEditor = null;
    #allEditors = new Map();
    #allLayers = new Map();
    #altTextManager = null;
    #annotationStorage = null;
    #changedExistingAnnotations = null;
    #commandManager = new CommandManager();
    #copyPasteAC = null;
    #currentDrawingSession = null;
    #currentPageIndex = 0;
    #deletedAnnotationsElementIds = new Set();
    #draggingEditors = null;
    #editorTypes = null;
    #editorsToRescale = new Set();
    _editorUndoBar = null;
    #enableHighlightFloatingButton = false;
    #enableUpdatedAddImage = false;
    #enableNewAltTextWhenAddingImage = false;
    #filterFactory = null;
    #focusMainContainerTimeoutId = null;
    #focusManagerAC = null;
    #highlightColors = null;
    #highlightWhenShiftUp = false;
    #highlightToolbar = null;
    #idManager = new IdManager();
    #isEnabled = false;
    #isWaiting = false;
    #keyboardManagerAC = null;
    #lastActiveElement = null;
    #mainHighlightColorPicker = null;
    #mlManager = null;
    #mode = AnnotationEditorType.NONE;
    #selectedEditors = new Set();
    #selectedTextNode = null;
    #pageColors = null;
    #showAllStates = null;
    #previousStates = {
        isEditing: false,
        isEmpty: true,
        hasSomethingToUndo: false,
        hasSomethingToRedo: false,
        hasSelectedEditor: false,
        hasSelectedText: false
    };
    #translation = [
        0,
        0
    ];
    #translationTimeoutId = null;
    #container = null;
    #viewer = null;
    #updateModeCapability = null;
    static TRANSLATE_SMALL = 1;
    static TRANSLATE_BIG = 10;
    static get _keyboardManager() {
        const proto = AnnotationEditorUIManager.prototype;
        const arrowChecker = (self)=>self.#container.contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && self.hasSomethingToControl();
        const textInputChecker = (_self, { target: el })=>{
            if (el instanceof HTMLInputElement) {
                const { type } = el;
                return type !== "text" && type !== "number";
            }
            return true;
        };
        const small = this.TRANSLATE_SMALL;
        const big = this.TRANSLATE_BIG;
        return shadow(this, "_keyboardManager", new KeyboardManager([
            [
                [
                    "ctrl+a",
                    "mac+meta+a"
                ],
                proto.selectAll,
                {
                    checker: textInputChecker
                }
            ],
            [
                [
                    "ctrl+z",
                    "mac+meta+z"
                ],
                proto.undo,
                {
                    checker: textInputChecker
                }
            ],
            [
                [
                    "ctrl+y",
                    "ctrl+shift+z",
                    "mac+meta+shift+z",
                    "ctrl+shift+Z",
                    "mac+meta+shift+Z"
                ],
                proto.redo,
                {
                    checker: textInputChecker
                }
            ],
            [
                [
                    "Backspace",
                    "alt+Backspace",
                    "ctrl+Backspace",
                    "shift+Backspace",
                    "mac+Backspace",
                    "mac+alt+Backspace",
                    "mac+ctrl+Backspace",
                    "Delete",
                    "ctrl+Delete",
                    "shift+Delete",
                    "mac+Delete"
                ],
                proto.delete,
                {
                    checker: textInputChecker
                }
            ],
            [
                [
                    "Enter",
                    "mac+Enter"
                ],
                proto.addNewEditorFromKeyboard,
                {
                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled
                }
            ],
            [
                [
                    " ",
                    "mac+ "
                ],
                proto.addNewEditorFromKeyboard,
                {
                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)
                }
            ],
            [
                [
                    "Escape",
                    "mac+Escape"
                ],
                proto.unselectAll
            ],
            [
                [
                    "ArrowLeft",
                    "mac+ArrowLeft"
                ],
                proto.translateSelectedEditors,
                {
                    args: [
                        -small,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowLeft",
                    "mac+shift+ArrowLeft"
                ],
                proto.translateSelectedEditors,
                {
                    args: [
                        -big,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowRight",
                    "mac+ArrowRight"
                ],
                proto.translateSelectedEditors,
                {
                    args: [
                        small,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowRight",
                    "mac+shift+ArrowRight"
                ],
                proto.translateSelectedEditors,
                {
                    args: [
                        big,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowUp",
                    "mac+ArrowUp"
                ],
                proto.translateSelectedEditors,
                {
                    args: [
                        0,
                        -small
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowUp",
                    "mac+shift+ArrowUp"
                ],
                proto.translateSelectedEditors,
                {
                    args: [
                        0,
                        -big
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowDown",
                    "mac+ArrowDown"
                ],
                proto.translateSelectedEditors,
                {
                    args: [
                        0,
                        small
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowDown",
                    "mac+shift+ArrowDown"
                ],
                proto.translateSelectedEditors,
                {
                    args: [
                        0,
                        big
                    ],
                    checker: arrowChecker
                }
            ]
        ]));
    }
    constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom){
        const signal = this._signal = this.#abortController.signal;
        this.#container = container;
        this.#viewer = viewer;
        this.#altTextManager = altTextManager;
        this._eventBus = eventBus;
        eventBus._on("editingaction", this.onEditingAction.bind(this), {
            signal
        });
        eventBus._on("pagechanging", this.onPageChanging.bind(this), {
            signal
        });
        eventBus._on("scalechanging", this.onScaleChanging.bind(this), {
            signal
        });
        eventBus._on("rotationchanging", this.onRotationChanging.bind(this), {
            signal
        });
        eventBus._on("setpreference", this.onSetPreference.bind(this), {
            signal
        });
        eventBus._on("switchannotationeditorparams", (evt)=>this.updateParams(evt.type, evt.value), {
            signal
        });
        this.#addSelectionListener();
        this.#addDragAndDropListeners();
        this.#addKeyboardManager();
        this.#annotationStorage = pdfDocument.annotationStorage;
        this.#filterFactory = pdfDocument.filterFactory;
        this.#pageColors = pageColors;
        this.#highlightColors = highlightColors || null;
        this.#enableHighlightFloatingButton = enableHighlightFloatingButton;
        this.#enableUpdatedAddImage = enableUpdatedAddImage;
        this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;
        this.#mlManager = mlManager || null;
        this.viewParameters = {
            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
            rotation: 0
        };
        this.isShiftKeyDown = false;
        this._editorUndoBar = editorUndoBar || null;
        this._supportsPinchToZoom = supportsPinchToZoom !== false;
    }
    destroy() {
        this.#updateModeCapability?.resolve();
        this.#updateModeCapability = null;
        this.#abortController?.abort();
        this.#abortController = null;
        this._signal = null;
        for (const layer of this.#allLayers.values())layer.destroy();
        this.#allLayers.clear();
        this.#allEditors.clear();
        this.#editorsToRescale.clear();
        this.#activeEditor = null;
        this.#selectedEditors.clear();
        this.#commandManager.destroy();
        this.#altTextManager?.destroy();
        this.#highlightToolbar?.hide();
        this.#highlightToolbar = null;
        if (this.#focusMainContainerTimeoutId) {
            clearTimeout(this.#focusMainContainerTimeoutId);
            this.#focusMainContainerTimeoutId = null;
        }
        if (this.#translationTimeoutId) {
            clearTimeout(this.#translationTimeoutId);
            this.#translationTimeoutId = null;
        }
        this._editorUndoBar?.destroy();
    }
    combinedSignal(ac) {
        return AbortSignal.any([
            this._signal,
            ac.signal
        ]);
    }
    get mlManager() {
        return this.#mlManager;
    }
    get useNewAltTextFlow() {
        return this.#enableUpdatedAddImage;
    }
    get useNewAltTextWhenAddingImage() {
        return this.#enableNewAltTextWhenAddingImage;
    }
    get hcmFilter() {
        return shadow(this, "hcmFilter", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : "none");
    }
    get direction() {
        return shadow(this, "direction", getComputedStyle(this.#container).direction);
    }
    get highlightColors() {
        return shadow(this, "highlightColors", this.#highlightColors ? new Map(this.#highlightColors.split(",").map((pair)=>pair.split("=").map((x)=>x.trim()))) : null);
    }
    get highlightColorNames() {
        return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e)=>e.reverse())) : null);
    }
    setCurrentDrawingSession(layer) {
        if (layer) {
            this.unselectAll();
            this.disableUserSelect(true);
        } else this.disableUserSelect(false);
        this.#currentDrawingSession = layer;
    }
    setMainHighlightColorPicker(colorPicker) {
        this.#mainHighlightColorPicker = colorPicker;
    }
    editAltText(editor, firstTime = false) {
        this.#altTextManager?.editAltText(this, editor, firstTime);
    }
    switchToMode(mode, callback) {
        this._eventBus.on("annotationeditormodechanged", callback, {
            once: true,
            signal: this._signal
        });
        this._eventBus.dispatch("showannotationeditorui", {
            source: this,
            mode
        });
    }
    setPreference(name, value) {
        this._eventBus.dispatch("setpreference", {
            source: this,
            name,
            value
        });
    }
    onSetPreference({ name, value }) {
        switch(name){
            case "enableNewAltTextWhenAddingImage":
                this.#enableNewAltTextWhenAddingImage = value;
                break;
        }
    }
    onPageChanging({ pageNumber }) {
        this.#currentPageIndex = pageNumber - 1;
    }
    focusMainContainer() {
        this.#container.focus();
    }
    findParent(x, y) {
        for (const layer of this.#allLayers.values()){
            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();
            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) return layer;
        }
        return null;
    }
    disableUserSelect(value = false) {
        this.#viewer.classList.toggle("noUserSelect", value);
    }
    addShouldRescale(editor) {
        this.#editorsToRescale.add(editor);
    }
    removeShouldRescale(editor) {
        this.#editorsToRescale.delete(editor);
    }
    onScaleChanging({ scale }) {
        this.commitOrRemove();
        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
        for (const editor of this.#editorsToRescale)editor.onScaleChanging();
        this.#currentDrawingSession?.onScaleChanging();
    }
    onRotationChanging({ pagesRotation }) {
        this.commitOrRemove();
        this.viewParameters.rotation = pagesRotation;
    }
    #getAnchorElementForSelection({ anchorNode }) {
        return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;
    }
    #getLayerForTextLayer(textLayer) {
        const { currentLayer } = this;
        if (currentLayer.hasTextLayer(textLayer)) return currentLayer;
        for (const layer of this.#allLayers.values()){
            if (layer.hasTextLayer(textLayer)) return layer;
        }
        return null;
    }
    highlightSelection(methodOfCreation = "") {
        const selection = document.getSelection();
        if (!selection || selection.isCollapsed) return;
        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;
        const text = selection.toString();
        const anchorElement = this.#getAnchorElementForSelection(selection);
        const textLayer = anchorElement.closest(".textLayer");
        const boxes = this.getSelectionBoxes(textLayer);
        if (!boxes) return;
        selection.empty();
        const layer = this.#getLayerForTextLayer(textLayer);
        const isNoneMode = this.#mode === AnnotationEditorType.NONE;
        const callback = ()=>{
            layer?.createAndAddNewEditor({
                x: 0,
                y: 0
            }, false, {
                methodOfCreation,
                boxes,
                anchorNode,
                anchorOffset,
                focusNode,
                focusOffset,
                text
            });
            if (isNoneMode) this.showAllEditors("highlight", true, true);
        };
        if (isNoneMode) {
            this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);
            return;
        }
        callback();
    }
    #displayHighlightToolbar() {
        const selection = document.getSelection();
        if (!selection || selection.isCollapsed) return;
        const anchorElement = this.#getAnchorElementForSelection(selection);
        const textLayer = anchorElement.closest(".textLayer");
        const boxes = this.getSelectionBoxes(textLayer);
        if (!boxes) return;
        this.#highlightToolbar ||= new HighlightToolbar(this);
        this.#highlightToolbar.show(textLayer, boxes, this.direction === "ltr");
    }
    addToAnnotationStorage(editor) {
        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) this.#annotationStorage.setValue(editor.id, editor);
    }
    #selectionChange() {
        const selection = document.getSelection();
        if (!selection || selection.isCollapsed) {
            if (this.#selectedTextNode) {
                this.#highlightToolbar?.hide();
                this.#selectedTextNode = null;
                this.#dispatchUpdateStates({
                    hasSelectedText: false
                });
            }
            return;
        }
        const { anchorNode } = selection;
        if (anchorNode === this.#selectedTextNode) return;
        const anchorElement = this.#getAnchorElementForSelection(selection);
        const textLayer = anchorElement.closest(".textLayer");
        if (!textLayer) {
            if (this.#selectedTextNode) {
                this.#highlightToolbar?.hide();
                this.#selectedTextNode = null;
                this.#dispatchUpdateStates({
                    hasSelectedText: false
                });
            }
            return;
        }
        this.#highlightToolbar?.hide();
        this.#selectedTextNode = anchorNode;
        this.#dispatchUpdateStates({
            hasSelectedText: true
        });
        if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) return;
        if (this.#mode === AnnotationEditorType.HIGHLIGHT) this.showAllEditors("highlight", true, true);
        this.#highlightWhenShiftUp = this.isShiftKeyDown;
        if (!this.isShiftKeyDown) {
            const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;
            activeLayer?.toggleDrawing();
            const ac = new AbortController();
            const signal = this.combinedSignal(ac);
            const pointerup = (e)=>{
                if (e.type === "pointerup" && e.button !== 0) return;
                ac.abort();
                activeLayer?.toggleDrawing(true);
                if (e.type === "pointerup") this.#onSelectEnd("main_toolbar");
            };
            window.addEventListener("pointerup", pointerup, {
                signal
            });
            window.addEventListener("blur", pointerup, {
                signal
            });
        }
    }
    #onSelectEnd(methodOfCreation = "") {
        if (this.#mode === AnnotationEditorType.HIGHLIGHT) this.highlightSelection(methodOfCreation);
        else if (this.#enableHighlightFloatingButton) this.#displayHighlightToolbar();
    }
    #addSelectionListener() {
        document.addEventListener("selectionchange", this.#selectionChange.bind(this), {
            signal: this._signal
        });
    }
    #addFocusManager() {
        if (this.#focusManagerAC) return;
        this.#focusManagerAC = new AbortController();
        const signal = this.combinedSignal(this.#focusManagerAC);
        window.addEventListener("focus", this.focus.bind(this), {
            signal
        });
        window.addEventListener("blur", this.blur.bind(this), {
            signal
        });
    }
    #removeFocusManager() {
        this.#focusManagerAC?.abort();
        this.#focusManagerAC = null;
    }
    blur() {
        this.isShiftKeyDown = false;
        if (this.#highlightWhenShiftUp) {
            this.#highlightWhenShiftUp = false;
            this.#onSelectEnd("main_toolbar");
        }
        if (!this.hasSelection) return;
        const { activeElement } = document;
        for (const editor of this.#selectedEditors)if (editor.div.contains(activeElement)) {
            this.#lastActiveElement = [
                editor,
                activeElement
            ];
            editor._focusEventsAllowed = false;
            break;
        }
    }
    focus() {
        if (!this.#lastActiveElement) return;
        const [lastEditor, lastActiveElement] = this.#lastActiveElement;
        this.#lastActiveElement = null;
        lastActiveElement.addEventListener("focusin", ()=>{
            lastEditor._focusEventsAllowed = true;
        }, {
            once: true,
            signal: this._signal
        });
        lastActiveElement.focus();
    }
    #addKeyboardManager() {
        if (this.#keyboardManagerAC) return;
        this.#keyboardManagerAC = new AbortController();
        const signal = this.combinedSignal(this.#keyboardManagerAC);
        window.addEventListener("keydown", this.keydown.bind(this), {
            signal
        });
        window.addEventListener("keyup", this.keyup.bind(this), {
            signal
        });
    }
    #removeKeyboardManager() {
        this.#keyboardManagerAC?.abort();
        this.#keyboardManagerAC = null;
    }
    #addCopyPasteListeners() {
        if (this.#copyPasteAC) return;
        this.#copyPasteAC = new AbortController();
        const signal = this.combinedSignal(this.#copyPasteAC);
        document.addEventListener("copy", this.copy.bind(this), {
            signal
        });
        document.addEventListener("cut", this.cut.bind(this), {
            signal
        });
        document.addEventListener("paste", this.paste.bind(this), {
            signal
        });
    }
    #removeCopyPasteListeners() {
        this.#copyPasteAC?.abort();
        this.#copyPasteAC = null;
    }
    #addDragAndDropListeners() {
        const signal = this._signal;
        document.addEventListener("dragover", this.dragOver.bind(this), {
            signal
        });
        document.addEventListener("drop", this.drop.bind(this), {
            signal
        });
    }
    addEditListeners() {
        this.#addKeyboardManager();
        this.#addCopyPasteListeners();
    }
    removeEditListeners() {
        this.#removeKeyboardManager();
        this.#removeCopyPasteListeners();
    }
    dragOver(event) {
        for (const { type } of event.dataTransfer.items){
            for (const editorType of this.#editorTypes)if (editorType.isHandlingMimeForPasting(type)) {
                event.dataTransfer.dropEffect = "copy";
                event.preventDefault();
                return;
            }
        }
    }
    drop(event) {
        for (const item of event.dataTransfer.items){
            for (const editorType of this.#editorTypes)if (editorType.isHandlingMimeForPasting(item.type)) {
                editorType.paste(item, this.currentLayer);
                event.preventDefault();
                return;
            }
        }
    }
    copy(event) {
        event.preventDefault();
        this.#activeEditor?.commitOrRemove();
        if (!this.hasSelection) return;
        const editors = [];
        for (const editor of this.#selectedEditors){
            const serialized = editor.serialize(true);
            if (serialized) editors.push(serialized);
        }
        if (editors.length === 0) return;
        event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
    }
    cut(event) {
        this.copy(event);
        this.delete();
    }
    async paste(event) {
        event.preventDefault();
        const { clipboardData } = event;
        for (const item of clipboardData.items){
            for (const editorType of this.#editorTypes)if (editorType.isHandlingMimeForPasting(item.type)) {
                editorType.paste(item, this.currentLayer);
                return;
            }
        }
        let data = clipboardData.getData("application/pdfjs");
        if (!data) return;
        try {
            data = JSON.parse(data);
        } catch (ex) {
            warn(`paste: "${ex.message}".`);
            return;
        }
        if (!Array.isArray(data)) return;
        this.unselectAll();
        const layer = this.currentLayer;
        try {
            const newEditors = [];
            for (const editor of data){
                const deserializedEditor = await layer.deserialize(editor);
                if (!deserializedEditor) return;
                newEditors.push(deserializedEditor);
            }
            const cmd = ()=>{
                for (const editor of newEditors)this.#addEditorToLayer(editor);
                this.#selectEditors(newEditors);
            };
            const undo = ()=>{
                for (const editor of newEditors)editor.remove();
            };
            this.addCommands({
                cmd,
                undo,
                mustExec: true
            });
        } catch (ex) {
            warn(`paste: "${ex.message}".`);
        }
    }
    keydown(event) {
        if (!this.isShiftKeyDown && event.key === "Shift") this.isShiftKeyDown = true;
        if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) AnnotationEditorUIManager._keyboardManager.exec(this, event);
    }
    keyup(event) {
        if (this.isShiftKeyDown && event.key === "Shift") {
            this.isShiftKeyDown = false;
            if (this.#highlightWhenShiftUp) {
                this.#highlightWhenShiftUp = false;
                this.#onSelectEnd("main_toolbar");
            }
        }
    }
    onEditingAction({ name }) {
        switch(name){
            case "undo":
            case "redo":
            case "delete":
            case "selectAll":
                this[name]();
                break;
            case "highlightSelection":
                this.highlightSelection("context_menu");
                break;
        }
    }
    #dispatchUpdateStates(details) {
        const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);
        if (hasChanged) {
            this._eventBus.dispatch("annotationeditorstateschanged", {
                source: this,
                details: Object.assign(this.#previousStates, details)
            });
            if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) this.#dispatchUpdateUI([
                [
                    AnnotationEditorParamsType.HIGHLIGHT_FREE,
                    true
                ]
            ]);
        }
    }
    #dispatchUpdateUI(details) {
        this._eventBus.dispatch("annotationeditorparamschanged", {
            source: this,
            details
        });
    }
    setEditingState(isEditing) {
        if (isEditing) {
            this.#addFocusManager();
            this.#addCopyPasteListeners();
            this.#dispatchUpdateStates({
                isEditing: this.#mode !== AnnotationEditorType.NONE,
                isEmpty: this.#isEmpty(),
                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
                hasSelectedEditor: false
            });
        } else {
            this.#removeFocusManager();
            this.#removeCopyPasteListeners();
            this.#dispatchUpdateStates({
                isEditing: false
            });
            this.disableUserSelect(false);
        }
    }
    registerEditorTypes(types) {
        if (this.#editorTypes) return;
        this.#editorTypes = types;
        for (const editorType of this.#editorTypes)this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
    }
    getId() {
        return this.#idManager.id;
    }
    get currentLayer() {
        return this.#allLayers.get(this.#currentPageIndex);
    }
    getLayer(pageIndex) {
        return this.#allLayers.get(pageIndex);
    }
    get currentPageIndex() {
        return this.#currentPageIndex;
    }
    addLayer(layer) {
        this.#allLayers.set(layer.pageIndex, layer);
        if (this.#isEnabled) layer.enable();
        else layer.disable();
    }
    removeLayer(layer) {
        this.#allLayers.delete(layer.pageIndex);
    }
    async updateMode(mode, editId = null, isFromKeyboard = false) {
        if (this.#mode === mode) return;
        if (this.#updateModeCapability) {
            await this.#updateModeCapability.promise;
            if (!this.#updateModeCapability) return;
        }
        this.#updateModeCapability = Promise.withResolvers();
        this.#mode = mode;
        if (mode === AnnotationEditorType.NONE) {
            this.setEditingState(false);
            this.#disableAll();
            this._editorUndoBar?.hide();
            this.#updateModeCapability.resolve();
            return;
        }
        this.setEditingState(true);
        await this.#enableAll();
        this.unselectAll();
        for (const layer of this.#allLayers.values())layer.updateMode(mode);
        if (!editId) {
            if (isFromKeyboard) this.addNewEditorFromKeyboard();
            this.#updateModeCapability.resolve();
            return;
        }
        for (const editor of this.#allEditors.values())if (editor.annotationElementId === editId) {
            this.setSelected(editor);
            editor.enterInEditMode();
        } else editor.unselect();
        this.#updateModeCapability.resolve();
    }
    addNewEditorFromKeyboard() {
        if (this.currentLayer.canCreateNewEmptyEditor()) this.currentLayer.addNewEditor();
    }
    updateToolbar(mode) {
        if (mode === this.#mode) return;
        this._eventBus.dispatch("switchannotationeditormode", {
            source: this,
            mode
        });
    }
    updateParams(type, value) {
        if (!this.#editorTypes) return;
        switch(type){
            case AnnotationEditorParamsType.CREATE:
                this.currentLayer.addNewEditor();
                return;
            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
                this.#mainHighlightColorPicker?.updateColor(value);
                break;
            case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
                this._eventBus.dispatch("reporttelemetry", {
                    source: this,
                    details: {
                        type: "editing",
                        data: {
                            type: "highlight",
                            action: "toggle_visibility"
                        }
                    }
                });
                (this.#showAllStates ||= new Map()).set(type, value);
                this.showAllEditors("highlight", value);
                break;
        }
        for (const editor of this.#selectedEditors)editor.updateParams(type, value);
        for (const editorType of this.#editorTypes)editorType.updateDefaultParams(type, value);
    }
    showAllEditors(type, visible, updateButton = false) {
        for (const editor of this.#allEditors.values())if (editor.editorType === type) editor.show(visible);
        const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;
        if (state !== visible) this.#dispatchUpdateUI([
            [
                AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL,
                visible
            ]
        ]);
    }
    enableWaiting(mustWait = false) {
        if (this.#isWaiting === mustWait) return;
        this.#isWaiting = mustWait;
        for (const layer of this.#allLayers.values()){
            if (mustWait) layer.disableClick();
            else layer.enableClick();
            layer.div.classList.toggle("waiting", mustWait);
        }
    }
    async #enableAll() {
        if (!this.#isEnabled) {
            this.#isEnabled = true;
            const promises = [];
            for (const layer of this.#allLayers.values())promises.push(layer.enable());
            await Promise.all(promises);
            for (const editor of this.#allEditors.values())editor.enable();
        }
    }
    #disableAll() {
        this.unselectAll();
        if (this.#isEnabled) {
            this.#isEnabled = false;
            for (const layer of this.#allLayers.values())layer.disable();
            for (const editor of this.#allEditors.values())editor.disable();
        }
    }
    getEditors(pageIndex) {
        const editors = [];
        for (const editor of this.#allEditors.values())if (editor.pageIndex === pageIndex) editors.push(editor);
        return editors;
    }
    getEditor(id) {
        return this.#allEditors.get(id);
    }
    addEditor(editor) {
        this.#allEditors.set(editor.id, editor);
    }
    removeEditor(editor) {
        if (editor.div.contains(document.activeElement)) {
            if (this.#focusMainContainerTimeoutId) clearTimeout(this.#focusMainContainerTimeoutId);
            this.#focusMainContainerTimeoutId = setTimeout(()=>{
                this.focusMainContainer();
                this.#focusMainContainerTimeoutId = null;
            }, 0);
        }
        this.#allEditors.delete(editor.id);
        this.unselect(editor);
        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) this.#annotationStorage?.remove(editor.id);
    }
    addDeletedAnnotationElement(editor) {
        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
        this.addChangedExistingAnnotation(editor);
        editor.deleted = true;
    }
    isDeletedAnnotationElement(annotationElementId) {
        return this.#deletedAnnotationsElementIds.has(annotationElementId);
    }
    removeDeletedAnnotationElement(editor) {
        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
        this.removeChangedExistingAnnotation(editor);
        editor.deleted = false;
    }
    #addEditorToLayer(editor) {
        const layer = this.#allLayers.get(editor.pageIndex);
        if (layer) layer.addOrRebuild(editor);
        else {
            this.addEditor(editor);
            this.addToAnnotationStorage(editor);
        }
    }
    setActiveEditor(editor) {
        if (this.#activeEditor === editor) return;
        this.#activeEditor = editor;
        if (editor) this.#dispatchUpdateUI(editor.propertiesToUpdate);
    }
    get #lastSelectedEditor() {
        let ed = null;
        for (ed of this.#selectedEditors);
        return ed;
    }
    updateUI(editor) {
        if (this.#lastSelectedEditor === editor) this.#dispatchUpdateUI(editor.propertiesToUpdate);
    }
    updateUIForDefaultProperties(editorType) {
        this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
    }
    toggleSelected(editor) {
        if (this.#selectedEditors.has(editor)) {
            this.#selectedEditors.delete(editor);
            editor.unselect();
            this.#dispatchUpdateStates({
                hasSelectedEditor: this.hasSelection
            });
            return;
        }
        this.#selectedEditors.add(editor);
        editor.select();
        this.#dispatchUpdateUI(editor.propertiesToUpdate);
        this.#dispatchUpdateStates({
            hasSelectedEditor: true
        });
    }
    setSelected(editor) {
        this.#currentDrawingSession?.commitOrRemove();
        for (const ed of this.#selectedEditors)if (ed !== editor) ed.unselect();
        this.#selectedEditors.clear();
        this.#selectedEditors.add(editor);
        editor.select();
        this.#dispatchUpdateUI(editor.propertiesToUpdate);
        this.#dispatchUpdateStates({
            hasSelectedEditor: true
        });
    }
    isSelected(editor) {
        return this.#selectedEditors.has(editor);
    }
    get firstSelectedEditor() {
        return this.#selectedEditors.values().next().value;
    }
    unselect(editor) {
        editor.unselect();
        this.#selectedEditors.delete(editor);
        this.#dispatchUpdateStates({
            hasSelectedEditor: this.hasSelection
        });
    }
    get hasSelection() {
        return this.#selectedEditors.size !== 0;
    }
    get isEnterHandled() {
        return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;
    }
    undo() {
        this.#commandManager.undo();
        this.#dispatchUpdateStates({
            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
            hasSomethingToRedo: true,
            isEmpty: this.#isEmpty()
        });
        this._editorUndoBar?.hide();
    }
    redo() {
        this.#commandManager.redo();
        this.#dispatchUpdateStates({
            hasSomethingToUndo: true,
            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
            isEmpty: this.#isEmpty()
        });
    }
    addCommands(params) {
        this.#commandManager.add(params);
        this.#dispatchUpdateStates({
            hasSomethingToUndo: true,
            hasSomethingToRedo: false,
            isEmpty: this.#isEmpty()
        });
    }
    cleanUndoStack(type) {
        this.#commandManager.cleanType(type);
    }
    #isEmpty() {
        if (this.#allEditors.size === 0) return true;
        if (this.#allEditors.size === 1) {
            for (const editor of this.#allEditors.values())return editor.isEmpty();
        }
        return false;
    }
    delete() {
        this.commitOrRemove();
        const drawingEditor = this.currentLayer?.endDrawingSession(true);
        if (!this.hasSelection && !drawingEditor) return;
        const editors = drawingEditor ? [
            drawingEditor
        ] : [
            ...this.#selectedEditors
        ];
        const cmd = ()=>{
            this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);
            for (const editor of editors)editor.remove();
        };
        const undo = ()=>{
            for (const editor of editors)this.#addEditorToLayer(editor);
        };
        this.addCommands({
            cmd,
            undo,
            mustExec: true
        });
    }
    commitOrRemove() {
        this.#activeEditor?.commitOrRemove();
    }
    hasSomethingToControl() {
        return this.#activeEditor || this.hasSelection;
    }
    #selectEditors(editors) {
        for (const editor of this.#selectedEditors)editor.unselect();
        this.#selectedEditors.clear();
        for (const editor of editors){
            if (editor.isEmpty()) continue;
            this.#selectedEditors.add(editor);
            editor.select();
        }
        this.#dispatchUpdateStates({
            hasSelectedEditor: this.hasSelection
        });
    }
    selectAll() {
        for (const editor of this.#selectedEditors)editor.commit();
        this.#selectEditors(this.#allEditors.values());
    }
    unselectAll() {
        if (this.#activeEditor) {
            this.#activeEditor.commitOrRemove();
            if (this.#mode !== AnnotationEditorType.NONE) return;
        }
        if (this.#currentDrawingSession?.commitOrRemove()) return;
        if (!this.hasSelection) return;
        for (const editor of this.#selectedEditors)editor.unselect();
        this.#selectedEditors.clear();
        this.#dispatchUpdateStates({
            hasSelectedEditor: false
        });
    }
    translateSelectedEditors(x, y, noCommit = false) {
        if (!noCommit) this.commitOrRemove();
        if (!this.hasSelection) return;
        this.#translation[0] += x;
        this.#translation[1] += y;
        const [totalX, totalY] = this.#translation;
        const editors = [
            ...this.#selectedEditors
        ];
        const TIME_TO_WAIT = 1000;
        if (this.#translationTimeoutId) clearTimeout(this.#translationTimeoutId);
        this.#translationTimeoutId = setTimeout(()=>{
            this.#translationTimeoutId = null;
            this.#translation[0] = this.#translation[1] = 0;
            this.addCommands({
                cmd: ()=>{
                    for (const editor of editors)if (this.#allEditors.has(editor.id)) editor.translateInPage(totalX, totalY);
                },
                undo: ()=>{
                    for (const editor of editors)if (this.#allEditors.has(editor.id)) editor.translateInPage(-totalX, -totalY);
                },
                mustExec: false
            });
        }, TIME_TO_WAIT);
        for (const editor of editors)editor.translateInPage(x, y);
    }
    setUpDragSession() {
        if (!this.hasSelection) return;
        this.disableUserSelect(true);
        this.#draggingEditors = new Map();
        for (const editor of this.#selectedEditors)this.#draggingEditors.set(editor, {
            savedX: editor.x,
            savedY: editor.y,
            savedPageIndex: editor.pageIndex,
            newX: 0,
            newY: 0,
            newPageIndex: -1
        });
    }
    endDragSession() {
        if (!this.#draggingEditors) return false;
        this.disableUserSelect(false);
        const map = this.#draggingEditors;
        this.#draggingEditors = null;
        let mustBeAddedInUndoStack = false;
        for (const [{ x, y, pageIndex }, value] of map){
            value.newX = x;
            value.newY = y;
            value.newPageIndex = pageIndex;
            mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;
        }
        if (!mustBeAddedInUndoStack) return false;
        const move = (editor, x, y, pageIndex)=>{
            if (this.#allEditors.has(editor.id)) {
                const parent = this.#allLayers.get(pageIndex);
                if (parent) editor._setParentAndPosition(parent, x, y);
                else {
                    editor.pageIndex = pageIndex;
                    editor.x = x;
                    editor.y = y;
                }
            }
        };
        this.addCommands({
            cmd: ()=>{
                for (const [editor, { newX, newY, newPageIndex }] of map)move(editor, newX, newY, newPageIndex);
            },
            undo: ()=>{
                for (const [editor, { savedX, savedY, savedPageIndex }] of map)move(editor, savedX, savedY, savedPageIndex);
            },
            mustExec: true
        });
        return true;
    }
    dragSelectedEditors(tx, ty) {
        if (!this.#draggingEditors) return;
        for (const editor of this.#draggingEditors.keys())editor.drag(tx, ty);
    }
    rebuild(editor) {
        if (editor.parent === null) {
            const parent = this.getLayer(editor.pageIndex);
            if (parent) {
                parent.changeParent(editor);
                parent.addOrRebuild(editor);
            } else {
                this.addEditor(editor);
                this.addToAnnotationStorage(editor);
                editor.rebuild();
            }
        } else editor.parent.addOrRebuild(editor);
    }
    get isEditorHandlingKeyboard() {
        return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
    }
    isActive(editor) {
        return this.#activeEditor === editor;
    }
    getActive() {
        return this.#activeEditor;
    }
    getMode() {
        return this.#mode;
    }
    get imageManager() {
        return shadow(this, "imageManager", new ImageManager());
    }
    getSelectionBoxes(textLayer) {
        if (!textLayer) return null;
        const selection = document.getSelection();
        for(let i = 0, ii = selection.rangeCount; i < ii; i++){
            if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) return null;
        }
        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();
        let rotator;
        switch(textLayer.getAttribute("data-main-rotation")){
            case "90":
                rotator = (x, y, w, h)=>({
                        x: (y - layerY) / parentHeight,
                        y: 1 - (x + w - layerX) / parentWidth,
                        width: h / parentHeight,
                        height: w / parentWidth
                    });
                break;
            case "180":
                rotator = (x, y, w, h)=>({
                        x: 1 - (x + w - layerX) / parentWidth,
                        y: 1 - (y + h - layerY) / parentHeight,
                        width: w / parentWidth,
                        height: h / parentHeight
                    });
                break;
            case "270":
                rotator = (x, y, w, h)=>({
                        x: 1 - (y + h - layerY) / parentHeight,
                        y: (x - layerX) / parentWidth,
                        width: h / parentHeight,
                        height: w / parentWidth
                    });
                break;
            default:
                rotator = (x, y, w, h)=>({
                        x: (x - layerX) / parentWidth,
                        y: (y - layerY) / parentHeight,
                        width: w / parentWidth,
                        height: h / parentHeight
                    });
                break;
        }
        const boxes = [];
        for(let i = 0, ii = selection.rangeCount; i < ii; i++){
            const range = selection.getRangeAt(i);
            if (range.collapsed) continue;
            for (const { x, y, width, height } of range.getClientRects()){
                if (width === 0 || height === 0) continue;
                boxes.push(rotator(x, y, width, height));
            }
        }
        return boxes.length === 0 ? null : boxes;
    }
    addChangedExistingAnnotation({ annotationElementId, id }) {
        (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);
    }
    removeChangedExistingAnnotation({ annotationElementId }) {
        this.#changedExistingAnnotations?.delete(annotationElementId);
    }
    renderAnnotationElement(annotation) {
        const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);
        if (!editorId) return;
        const editor = this.#annotationStorage.getRawValue(editorId);
        if (!editor) return;
        if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) return;
        editor.renderAnnotationElement(annotation);
    }
}
class AltText {
    #altText = null;
    #altTextDecorative = false;
    #altTextButton = null;
    #altTextButtonLabel = null;
    #altTextTooltip = null;
    #altTextTooltipTimeout = null;
    #altTextWasFromKeyBoard = false;
    #badge = null;
    #editor = null;
    #guessedText = null;
    #textWithDisclaimer = null;
    #useNewAltTextFlow = false;
    static #l10nNewButton = null;
    static _l10n = null;
    constructor(editor){
        this.#editor = editor;
        this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;
        AltText.#l10nNewButton ||= Object.freeze({
            added: "pdfjs-editor-new-alt-text-added-button",
            "added-label": "pdfjs-editor-new-alt-text-added-button-label",
            missing: "pdfjs-editor-new-alt-text-missing-button",
            "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
            review: "pdfjs-editor-new-alt-text-to-review-button",
            "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
        });
    }
    static initialize(l10n) {
        AltText._l10n ??= l10n;
    }
    async render() {
        const altText = this.#altTextButton = document.createElement("button");
        altText.className = "altText";
        altText.tabIndex = "0";
        const label = this.#altTextButtonLabel = document.createElement("span");
        altText.append(label);
        if (this.#useNewAltTextFlow) {
            altText.classList.add("new");
            altText.setAttribute("data-l10n-id", AltText.#l10nNewButton.missing);
            label.setAttribute("data-l10n-id", AltText.#l10nNewButton["missing-label"]);
        } else {
            altText.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button");
            label.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label");
        }
        const signal = this.#editor._uiManager._signal;
        altText.addEventListener("contextmenu", noContextMenu, {
            signal
        });
        altText.addEventListener("pointerdown", (event)=>event.stopPropagation(), {
            signal
        });
        const onClick = (event)=>{
            event.preventDefault();
            this.#editor._uiManager.editAltText(this.#editor);
            if (this.#useNewAltTextFlow) this.#editor._reportTelemetry({
                action: "pdfjs.image.alt_text.image_status_label_clicked",
                data: {
                    label: this.#label
                }
            });
        };
        altText.addEventListener("click", onClick, {
            capture: true,
            signal
        });
        altText.addEventListener("keydown", (event)=>{
            if (event.target === altText && event.key === "Enter") {
                this.#altTextWasFromKeyBoard = true;
                onClick(event);
            }
        }, {
            signal
        });
        await this.#setState();
        return altText;
    }
    get #label() {
        return this.#altText && "added" || this.#altText === null && this.guessedText && "review" || "missing";
    }
    finish() {
        if (!this.#altTextButton) return;
        this.#altTextButton.focus({
            focusVisible: this.#altTextWasFromKeyBoard
        });
        this.#altTextWasFromKeyBoard = false;
    }
    isEmpty() {
        if (this.#useNewAltTextFlow) return this.#altText === null;
        return !this.#altText && !this.#altTextDecorative;
    }
    hasData() {
        if (this.#useNewAltTextFlow) return this.#altText !== null || !!this.#guessedText;
        return this.isEmpty();
    }
    get guessedText() {
        return this.#guessedText;
    }
    async setGuessedText(guessedText) {
        if (this.#altText !== null) return;
        this.#guessedText = guessedText;
        this.#textWithDisclaimer = await AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
            generatedAltText: guessedText
        });
        this.#setState();
    }
    toggleAltTextBadge(visibility = false) {
        if (!this.#useNewAltTextFlow || this.#altText) {
            this.#badge?.remove();
            this.#badge = null;
            return;
        }
        if (!this.#badge) {
            const badge = this.#badge = document.createElement("div");
            badge.className = "noAltTextBadge";
            this.#editor.div.append(badge);
        }
        this.#badge.classList.toggle("hidden", !visibility);
    }
    serialize(isForCopying) {
        let altText = this.#altText;
        if (!isForCopying && this.#guessedText === altText) altText = this.#textWithDisclaimer;
        return {
            altText,
            decorative: this.#altTextDecorative,
            guessedText: this.#guessedText,
            textWithDisclaimer: this.#textWithDisclaimer
        };
    }
    get data() {
        return {
            altText: this.#altText,
            decorative: this.#altTextDecorative
        };
    }
    set data({ altText, decorative, guessedText, textWithDisclaimer, cancel = false }) {
        if (guessedText) {
            this.#guessedText = guessedText;
            this.#textWithDisclaimer = textWithDisclaimer;
        }
        if (this.#altText === altText && this.#altTextDecorative === decorative) return;
        if (!cancel) {
            this.#altText = altText;
            this.#altTextDecorative = decorative;
        }
        this.#setState();
    }
    toggle(enabled = false) {
        if (!this.#altTextButton) return;
        if (!enabled && this.#altTextTooltipTimeout) {
            clearTimeout(this.#altTextTooltipTimeout);
            this.#altTextTooltipTimeout = null;
        }
        this.#altTextButton.disabled = !enabled;
    }
    shown() {
        this.#editor._reportTelemetry({
            action: "pdfjs.image.alt_text.image_status_label_displayed",
            data: {
                label: this.#label
            }
        });
    }
    destroy() {
        this.#altTextButton?.remove();
        this.#altTextButton = null;
        this.#altTextButtonLabel = null;
        this.#altTextTooltip = null;
        this.#badge?.remove();
        this.#badge = null;
    }
    async #setState() {
        const button = this.#altTextButton;
        if (!button) return;
        if (this.#useNewAltTextFlow) {
            button.classList.toggle("done", !!this.#altText);
            button.setAttribute("data-l10n-id", AltText.#l10nNewButton[this.#label]);
            this.#altTextButtonLabel?.setAttribute("data-l10n-id", AltText.#l10nNewButton[`${this.#label}-label`]);
            if (!this.#altText) {
                this.#altTextTooltip?.remove();
                return;
            }
        } else {
            if (!this.#altText && !this.#altTextDecorative) {
                button.classList.remove("done");
                this.#altTextTooltip?.remove();
                return;
            }
            button.classList.add("done");
            button.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
        }
        let tooltip = this.#altTextTooltip;
        if (!tooltip) {
            this.#altTextTooltip = tooltip = document.createElement("span");
            tooltip.className = "tooltip";
            tooltip.setAttribute("role", "tooltip");
            tooltip.id = `alt-text-tooltip-${this.#editor.id}`;
            const DELAY_TO_SHOW_TOOLTIP = 100;
            const signal = this.#editor._uiManager._signal;
            signal.addEventListener("abort", ()=>{
                clearTimeout(this.#altTextTooltipTimeout);
                this.#altTextTooltipTimeout = null;
            }, {
                once: true
            });
            button.addEventListener("mouseenter", ()=>{
                this.#altTextTooltipTimeout = setTimeout(()=>{
                    this.#altTextTooltipTimeout = null;
                    this.#altTextTooltip.classList.add("show");
                    this.#editor._reportTelemetry({
                        action: "alt_text_tooltip"
                    });
                }, DELAY_TO_SHOW_TOOLTIP);
            }, {
                signal
            });
            button.addEventListener("mouseleave", ()=>{
                if (this.#altTextTooltipTimeout) {
                    clearTimeout(this.#altTextTooltipTimeout);
                    this.#altTextTooltipTimeout = null;
                }
                this.#altTextTooltip?.classList.remove("show");
            }, {
                signal
            });
        }
        if (this.#altTextDecorative) tooltip.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip");
        else {
            tooltip.removeAttribute("data-l10n-id");
            tooltip.textContent = this.#altText;
        }
        if (!tooltip.parentNode) button.append(tooltip);
        const element = this.#editor.getImageForAltText();
        element?.setAttribute("aria-describedby", tooltip.id);
    }
}
class TouchManager {
    #container;
    #isPinching = false;
    #isPinchingStopped = null;
    #isPinchingDisabled;
    #onPinchStart;
    #onPinching;
    #onPinchEnd;
    #signal;
    #touchInfo = null;
    #touchManagerAC;
    #touchMoveAC = null;
    constructor({ container, isPinchingDisabled = null, isPinchingStopped = null, onPinchStart = null, onPinching = null, onPinchEnd = null, signal }){
        this.#container = container;
        this.#isPinchingStopped = isPinchingStopped;
        this.#isPinchingDisabled = isPinchingDisabled;
        this.#onPinchStart = onPinchStart;
        this.#onPinching = onPinching;
        this.#onPinchEnd = onPinchEnd;
        this.#touchManagerAC = new AbortController();
        this.#signal = AbortSignal.any([
            signal,
            this.#touchManagerAC.signal
        ]);
        container.addEventListener("touchstart", this.#onTouchStart.bind(this), {
            passive: false,
            signal: this.#signal
        });
    }
    get MIN_TOUCH_DISTANCE_TO_PINCH() {
        return shadow(this, "MIN_TOUCH_DISTANCE_TO_PINCH", 35 / (window.devicePixelRatio || 1));
    }
    #onTouchStart(evt) {
        if (this.#isPinchingDisabled?.() || evt.touches.length < 2) return;
        if (!this.#touchMoveAC) {
            this.#touchMoveAC = new AbortController();
            const signal = AbortSignal.any([
                this.#signal,
                this.#touchMoveAC.signal
            ]);
            const container = this.#container;
            const opt = {
                signal,
                passive: false
            };
            container.addEventListener("touchmove", this.#onTouchMove.bind(this), opt);
            container.addEventListener("touchend", this.#onTouchEnd.bind(this), opt);
            container.addEventListener("touchcancel", this.#onTouchEnd.bind(this), opt);
            this.#onPinchStart?.();
        }
        stopEvent(evt);
        if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {
            this.#touchInfo = null;
            return;
        }
        let [touch0, touch1] = evt.touches;
        if (touch0.identifier > touch1.identifier) [touch0, touch1] = [
            touch1,
            touch0
        ];
        this.#touchInfo = {
            touch0X: touch0.screenX,
            touch0Y: touch0.screenY,
            touch1X: touch1.screenX,
            touch1Y: touch1.screenY
        };
    }
    #onTouchMove(evt) {
        if (!this.#touchInfo || evt.touches.length !== 2) return;
        let [touch0, touch1] = evt.touches;
        if (touch0.identifier > touch1.identifier) [touch0, touch1] = [
            touch1,
            touch0
        ];
        const { screenX: screen0X, screenY: screen0Y } = touch0;
        const { screenX: screen1X, screenY: screen1Y } = touch1;
        const touchInfo = this.#touchInfo;
        const { touch0X: pTouch0X, touch0Y: pTouch0Y, touch1X: pTouch1X, touch1Y: pTouch1Y } = touchInfo;
        const prevGapX = pTouch1X - pTouch0X;
        const prevGapY = pTouch1Y - pTouch0Y;
        const currGapX = screen1X - screen0X;
        const currGapY = screen1Y - screen0Y;
        const distance = Math.hypot(currGapX, currGapY) || 1;
        const pDistance = Math.hypot(prevGapX, prevGapY) || 1;
        if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) return;
        touchInfo.touch0X = screen0X;
        touchInfo.touch0Y = screen0Y;
        touchInfo.touch1X = screen1X;
        touchInfo.touch1Y = screen1Y;
        evt.preventDefault();
        if (!this.#isPinching) {
            this.#isPinching = true;
            return;
        }
        const origin = [
            (screen0X + screen1X) / 2,
            (screen0Y + screen1Y) / 2
        ];
        this.#onPinching?.(origin, pDistance, distance);
    }
    #onTouchEnd(evt) {
        this.#touchMoveAC.abort();
        this.#touchMoveAC = null;
        this.#onPinchEnd?.();
        if (!this.#touchInfo) return;
        evt.preventDefault();
        this.#touchInfo = null;
        this.#isPinching = false;
    }
    destroy() {
        this.#touchManagerAC?.abort();
        this.#touchManagerAC = null;
    }
}
class AnnotationEditor {
    #accessibilityData = null;
    #allResizerDivs = null;
    #altText = null;
    #disabled = false;
    #dragPointerId = null;
    #dragPointerType = "";
    #keepAspectRatio = false;
    #resizersDiv = null;
    #lastPointerCoords = null;
    #savedDimensions = null;
    #focusAC = null;
    #focusedResizerName = "";
    #hasBeenClicked = false;
    #initialRect = null;
    #isEditing = false;
    #isInEditMode = false;
    #isResizerEnabledForKeyboard = false;
    #moveInDOMTimeout = null;
    #prevDragX = 0;
    #prevDragY = 0;
    #telemetryTimeouts = null;
    #touchManager = null;
    _editToolbar = null;
    _initialOptions = Object.create(null);
    _initialData = null;
    _isVisible = true;
    _uiManager = null;
    _focusEventsAllowed = true;
    static _l10n = null;
    static _l10nResizer = null;
    #isDraggable = false;
    #zIndex = AnnotationEditor._zIndex++;
    static _borderLineWidth = -1;
    static _colorManager = new ColorManager();
    static _zIndex = 1;
    static _telemetryTimeout = 1000;
    static get _resizerKeyboardManager() {
        const resize = AnnotationEditor.prototype._resizeWithKeyboard;
        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
        const big = AnnotationEditorUIManager.TRANSLATE_BIG;
        return shadow(this, "_resizerKeyboardManager", new KeyboardManager([
            [
                [
                    "ArrowLeft",
                    "mac+ArrowLeft"
                ],
                resize,
                {
                    args: [
                        -small,
                        0
                    ]
                }
            ],
            [
                [
                    "ctrl+ArrowLeft",
                    "mac+shift+ArrowLeft"
                ],
                resize,
                {
                    args: [
                        -big,
                        0
                    ]
                }
            ],
            [
                [
                    "ArrowRight",
                    "mac+ArrowRight"
                ],
                resize,
                {
                    args: [
                        small,
                        0
                    ]
                }
            ],
            [
                [
                    "ctrl+ArrowRight",
                    "mac+shift+ArrowRight"
                ],
                resize,
                {
                    args: [
                        big,
                        0
                    ]
                }
            ],
            [
                [
                    "ArrowUp",
                    "mac+ArrowUp"
                ],
                resize,
                {
                    args: [
                        0,
                        -small
                    ]
                }
            ],
            [
                [
                    "ctrl+ArrowUp",
                    "mac+shift+ArrowUp"
                ],
                resize,
                {
                    args: [
                        0,
                        -big
                    ]
                }
            ],
            [
                [
                    "ArrowDown",
                    "mac+ArrowDown"
                ],
                resize,
                {
                    args: [
                        0,
                        small
                    ]
                }
            ],
            [
                [
                    "ctrl+ArrowDown",
                    "mac+shift+ArrowDown"
                ],
                resize,
                {
                    args: [
                        0,
                        big
                    ]
                }
            ],
            [
                [
                    "Escape",
                    "mac+Escape"
                ],
                AnnotationEditor.prototype._stopResizingWithKeyboard
            ]
        ]));
    }
    constructor(parameters){
        this.parent = parameters.parent;
        this.id = parameters.id;
        this.width = this.height = null;
        this.pageIndex = parameters.parent.pageIndex;
        this.name = parameters.name;
        this.div = null;
        this._uiManager = parameters.uiManager;
        this.annotationElementId = null;
        this._willKeepAspectRatio = false;
        this._initialOptions.isCentered = parameters.isCentered;
        this._structTreeParentId = null;
        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;
        this.rotation = rotation;
        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
        this.pageDimensions = [
            pageWidth,
            pageHeight
        ];
        this.pageTranslation = [
            pageX,
            pageY
        ];
        const [width, height] = this.parentDimensions;
        this.x = parameters.x / width;
        this.y = parameters.y / height;
        this.isAttachedToDOM = false;
        this.deleted = false;
    }
    get editorType() {
        return Object.getPrototypeOf(this).constructor._type;
    }
    static get isDrawer() {
        return false;
    }
    static get _defaultLineColor() {
        return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
    }
    static deleteAnnotationElement(editor) {
        const fakeEditor = new FakeEditor({
            id: editor.parent.getNextId(),
            parent: editor.parent,
            uiManager: editor._uiManager
        });
        fakeEditor.annotationElementId = editor.annotationElementId;
        fakeEditor.deleted = true;
        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
    }
    static initialize(l10n, _uiManager) {
        AnnotationEditor._l10n ??= l10n;
        AnnotationEditor._l10nResizer ||= Object.freeze({
            topLeft: "pdfjs-editor-resizer-top-left",
            topMiddle: "pdfjs-editor-resizer-top-middle",
            topRight: "pdfjs-editor-resizer-top-right",
            middleRight: "pdfjs-editor-resizer-middle-right",
            bottomRight: "pdfjs-editor-resizer-bottom-right",
            bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
            bottomLeft: "pdfjs-editor-resizer-bottom-left",
            middleLeft: "pdfjs-editor-resizer-middle-left"
        });
        if (AnnotationEditor._borderLineWidth !== -1) return;
        const style = getComputedStyle(document.documentElement);
        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
    }
    static updateDefaultParams(_type, _value) {}
    static get defaultPropertiesToUpdate() {
        return [];
    }
    static isHandlingMimeForPasting(mime) {
        return false;
    }
    static paste(item, parent) {
        unreachable("Not implemented");
    }
    get propertiesToUpdate() {
        return [];
    }
    get _isDraggable() {
        return this.#isDraggable;
    }
    set _isDraggable(value) {
        this.#isDraggable = value;
        this.div?.classList.toggle("draggable", value);
    }
    get isEnterHandled() {
        return true;
    }
    center() {
        const [pageWidth, pageHeight] = this.pageDimensions;
        switch(this.parentRotation){
            case 90:
                this.x -= this.height * pageHeight / (pageWidth * 2);
                this.y += this.width * pageWidth / (pageHeight * 2);
                break;
            case 180:
                this.x += this.width / 2;
                this.y += this.height / 2;
                break;
            case 270:
                this.x += this.height * pageHeight / (pageWidth * 2);
                this.y -= this.width * pageWidth / (pageHeight * 2);
                break;
            default:
                this.x -= this.width / 2;
                this.y -= this.height / 2;
                break;
        }
        this.fixAndSetPosition();
    }
    addCommands(params) {
        this._uiManager.addCommands(params);
    }
    get currentLayer() {
        return this._uiManager.currentLayer;
    }
    setInBackground() {
        this.div.style.zIndex = 0;
    }
    setInForeground() {
        this.div.style.zIndex = this.#zIndex;
    }
    setParent(parent) {
        if (parent !== null) {
            this.pageIndex = parent.pageIndex;
            this.pageDimensions = parent.pageDimensions;
        } else this.#stopResizing();
        this.parent = parent;
    }
    focusin(event) {
        if (!this._focusEventsAllowed) return;
        if (!this.#hasBeenClicked) this.parent.setSelected(this);
        else this.#hasBeenClicked = false;
    }
    focusout(event) {
        if (!this._focusEventsAllowed) return;
        if (!this.isAttachedToDOM) return;
        const target = event.relatedTarget;
        if (target?.closest(`#${this.id}`)) return;
        event.preventDefault();
        if (!this.parent?.isMultipleSelection) this.commitOrRemove();
    }
    commitOrRemove() {
        if (this.isEmpty()) this.remove();
        else this.commit();
    }
    commit() {
        this.addToAnnotationStorage();
    }
    addToAnnotationStorage() {
        this._uiManager.addToAnnotationStorage(this);
    }
    setAt(x, y, tx, ty) {
        const [width, height] = this.parentDimensions;
        [tx, ty] = this.screenToPageTranslation(tx, ty);
        this.x = (x + tx) / width;
        this.y = (y + ty) / height;
        this.fixAndSetPosition();
    }
    #translate([width, height], x, y) {
        [x, y] = this.screenToPageTranslation(x, y);
        this.x += x / width;
        this.y += y / height;
        this._onTranslating(this.x, this.y);
        this.fixAndSetPosition();
    }
    translate(x, y) {
        this.#translate(this.parentDimensions, x, y);
    }
    translateInPage(x, y) {
        this.#initialRect ||= [
            this.x,
            this.y,
            this.width,
            this.height
        ];
        this.#translate(this.pageDimensions, x, y);
        this.div.scrollIntoView({
            block: "nearest"
        });
    }
    drag(tx, ty) {
        this.#initialRect ||= [
            this.x,
            this.y,
            this.width,
            this.height
        ];
        const { div, parentDimensions: [parentWidth, parentHeight] } = this;
        this.x += tx / parentWidth;
        this.y += ty / parentHeight;
        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
            const { x, y } = this.div.getBoundingClientRect();
            if (this.parent.findNewParent(this, x, y)) {
                this.x -= Math.floor(this.x);
                this.y -= Math.floor(this.y);
            }
        }
        let { x, y } = this;
        const [bx, by] = this.getBaseTranslation();
        x += bx;
        y += by;
        const { style } = div;
        style.left = `${(100 * x).toFixed(2)}%`;
        style.top = `${(100 * y).toFixed(2)}%`;
        this._onTranslating(x, y);
        div.scrollIntoView({
            block: "nearest"
        });
    }
    _onTranslating(x, y) {}
    _onTranslated(x, y) {}
    get _hasBeenMoved() {
        return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);
    }
    get _hasBeenResized() {
        return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);
    }
    getBaseTranslation() {
        const [parentWidth, parentHeight] = this.parentDimensions;
        const { _borderLineWidth } = AnnotationEditor;
        const x = _borderLineWidth / parentWidth;
        const y = _borderLineWidth / parentHeight;
        switch(this.rotation){
            case 90:
                return [
                    -x,
                    y
                ];
            case 180:
                return [
                    x,
                    y
                ];
            case 270:
                return [
                    x,
                    -y
                ];
            default:
                return [
                    -x,
                    -y
                ];
        }
    }
    get _mustFixPosition() {
        return true;
    }
    fixAndSetPosition(rotation = this.rotation) {
        const { div: { style }, pageDimensions: [pageWidth, pageHeight] } = this;
        let { x, y, width, height } = this;
        width *= pageWidth;
        height *= pageHeight;
        x *= pageWidth;
        y *= pageHeight;
        if (this._mustFixPosition) switch(rotation){
            case 0:
                x = Math.max(0, Math.min(pageWidth - width, x));
                y = Math.max(0, Math.min(pageHeight - height, y));
                break;
            case 90:
                x = Math.max(0, Math.min(pageWidth - height, x));
                y = Math.min(pageHeight, Math.max(width, y));
                break;
            case 180:
                x = Math.min(pageWidth, Math.max(width, x));
                y = Math.min(pageHeight, Math.max(height, y));
                break;
            case 270:
                x = Math.min(pageWidth, Math.max(height, x));
                y = Math.max(0, Math.min(pageHeight - width, y));
                break;
        }
        this.x = x /= pageWidth;
        this.y = y /= pageHeight;
        const [bx, by] = this.getBaseTranslation();
        x += bx;
        y += by;
        style.left = `${(100 * x).toFixed(2)}%`;
        style.top = `${(100 * y).toFixed(2)}%`;
        this.moveInDOM();
    }
    static #rotatePoint(x, y, angle) {
        switch(angle){
            case 90:
                return [
                    y,
                    -x
                ];
            case 180:
                return [
                    -x,
                    -y
                ];
            case 270:
                return [
                    -y,
                    x
                ];
            default:
                return [
                    x,
                    y
                ];
        }
    }
    screenToPageTranslation(x, y) {
        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);
    }
    pageTranslationToScreen(x, y) {
        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);
    }
    #getRotationMatrix(rotation) {
        switch(rotation){
            case 90:
                {
                    const [pageWidth, pageHeight] = this.pageDimensions;
                    return [
                        0,
                        -pageWidth / pageHeight,
                        pageHeight / pageWidth,
                        0
                    ];
                }
            case 180:
                return [
                    -1,
                    0,
                    0,
                    -1
                ];
            case 270:
                {
                    const [pageWidth, pageHeight] = this.pageDimensions;
                    return [
                        0,
                        pageWidth / pageHeight,
                        -pageHeight / pageWidth,
                        0
                    ];
                }
            default:
                return [
                    1,
                    0,
                    0,
                    1
                ];
        }
    }
    get parentScale() {
        return this._uiManager.viewParameters.realScale;
    }
    get parentRotation() {
        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
    }
    get parentDimensions() {
        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;
        return [
            pageWidth * parentScale,
            pageHeight * parentScale
        ];
    }
    setDims(width, height) {
        const [parentWidth, parentHeight] = this.parentDimensions;
        const { style } = this.div;
        style.width = `${(100 * width / parentWidth).toFixed(2)}%`;
        if (!this.#keepAspectRatio) style.height = `${(100 * height / parentHeight).toFixed(2)}%`;
    }
    fixDims() {
        const { style } = this.div;
        const { height, width } = style;
        const widthPercent = width.endsWith("%");
        const heightPercent = !this.#keepAspectRatio && height.endsWith("%");
        if (widthPercent && heightPercent) return;
        const [parentWidth, parentHeight] = this.parentDimensions;
        if (!widthPercent) style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;
        if (!this.#keepAspectRatio && !heightPercent) style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;
    }
    getInitialTranslation() {
        return [
            0,
            0
        ];
    }
    #createResizers() {
        if (this.#resizersDiv) return;
        this.#resizersDiv = document.createElement("div");
        this.#resizersDiv.classList.add("resizers");
        const classes = this._willKeepAspectRatio ? [
            "topLeft",
            "topRight",
            "bottomRight",
            "bottomLeft"
        ] : [
            "topLeft",
            "topMiddle",
            "topRight",
            "middleRight",
            "bottomRight",
            "bottomMiddle",
            "bottomLeft",
            "middleLeft"
        ];
        const signal = this._uiManager._signal;
        for (const name of classes){
            const div = document.createElement("div");
            this.#resizersDiv.append(div);
            div.classList.add("resizer", name);
            div.setAttribute("data-resizer-name", name);
            div.addEventListener("pointerdown", this.#resizerPointerdown.bind(this, name), {
                signal
            });
            div.addEventListener("contextmenu", noContextMenu, {
                signal
            });
            div.tabIndex = -1;
        }
        this.div.prepend(this.#resizersDiv);
    }
    #resizerPointerdown(name, event) {
        event.preventDefault();
        const { isMac } = util_FeatureTest.platform;
        if (event.button !== 0 || event.ctrlKey && isMac) return;
        this.#altText?.toggle(false);
        const savedDraggable = this._isDraggable;
        this._isDraggable = false;
        this.#lastPointerCoords = [
            event.screenX,
            event.screenY
        ];
        const ac = new AbortController();
        const signal = this._uiManager.combinedSignal(ac);
        this.parent.togglePointerEvents(false);
        window.addEventListener("pointermove", this.#resizerPointermove.bind(this, name), {
            passive: true,
            capture: true,
            signal
        });
        window.addEventListener("touchmove", stopEvent, {
            passive: false,
            signal
        });
        window.addEventListener("contextmenu", noContextMenu, {
            signal
        });
        this.#savedDimensions = {
            savedX: this.x,
            savedY: this.y,
            savedWidth: this.width,
            savedHeight: this.height
        };
        const savedParentCursor = this.parent.div.style.cursor;
        const savedCursor = this.div.style.cursor;
        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
        const pointerUpCallback = ()=>{
            ac.abort();
            this.parent.togglePointerEvents(true);
            this.#altText?.toggle(true);
            this._isDraggable = savedDraggable;
            this.parent.div.style.cursor = savedParentCursor;
            this.div.style.cursor = savedCursor;
            this.#addResizeToUndoStack();
        };
        window.addEventListener("pointerup", pointerUpCallback, {
            signal
        });
        window.addEventListener("blur", pointerUpCallback, {
            signal
        });
    }
    #resize(x, y, width, height) {
        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(parentWidth * width, parentHeight * height);
        this.fixAndSetPosition();
        this._onResized();
    }
    _onResized() {}
    #addResizeToUndoStack() {
        if (!this.#savedDimensions) return;
        const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;
        this.#savedDimensions = null;
        const newX = this.x;
        const newY = this.y;
        const newWidth = this.width;
        const newHeight = this.height;
        if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) return;
        this.addCommands({
            cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),
            undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),
            mustExec: true
        });
    }
    static _round(x) {
        return Math.round(x * 10000) / 10000;
    }
    #resizerPointermove(name, event) {
        const [parentWidth, parentHeight] = this.parentDimensions;
        const savedX = this.x;
        const savedY = this.y;
        const savedWidth = this.width;
        const savedHeight = this.height;
        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
        const rotationMatrix = this.#getRotationMatrix(this.rotation);
        const transf = (x, y)=>[
                rotationMatrix[0] * x + rotationMatrix[2] * y,
                rotationMatrix[1] * x + rotationMatrix[3] * y
            ];
        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);
        const invTransf = (x, y)=>[
                invRotationMatrix[0] * x + invRotationMatrix[2] * y,
                invRotationMatrix[1] * x + invRotationMatrix[3] * y
            ];
        let getPoint;
        let getOpposite;
        let isDiagonal = false;
        let isHorizontal = false;
        switch(name){
            case "topLeft":
                isDiagonal = true;
                getPoint = (w, h)=>[
                        0,
                        0
                    ];
                getOpposite = (w, h)=>[
                        w,
                        h
                    ];
                break;
            case "topMiddle":
                getPoint = (w, h)=>[
                        w / 2,
                        0
                    ];
                getOpposite = (w, h)=>[
                        w / 2,
                        h
                    ];
                break;
            case "topRight":
                isDiagonal = true;
                getPoint = (w, h)=>[
                        w,
                        0
                    ];
                getOpposite = (w, h)=>[
                        0,
                        h
                    ];
                break;
            case "middleRight":
                isHorizontal = true;
                getPoint = (w, h)=>[
                        w,
                        h / 2
                    ];
                getOpposite = (w, h)=>[
                        0,
                        h / 2
                    ];
                break;
            case "bottomRight":
                isDiagonal = true;
                getPoint = (w, h)=>[
                        w,
                        h
                    ];
                getOpposite = (w, h)=>[
                        0,
                        0
                    ];
                break;
            case "bottomMiddle":
                getPoint = (w, h)=>[
                        w / 2,
                        h
                    ];
                getOpposite = (w, h)=>[
                        w / 2,
                        0
                    ];
                break;
            case "bottomLeft":
                isDiagonal = true;
                getPoint = (w, h)=>[
                        0,
                        h
                    ];
                getOpposite = (w, h)=>[
                        w,
                        0
                    ];
                break;
            case "middleLeft":
                isHorizontal = true;
                getPoint = (w, h)=>[
                        0,
                        h / 2
                    ];
                getOpposite = (w, h)=>[
                        w,
                        h / 2
                    ];
                break;
        }
        const point = getPoint(savedWidth, savedHeight);
        const oppositePoint = getOpposite(savedWidth, savedHeight);
        let transfOppositePoint = transf(...oppositePoint);
        const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);
        const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);
        let ratioX = 1;
        let ratioY = 1;
        let deltaX, deltaY;
        if (!event.fromKeyboard) {
            const { screenX, screenY } = event;
            const [lastScreenX, lastScreenY] = this.#lastPointerCoords;
            [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);
            this.#lastPointerCoords[0] = screenX;
            this.#lastPointerCoords[1] = screenY;
        } else ({ deltaX, deltaY } = event);
        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
        if (isDiagonal) {
            const oldDiag = Math.hypot(savedWidth, savedHeight);
            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
        } else if (isHorizontal) ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;
        else ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;
        const newWidth = AnnotationEditor._round(savedWidth * ratioX);
        const newHeight = AnnotationEditor._round(savedHeight * ratioY);
        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
        const newX = oppositeX - transfOppositePoint[0];
        const newY = oppositeY - transfOppositePoint[1];
        this.#initialRect ||= [
            this.x,
            this.y,
            this.width,
            this.height
        ];
        this.width = newWidth;
        this.height = newHeight;
        this.x = newX;
        this.y = newY;
        this.setDims(parentWidth * newWidth, parentHeight * newHeight);
        this.fixAndSetPosition();
        this._onResizing();
    }
    _onResizing() {}
    altTextFinish() {
        this.#altText?.finish();
    }
    async addEditToolbar() {
        if (this._editToolbar || this.#isInEditMode) return this._editToolbar;
        this._editToolbar = new EditorToolbar(this);
        this.div.append(this._editToolbar.render());
        if (this.#altText) await this._editToolbar.addAltText(this.#altText);
        return this._editToolbar;
    }
    removeEditToolbar() {
        if (!this._editToolbar) return;
        this._editToolbar.remove();
        this._editToolbar = null;
        this.#altText?.destroy();
    }
    addContainer(container) {
        const editToolbarDiv = this._editToolbar?.div;
        if (editToolbarDiv) editToolbarDiv.before(container);
        else this.div.append(container);
    }
    getClientDimensions() {
        return this.div.getBoundingClientRect();
    }
    async addAltTextButton() {
        if (this.#altText) return;
        AltText.initialize(AnnotationEditor._l10n);
        this.#altText = new AltText(this);
        if (this.#accessibilityData) {
            this.#altText.data = this.#accessibilityData;
            this.#accessibilityData = null;
        }
        await this.addEditToolbar();
    }
    get altTextData() {
        return this.#altText?.data;
    }
    set altTextData(data) {
        if (!this.#altText) return;
        this.#altText.data = data;
    }
    get guessedAltText() {
        return this.#altText?.guessedText;
    }
    async setGuessedAltText(text) {
        await this.#altText?.setGuessedText(text);
    }
    serializeAltText(isForCopying) {
        return this.#altText?.serialize(isForCopying);
    }
    hasAltText() {
        return !!this.#altText && !this.#altText.isEmpty();
    }
    hasAltTextData() {
        return this.#altText?.hasData() ?? false;
    }
    render() {
        this.div = document.createElement("div");
        this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
        this.div.className = this.name;
        this.div.setAttribute("id", this.id);
        this.div.tabIndex = this.#disabled ? -1 : 0;
        if (!this._isVisible) this.div.classList.add("hidden");
        this.setInForeground();
        this.#addFocusListeners();
        const [parentWidth, parentHeight] = this.parentDimensions;
        if (this.parentRotation % 180 !== 0) {
            this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
            this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
        }
        const [tx, ty] = this.getInitialTranslation();
        this.translate(tx, ty);
        bindEvents(this, this.div, [
            "pointerdown"
        ]);
        if (this.isResizable && this._uiManager._supportsPinchToZoom) this.#touchManager ||= new TouchManager({
            container: this.div,
            isPinchingDisabled: ()=>!this.isSelected,
            onPinchStart: this.#touchPinchStartCallback.bind(this),
            onPinching: this.#touchPinchCallback.bind(this),
            onPinchEnd: this.#touchPinchEndCallback.bind(this),
            signal: this._uiManager._signal
        });
        this._uiManager._editorUndoBar?.hide();
        return this.div;
    }
    #touchPinchStartCallback() {
        this.#savedDimensions = {
            savedX: this.x,
            savedY: this.y,
            savedWidth: this.width,
            savedHeight: this.height
        };
        this.#altText?.toggle(false);
        this.parent.togglePointerEvents(false);
    }
    #touchPinchCallback(_origin, prevDistance, distance) {
        const slowDownFactor = 0.7;
        let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;
        if (factor === 1) return;
        const rotationMatrix = this.#getRotationMatrix(this.rotation);
        const transf = (x, y)=>[
                rotationMatrix[0] * x + rotationMatrix[2] * y,
                rotationMatrix[1] * x + rotationMatrix[3] * y
            ];
        const [parentWidth, parentHeight] = this.parentDimensions;
        const savedX = this.x;
        const savedY = this.y;
        const savedWidth = this.width;
        const savedHeight = this.height;
        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
        factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
        const newWidth = AnnotationEditor._round(savedWidth * factor);
        const newHeight = AnnotationEditor._round(savedHeight * factor);
        if (newWidth === savedWidth && newHeight === savedHeight) return;
        this.#initialRect ||= [
            savedX,
            savedY,
            savedWidth,
            savedHeight
        ];
        const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);
        const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);
        const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);
        const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);
        this.x = centerX - newTransfCenterPoint[0];
        this.y = centerY - newTransfCenterPoint[1];
        this.width = newWidth;
        this.height = newHeight;
        this.setDims(parentWidth * newWidth, parentHeight * newHeight);
        this.fixAndSetPosition();
        this._onResizing();
    }
    #touchPinchEndCallback() {
        this.#altText?.toggle(true);
        this.parent.togglePointerEvents(true);
        this.#addResizeToUndoStack();
    }
    pointerdown(event) {
        const { isMac } = util_FeatureTest.platform;
        if (event.button !== 0 || event.ctrlKey && isMac) {
            event.preventDefault();
            return;
        }
        this.#hasBeenClicked = true;
        if (this._isDraggable) {
            this.#setUpDragSession(event);
            return;
        }
        this.#selectOnPointerEvent(event);
    }
    get isSelected() {
        return this._uiManager.isSelected(this);
    }
    #selectOnPointerEvent(event) {
        const { isMac } = util_FeatureTest.platform;
        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) this.parent.toggleSelected(this);
        else this.parent.setSelected(this);
    }
    #setUpDragSession(event) {
        const { isSelected } = this;
        this._uiManager.setUpDragSession();
        let hasDraggingStarted = false;
        const ac = new AbortController();
        const signal = this._uiManager.combinedSignal(ac);
        const opts = {
            capture: true,
            passive: false,
            signal
        };
        const cancelDrag = (e)=>{
            ac.abort();
            this.#dragPointerId = null;
            this.#hasBeenClicked = false;
            if (!this._uiManager.endDragSession()) this.#selectOnPointerEvent(e);
            if (hasDraggingStarted) this._onStopDragging();
        };
        if (isSelected) {
            this.#prevDragX = event.clientX;
            this.#prevDragY = event.clientY;
            this.#dragPointerId = event.pointerId;
            this.#dragPointerType = event.pointerType;
            window.addEventListener("pointermove", (e)=>{
                if (!hasDraggingStarted) {
                    hasDraggingStarted = true;
                    this._onStartDragging();
                }
                const { clientX: x, clientY: y, pointerId } = e;
                if (pointerId !== this.#dragPointerId) {
                    stopEvent(e);
                    return;
                }
                const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);
                this.#prevDragX = x;
                this.#prevDragY = y;
                this._uiManager.dragSelectedEditors(tx, ty);
            }, opts);
            window.addEventListener("touchmove", stopEvent, opts);
            window.addEventListener("pointerdown", (e)=>{
                if (e.pointerType === this.#dragPointerType) {
                    if (this.#touchManager || e.isPrimary) cancelDrag(e);
                }
                stopEvent(e);
            }, opts);
        }
        const pointerUpCallback = (e)=>{
            if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {
                cancelDrag(e);
                return;
            }
            stopEvent(e);
        };
        window.addEventListener("pointerup", pointerUpCallback, {
            signal
        });
        window.addEventListener("blur", pointerUpCallback, {
            signal
        });
    }
    _onStartDragging() {}
    _onStopDragging() {}
    moveInDOM() {
        if (this.#moveInDOMTimeout) clearTimeout(this.#moveInDOMTimeout);
        this.#moveInDOMTimeout = setTimeout(()=>{
            this.#moveInDOMTimeout = null;
            this.parent?.moveEditorInDOM(this);
        }, 0);
    }
    _setParentAndPosition(parent, x, y) {
        parent.changeParent(this);
        this.x = x;
        this.y = y;
        this.fixAndSetPosition();
        this._onTranslated();
    }
    getRect(tx, ty, rotation = this.rotation) {
        const scale = this.parentScale;
        const [pageWidth, pageHeight] = this.pageDimensions;
        const [pageX, pageY] = this.pageTranslation;
        const shiftX = tx / scale;
        const shiftY = ty / scale;
        const x = this.x * pageWidth;
        const y = this.y * pageHeight;
        const width = this.width * pageWidth;
        const height = this.height * pageHeight;
        switch(rotation){
            case 0:
                return [
                    x + shiftX + pageX,
                    pageHeight - y - shiftY - height + pageY,
                    x + shiftX + width + pageX,
                    pageHeight - y - shiftY + pageY
                ];
            case 90:
                return [
                    x + shiftY + pageX,
                    pageHeight - y + shiftX + pageY,
                    x + shiftY + height + pageX,
                    pageHeight - y + shiftX + width + pageY
                ];
            case 180:
                return [
                    x - shiftX - width + pageX,
                    pageHeight - y + shiftY + pageY,
                    x - shiftX + pageX,
                    pageHeight - y + shiftY + height + pageY
                ];
            case 270:
                return [
                    x - shiftY - height + pageX,
                    pageHeight - y - shiftX - width + pageY,
                    x - shiftY + pageX,
                    pageHeight - y - shiftX + pageY
                ];
            default:
                throw new Error("Invalid rotation");
        }
    }
    getRectInCurrentCoords(rect, pageHeight) {
        const [x1, y1, x2, y2] = rect;
        const width = x2 - x1;
        const height = y2 - y1;
        switch(this.rotation){
            case 0:
                return [
                    x1,
                    pageHeight - y2,
                    width,
                    height
                ];
            case 90:
                return [
                    x1,
                    pageHeight - y1,
                    height,
                    width
                ];
            case 180:
                return [
                    x2,
                    pageHeight - y1,
                    width,
                    height
                ];
            case 270:
                return [
                    x2,
                    pageHeight - y2,
                    height,
                    width
                ];
            default:
                throw new Error("Invalid rotation");
        }
    }
    onceAdded(focus) {}
    isEmpty() {
        return false;
    }
    enableEditMode() {
        this.#isInEditMode = true;
    }
    disableEditMode() {
        this.#isInEditMode = false;
    }
    isInEditMode() {
        return this.#isInEditMode;
    }
    shouldGetKeyboardEvents() {
        return this.#isResizerEnabledForKeyboard;
    }
    needsToBeRebuilt() {
        return this.div && !this.isAttachedToDOM;
    }
    get isOnScreen() {
        const { top, left, bottom, right } = this.getClientDimensions();
        const { innerHeight, innerWidth } = window;
        return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;
    }
    #addFocusListeners() {
        if (this.#focusAC || !this.div) return;
        this.#focusAC = new AbortController();
        const signal = this._uiManager.combinedSignal(this.#focusAC);
        this.div.addEventListener("focusin", this.focusin.bind(this), {
            signal
        });
        this.div.addEventListener("focusout", this.focusout.bind(this), {
            signal
        });
    }
    rebuild() {
        this.#addFocusListeners();
    }
    rotate(_angle) {}
    resize() {}
    serializeDeleted() {
        return {
            id: this.annotationElementId,
            deleted: true,
            pageIndex: this.pageIndex,
            popupRef: this._initialData?.popupRef || ""
        };
    }
    serialize(isForCopying = false, context = null) {
        unreachable("An editor must be serializable");
    }
    static async deserialize(data, parent, uiManager) {
        const editor = new this.prototype.constructor({
            parent,
            id: parent.getNextId(),
            uiManager
        });
        editor.rotation = data.rotation;
        editor.#accessibilityData = data.accessibilityData;
        const [pageWidth, pageHeight] = editor.pageDimensions;
        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
        editor.x = x / pageWidth;
        editor.y = y / pageHeight;
        editor.width = width / pageWidth;
        editor.height = height / pageHeight;
        return editor;
    }
    get hasBeenModified() {
        return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
    }
    remove() {
        this.#focusAC?.abort();
        this.#focusAC = null;
        if (!this.isEmpty()) this.commit();
        if (this.parent) this.parent.remove(this);
        else this._uiManager.removeEditor(this);
        if (this.#moveInDOMTimeout) {
            clearTimeout(this.#moveInDOMTimeout);
            this.#moveInDOMTimeout = null;
        }
        this.#stopResizing();
        this.removeEditToolbar();
        if (this.#telemetryTimeouts) {
            for (const timeout of this.#telemetryTimeouts.values())clearTimeout(timeout);
            this.#telemetryTimeouts = null;
        }
        this.parent = null;
        this.#touchManager?.destroy();
        this.#touchManager = null;
    }
    get isResizable() {
        return false;
    }
    makeResizable() {
        if (this.isResizable) {
            this.#createResizers();
            this.#resizersDiv.classList.remove("hidden");
            bindEvents(this, this.div, [
                "keydown"
            ]);
        }
    }
    get toolbarPosition() {
        return null;
    }
    keydown(event) {
        if (!this.isResizable || event.target !== this.div || event.key !== "Enter") return;
        this._uiManager.setSelected(this);
        this.#savedDimensions = {
            savedX: this.x,
            savedY: this.y,
            savedWidth: this.width,
            savedHeight: this.height
        };
        const children = this.#resizersDiv.children;
        if (!this.#allResizerDivs) {
            this.#allResizerDivs = Array.from(children);
            const boundResizerKeydown = this.#resizerKeydown.bind(this);
            const boundResizerBlur = this.#resizerBlur.bind(this);
            const signal = this._uiManager._signal;
            for (const div of this.#allResizerDivs){
                const name = div.getAttribute("data-resizer-name");
                div.setAttribute("role", "spinbutton");
                div.addEventListener("keydown", boundResizerKeydown, {
                    signal
                });
                div.addEventListener("blur", boundResizerBlur, {
                    signal
                });
                div.addEventListener("focus", this.#resizerFocus.bind(this, name), {
                    signal
                });
                div.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[name]);
            }
        }
        const first = this.#allResizerDivs[0];
        let firstPosition = 0;
        for (const div of children){
            if (div === first) break;
            firstPosition++;
        }
        const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);
        if (nextFirstPosition !== firstPosition) {
            if (nextFirstPosition < firstPosition) for(let i = 0; i < firstPosition - nextFirstPosition; i++)this.#resizersDiv.append(this.#resizersDiv.firstChild);
            else if (nextFirstPosition > firstPosition) for(let i = 0; i < nextFirstPosition - firstPosition; i++)this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);
            let i = 0;
            for (const child of children){
                const div = this.#allResizerDivs[i++];
                const name = div.getAttribute("data-resizer-name");
                child.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[name]);
            }
        }
        this.#setResizerTabIndex(0);
        this.#isResizerEnabledForKeyboard = true;
        this.#resizersDiv.firstChild.focus({
            focusVisible: true
        });
        event.preventDefault();
        event.stopImmediatePropagation();
    }
    #resizerKeydown(event) {
        AnnotationEditor._resizerKeyboardManager.exec(this, event);
    }
    #resizerBlur(event) {
        if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) this.#stopResizing();
    }
    #resizerFocus(name) {
        this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : "";
    }
    #setResizerTabIndex(value) {
        if (!this.#allResizerDivs) return;
        for (const div of this.#allResizerDivs)div.tabIndex = value;
    }
    _resizeWithKeyboard(x, y) {
        if (!this.#isResizerEnabledForKeyboard) return;
        this.#resizerPointermove(this.#focusedResizerName, {
            deltaX: x,
            deltaY: y,
            fromKeyboard: true
        });
    }
    #stopResizing() {
        this.#isResizerEnabledForKeyboard = false;
        this.#setResizerTabIndex(-1);
        this.#addResizeToUndoStack();
    }
    _stopResizingWithKeyboard() {
        this.#stopResizing();
        this.div.focus();
    }
    select() {
        this.makeResizable();
        this.div?.classList.add("selectedEditor");
        if (!this._editToolbar) {
            this.addEditToolbar().then(()=>{
                if (this.div?.classList.contains("selectedEditor")) this._editToolbar?.show();
            });
            return;
        }
        this._editToolbar?.show();
        this.#altText?.toggleAltTextBadge(false);
    }
    unselect() {
        this.#resizersDiv?.classList.add("hidden");
        this.div?.classList.remove("selectedEditor");
        if (this.div?.contains(document.activeElement)) this._uiManager.currentLayer.div.focus({
            preventScroll: true
        });
        this._editToolbar?.hide();
        this.#altText?.toggleAltTextBadge(true);
    }
    updateParams(type, value) {}
    disableEditing() {}
    enableEditing() {}
    enterInEditMode() {}
    getImageForAltText() {
        return null;
    }
    get contentDiv() {
        return this.div;
    }
    get isEditing() {
        return this.#isEditing;
    }
    set isEditing(value) {
        this.#isEditing = value;
        if (!this.parent) return;
        if (value) {
            this.parent.setSelected(this);
            this.parent.setActiveEditor(this);
        } else this.parent.setActiveEditor(null);
    }
    setAspectRatio(width, height) {
        this.#keepAspectRatio = true;
        const aspectRatio = width / height;
        const { style } = this.div;
        style.aspectRatio = aspectRatio;
        style.height = "auto";
    }
    static get MIN_SIZE() {
        return 16;
    }
    static canCreateNewEmptyEditor() {
        return true;
    }
    get telemetryInitialData() {
        return {
            action: "added"
        };
    }
    get telemetryFinalData() {
        return null;
    }
    _reportTelemetry(data, mustWait = false) {
        if (mustWait) {
            this.#telemetryTimeouts ||= new Map();
            const { action } = data;
            let timeout = this.#telemetryTimeouts.get(action);
            if (timeout) clearTimeout(timeout);
            timeout = setTimeout(()=>{
                this._reportTelemetry(data);
                this.#telemetryTimeouts.delete(action);
                if (this.#telemetryTimeouts.size === 0) this.#telemetryTimeouts = null;
            }, AnnotationEditor._telemetryTimeout);
            this.#telemetryTimeouts.set(action, timeout);
            return;
        }
        data.type ||= this.editorType;
        this._uiManager._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
                type: "editing",
                data
            }
        });
    }
    show(visible = this._isVisible) {
        this.div.classList.toggle("hidden", !visible);
        this._isVisible = visible;
    }
    enable() {
        if (this.div) this.div.tabIndex = 0;
        this.#disabled = false;
    }
    disable() {
        if (this.div) this.div.tabIndex = -1;
        this.#disabled = true;
    }
    renderAnnotationElement(annotation) {
        let content = annotation.container.querySelector(".annotationContent");
        if (!content) {
            content = document.createElement("div");
            content.classList.add("annotationContent", this.editorType);
            annotation.container.prepend(content);
        } else if (content.nodeName === "CANVAS") {
            const canvas = content;
            content = document.createElement("div");
            content.classList.add("annotationContent", this.editorType);
            canvas.before(content);
        }
        return content;
    }
    resetAnnotationElement(annotation) {
        const { firstChild } = annotation.container;
        if (firstChild?.nodeName === "DIV" && firstChild.classList.contains("annotationContent")) firstChild.remove();
    }
}
class FakeEditor extends AnnotationEditor {
    constructor(params){
        super(params);
        this.annotationElementId = params.annotationElementId;
        this.deleted = true;
    }
    serialize() {
        return this.serializeDeleted();
    }
}
const SEED = 0xc3d2e1f0;
const MASK_HIGH = 0xffff0000;
const MASK_LOW = 0xffff;
class MurmurHash3_64 {
    constructor(seed){
        this.h1 = seed ? seed & 0xffffffff : SEED;
        this.h2 = seed ? seed & 0xffffffff : SEED;
    }
    update(input) {
        let data, length;
        if (typeof input === "string") {
            data = new Uint8Array(input.length * 2);
            length = 0;
            for(let i = 0, ii = input.length; i < ii; i++){
                const code = input.charCodeAt(i);
                if (code <= 0xff) data[length++] = code;
                else {
                    data[length++] = code >>> 8;
                    data[length++] = code & 0xff;
                }
            }
        } else if (ArrayBuffer.isView(input)) {
            data = input.slice();
            length = data.byteLength;
        } else throw new Error("Invalid data format, must be a string or TypedArray.");
        const blockCounts = length >> 2;
        const tailLength = length - blockCounts * 4;
        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
        let k1 = 0, k2 = 0;
        let h1 = this.h1, h2 = this.h2;
        const C1 = 0xcc9e2d51, C2 = 0x1b873593;
        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
        for(let i = 0; i < blockCounts; i++)if (i & 1) {
            k1 = dataUint32[i];
            k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 0xe6546b64;
        } else {
            k2 = dataUint32[i];
            k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
            k2 = k2 << 15 | k2 >>> 17;
            k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
            h2 ^= k2;
            h2 = h2 << 13 | h2 >>> 19;
            h2 = h2 * 5 + 0xe6546b64;
        }
        k1 = 0;
        switch(tailLength){
            case 3:
                k1 ^= data[blockCounts * 4 + 2] << 16;
            case 2:
                k1 ^= data[blockCounts * 4 + 1] << 8;
            case 1:
                k1 ^= data[blockCounts * 4];
                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                k1 = k1 << 15 | k1 >>> 17;
                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                if (blockCounts & 1) h1 ^= k1;
                else h2 ^= k1;
        }
        this.h1 = h1;
        this.h2 = h2;
    }
    hexdigest() {
        let h1 = this.h1, h2 = this.h2;
        h1 ^= h2 >>> 1;
        h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
        h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
        h1 ^= h2 >>> 1;
        h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
        h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
        h1 ^= h2 >>> 1;
        return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
    }
}
const SerializableEmpty = Object.freeze({
    map: null,
    hash: "",
    transfer: undefined
});
class AnnotationStorage {
    #modified = false;
    #modifiedIds = null;
    #storage = new Map();
    constructor(){
        this.onSetModified = null;
        this.onResetModified = null;
        this.onAnnotationEditor = null;
    }
    getValue(key, defaultValue) {
        const value = this.#storage.get(key);
        if (value === undefined) return defaultValue;
        return Object.assign(defaultValue, value);
    }
    getRawValue(key) {
        return this.#storage.get(key);
    }
    remove(key) {
        this.#storage.delete(key);
        if (this.#storage.size === 0) this.resetModified();
        if (typeof this.onAnnotationEditor === "function") {
            for (const value of this.#storage.values()){
                if (value instanceof AnnotationEditor) return;
            }
            this.onAnnotationEditor(null);
        }
    }
    setValue(key, value) {
        const obj = this.#storage.get(key);
        let modified = false;
        if (obj !== undefined) {
            for (const [entry, val] of Object.entries(value))if (obj[entry] !== val) {
                modified = true;
                obj[entry] = val;
            }
        } else {
            modified = true;
            this.#storage.set(key, value);
        }
        if (modified) this.#setModified();
        if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === "function") this.onAnnotationEditor(value.constructor._type);
    }
    has(key) {
        return this.#storage.has(key);
    }
    getAll() {
        return this.#storage.size > 0 ? objectFromMap(this.#storage) : null;
    }
    setAll(obj) {
        for (const [key, val] of Object.entries(obj))this.setValue(key, val);
    }
    get size() {
        return this.#storage.size;
    }
    #setModified() {
        if (!this.#modified) {
            this.#modified = true;
            if (typeof this.onSetModified === "function") this.onSetModified();
        }
    }
    resetModified() {
        if (this.#modified) {
            this.#modified = false;
            if (typeof this.onResetModified === "function") this.onResetModified();
        }
    }
    get print() {
        return new PrintAnnotationStorage(this);
    }
    get serializable() {
        if (this.#storage.size === 0) return SerializableEmpty;
        const map = new Map(), hash = new MurmurHash3_64(), transfer = [];
        const context = Object.create(null);
        let hasBitmap = false;
        for (const [key, val] of this.#storage){
            const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;
            if (serialized) {
                map.set(key, serialized);
                hash.update(`${key}:${JSON.stringify(serialized)}`);
                hasBitmap ||= !!serialized.bitmap;
            }
        }
        if (hasBitmap) {
            for (const value of map.values())if (value.bitmap) transfer.push(value.bitmap);
        }
        return map.size > 0 ? {
            map,
            hash: hash.hexdigest(),
            transfer
        } : SerializableEmpty;
    }
    get editorStats() {
        let stats = null;
        const typeToEditor = new Map();
        for (const value of this.#storage.values()){
            if (!(value instanceof AnnotationEditor)) continue;
            const editorStats = value.telemetryFinalData;
            if (!editorStats) continue;
            const { type } = editorStats;
            if (!typeToEditor.has(type)) typeToEditor.set(type, Object.getPrototypeOf(value).constructor);
            stats ||= Object.create(null);
            const map = stats[type] ||= new Map();
            for (const [key, val] of Object.entries(editorStats)){
                if (key === "type") continue;
                let counters = map.get(key);
                if (!counters) {
                    counters = new Map();
                    map.set(key, counters);
                }
                const count = counters.get(val) ?? 0;
                counters.set(val, count + 1);
            }
        }
        for (const [type, editor] of typeToEditor)stats[type] = editor.computeTelemetryFinalData(stats[type]);
        return stats;
    }
    resetModifiedIds() {
        this.#modifiedIds = null;
    }
    get modifiedIds() {
        if (this.#modifiedIds) return this.#modifiedIds;
        const ids = [];
        for (const value of this.#storage.values()){
            if (!(value instanceof AnnotationEditor) || !value.annotationElementId || !value.serialize()) continue;
            ids.push(value.annotationElementId);
        }
        return this.#modifiedIds = {
            ids: new Set(ids),
            hash: ids.join(",")
        };
    }
}
class PrintAnnotationStorage extends AnnotationStorage {
    #serializable;
    constructor(parent){
        super();
        const { map, hash, transfer } = parent.serializable;
        const clone = structuredClone(map, transfer ? {
            transfer
        } : null);
        this.#serializable = {
            map: clone,
            hash,
            transfer
        };
    }
    get print() {
        unreachable("Should not call PrintAnnotationStorage.print");
    }
    get serializable() {
        return this.#serializable;
    }
    get modifiedIds() {
        return shadow(this, "modifiedIds", {
            ids: new Set(),
            hash: ""
        });
    }
}
class FontLoader {
    #systemFonts = new Set();
    constructor({ ownerDocument = globalThis.document, styleElement = null }){
        this._document = ownerDocument;
        this.nativeFontFaces = new Set();
        this.styleElement = null;
        this.loadingRequests = [];
        this.loadTestFontId = 0;
    }
    addNativeFontFace(nativeFontFace) {
        this.nativeFontFaces.add(nativeFontFace);
        this._document.fonts.add(nativeFontFace);
    }
    removeNativeFontFace(nativeFontFace) {
        this.nativeFontFaces.delete(nativeFontFace);
        this._document.fonts.delete(nativeFontFace);
    }
    insertRule(rule) {
        if (!this.styleElement) {
            this.styleElement = this._document.createElement("style");
            this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
        }
        const styleSheet = this.styleElement.sheet;
        styleSheet.insertRule(rule, styleSheet.cssRules.length);
    }
    clear() {
        for (const nativeFontFace of this.nativeFontFaces)this._document.fonts.delete(nativeFontFace);
        this.nativeFontFaces.clear();
        this.#systemFonts.clear();
        if (this.styleElement) {
            this.styleElement.remove();
            this.styleElement = null;
        }
    }
    async loadSystemFont({ systemFontInfo: info, _inspectFont }) {
        if (!info || this.#systemFonts.has(info.loadedName)) return;
        assert(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
        if (this.isFontLoadingAPISupported) {
            const { loadedName, src, style } = info;
            const fontFace = new FontFace(loadedName, src, style);
            this.addNativeFontFace(fontFace);
            try {
                await fontFace.load();
                this.#systemFonts.add(loadedName);
                _inspectFont?.(info);
            } catch  {
                warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);
                this.removeNativeFontFace(fontFace);
            }
            return;
        }
        unreachable("Not implemented: loadSystemFont without the Font Loading API.");
    }
    async bind(font) {
        if (font.attached || font.missingFile && !font.systemFontInfo) return;
        font.attached = true;
        if (font.systemFontInfo) {
            await this.loadSystemFont(font);
            return;
        }
        if (this.isFontLoadingAPISupported) {
            const nativeFontFace = font.createNativeFontFace();
            if (nativeFontFace) {
                this.addNativeFontFace(nativeFontFace);
                try {
                    await nativeFontFace.loaded;
                } catch (ex) {
                    warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                    font.disableFontFace = true;
                    throw ex;
                }
            }
            return;
        }
        const rule = font.createFontFaceRule();
        if (rule) {
            this.insertRule(rule);
            if (this.isSyncFontLoadingSupported) return;
            await new Promise((resolve)=>{
                const request = this._queueLoadingCallback(resolve);
                this._prepareFontLoadEvent(font, request);
            });
        }
    }
    get isFontLoadingAPISupported() {
        const hasFonts = !!this._document?.fonts;
        return shadow(this, "isFontLoadingAPISupported", hasFonts);
    }
    get isSyncFontLoadingSupported() {
        let supported = false;
        if (isNodeJS) supported = true;
        else if (typeof navigator !== "undefined" && typeof navigator?.userAgent === "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) supported = true;
        return shadow(this, "isSyncFontLoadingSupported", supported);
    }
    _queueLoadingCallback(callback) {
        function completeRequest() {
            assert(!request.done, "completeRequest() cannot be called twice.");
            request.done = true;
            while(loadingRequests.length > 0 && loadingRequests[0].done){
                const otherRequest = loadingRequests.shift();
                setTimeout(otherRequest.callback, 0);
            }
        }
        const { loadingRequests } = this;
        const request = {
            done: false,
            complete: completeRequest,
            callback
        };
        loadingRequests.push(request);
        return request;
    }
    get _loadTestFont() {
        const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
        return shadow(this, "_loadTestFont", testFont);
    }
    _prepareFontLoadEvent(font, request) {
        function int32(data, offset) {
            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
        }
        function spliceString(s, offset, remove, insert) {
            const chunk1 = s.substring(0, offset);
            const chunk2 = s.substring(offset + remove);
            return chunk1 + insert + chunk2;
        }
        let i, ii;
        const canvas = this._document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext("2d");
        let called = 0;
        function isFontReady(name, callback) {
            if (++called > 30) {
                warn("Load test font never loaded.");
                callback();
                return;
            }
            ctx.font = "30px " + name;
            ctx.fillText(".", 0, 20);
            const imageData = ctx.getImageData(0, 0, 1, 1);
            if (imageData.data[3] > 0) {
                callback();
                return;
            }
            setTimeout(isFontReady.bind(null, name, callback));
        }
        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
        let data = this._loadTestFont;
        const COMMENT_OFFSET = 976;
        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
        const CFF_CHECKSUM_OFFSET = 16;
        const XXXX_VALUE = 0x58585858;
        let checksum = int32(data, CFF_CHECKSUM_OFFSET);
        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4)checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
        if (i < loadTestFontId.length) checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
        const url = `url(data:font/opentype;base64,${btoa(data)});`;
        const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
        this.insertRule(rule);
        const div = this._document.createElement("div");
        div.style.visibility = "hidden";
        div.style.width = div.style.height = "10px";
        div.style.position = "absolute";
        div.style.top = div.style.left = "0px";
        for (const name of [
            font.loadedName,
            loadTestFontId
        ]){
            const span = this._document.createElement("span");
            span.textContent = "Hi";
            span.style.fontFamily = name;
            div.append(span);
        }
        this._document.body.append(div);
        isFontReady(loadTestFontId, ()=>{
            div.remove();
            request.complete();
        });
    }
}
class FontFaceObject {
    constructor(translatedData, { disableFontFace = false, fontExtraProperties = false, inspectFont = null }){
        this.compiledGlyphs = Object.create(null);
        for(const i in translatedData)this[i] = translatedData[i];
        this.disableFontFace = disableFontFace === true;
        this.fontExtraProperties = fontExtraProperties === true;
        this._inspectFont = inspectFont;
    }
    createNativeFontFace() {
        if (!this.data || this.disableFontFace) return null;
        let nativeFontFace;
        if (!this.cssFontInfo) nativeFontFace = new FontFace(this.loadedName, this.data, {});
        else {
            const css = {
                weight: this.cssFontInfo.fontWeight
            };
            if (this.cssFontInfo.italicAngle) css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
        }
        this._inspectFont?.(this);
        return nativeFontFace;
    }
    createFontFaceRule() {
        if (!this.data || this.disableFontFace) return null;
        const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
        let rule;
        if (!this.cssFontInfo) rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
        else {
            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
            if (this.cssFontInfo.italicAngle) css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
            rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
        }
        this._inspectFont?.(this, url);
        return rule;
    }
    getPathGenerator(objs, character) {
        if (this.compiledGlyphs[character] !== undefined) return this.compiledGlyphs[character];
        const objId = this.loadedName + "_path_" + character;
        let cmds;
        try {
            cmds = objs.get(objId);
        } catch (ex) {
            warn(`getPathGenerator - ignoring character: "${ex}".`);
        }
        const path = new Path2D(cmds || "");
        if (!this.fontExtraProperties) objs.delete(objId);
        return this.compiledGlyphs[character] = path;
    }
}
const CallbackKind = {
    DATA: 1,
    ERROR: 2
};
const StreamKind = {
    CANCEL: 1,
    CANCEL_COMPLETE: 2,
    CLOSE: 3,
    ENQUEUE: 4,
    ERROR: 5,
    PULL: 6,
    PULL_COMPLETE: 7,
    START_COMPLETE: 8
};
function onFn() {}
function wrapReason(ex) {
    if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof MissingPDFException || ex instanceof PasswordException || ex instanceof UnexpectedResponseException || ex instanceof UnknownErrorException) return ex;
    if (!(ex instanceof Error || typeof ex === "object" && ex !== null)) unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
    switch(ex.name){
        case "AbortException":
            return new AbortException(ex.message);
        case "InvalidPDFException":
            return new InvalidPDFException(ex.message);
        case "MissingPDFException":
            return new MissingPDFException(ex.message);
        case "PasswordException":
            return new PasswordException(ex.message, ex.code);
        case "UnexpectedResponseException":
            return new UnexpectedResponseException(ex.message, ex.status);
        case "UnknownErrorException":
            return new UnknownErrorException(ex.message, ex.details);
    }
    return new UnknownErrorException(ex.message, ex.toString());
}
class MessageHandler {
    #messageAC = new AbortController();
    constructor(sourceName, targetName, comObj){
        this.sourceName = sourceName;
        this.targetName = targetName;
        this.comObj = comObj;
        this.callbackId = 1;
        this.streamId = 1;
        this.streamSinks = Object.create(null);
        this.streamControllers = Object.create(null);
        this.callbackCapabilities = Object.create(null);
        this.actionHandler = Object.create(null);
        comObj.addEventListener("message", this.#onMessage.bind(this), {
            signal: this.#messageAC.signal
        });
    }
    #onMessage({ data }) {
        if (data.targetName !== this.sourceName) return;
        if (data.stream) {
            this.#processStreamMessage(data);
            return;
        }
        if (data.callback) {
            const callbackId = data.callbackId;
            const capability = this.callbackCapabilities[callbackId];
            if (!capability) throw new Error(`Cannot resolve callback ${callbackId}`);
            delete this.callbackCapabilities[callbackId];
            if (data.callback === CallbackKind.DATA) capability.resolve(data.data);
            else if (data.callback === CallbackKind.ERROR) capability.reject(wrapReason(data.reason));
            else throw new Error("Unexpected callback case");
            return;
        }
        const action = this.actionHandler[data.action];
        if (!action) throw new Error(`Unknown action from worker: ${data.action}`);
        if (data.callbackId) {
            const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
            Promise.try(action, data.data).then(function(result) {
                comObj.postMessage({
                    sourceName,
                    targetName,
                    callback: CallbackKind.DATA,
                    callbackId: data.callbackId,
                    data: result
                });
            }, function(reason) {
                comObj.postMessage({
                    sourceName,
                    targetName,
                    callback: CallbackKind.ERROR,
                    callbackId: data.callbackId,
                    reason: wrapReason(reason)
                });
            });
            return;
        }
        if (data.streamId) {
            this.#createStreamSink(data);
            return;
        }
        action(data.data);
    }
    on(actionName, handler) {
        const ah = this.actionHandler;
        if (ah[actionName]) throw new Error(`There is already an actionName called "${actionName}"`);
        ah[actionName] = handler;
    }
    send(actionName, data, transfers) {
        this.comObj.postMessage({
            sourceName: this.sourceName,
            targetName: this.targetName,
            action: actionName,
            data
        }, transfers);
    }
    sendWithPromise(actionName, data, transfers) {
        const callbackId = this.callbackId++;
        const capability = Promise.withResolvers();
        this.callbackCapabilities[callbackId] = capability;
        try {
            this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: actionName,
                callbackId,
                data
            }, transfers);
        } catch (ex) {
            capability.reject(ex);
        }
        return capability.promise;
    }
    sendWithStream(actionName, data, queueingStrategy, transfers) {
        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
        return new ReadableStream({
            start: (controller)=>{
                const startCapability = Promise.withResolvers();
                this.streamControllers[streamId] = {
                    controller,
                    startCall: startCapability,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: false
                };
                comObj.postMessage({
                    sourceName,
                    targetName,
                    action: actionName,
                    streamId,
                    data,
                    desiredSize: controller.desiredSize
                }, transfers);
                return startCapability.promise;
            },
            pull: (controller)=>{
                const pullCapability = Promise.withResolvers();
                this.streamControllers[streamId].pullCall = pullCapability;
                comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.PULL,
                    streamId,
                    desiredSize: controller.desiredSize
                });
                return pullCapability.promise;
            },
            cancel: (reason)=>{
                assert(reason instanceof Error, "cancel must have a valid reason");
                const cancelCapability = Promise.withResolvers();
                this.streamControllers[streamId].cancelCall = cancelCapability;
                this.streamControllers[streamId].isClosed = true;
                comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.CANCEL,
                    streamId,
                    reason: wrapReason(reason)
                });
                return cancelCapability.promise;
            }
        }, queueingStrategy);
    }
    #createStreamSink(data) {
        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
        const self = this, action = this.actionHandler[data.action];
        const streamSink = {
            enqueue (chunk, size = 1, transfers) {
                if (this.isCancelled) return;
                const lastDesiredSize = this.desiredSize;
                this.desiredSize -= size;
                if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                    this.sinkCapability = Promise.withResolvers();
                    this.ready = this.sinkCapability.promise;
                }
                comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.ENQUEUE,
                    streamId,
                    chunk
                }, transfers);
            },
            close () {
                if (this.isCancelled) return;
                this.isCancelled = true;
                comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.CLOSE,
                    streamId
                });
                delete self.streamSinks[streamId];
            },
            error (reason) {
                assert(reason instanceof Error, "error must have a valid reason");
                if (this.isCancelled) return;
                this.isCancelled = true;
                comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.ERROR,
                    streamId,
                    reason: wrapReason(reason)
                });
            },
            sinkCapability: Promise.withResolvers(),
            onPull: null,
            onCancel: null,
            isCancelled: false,
            desiredSize: data.desiredSize,
            ready: null
        };
        streamSink.sinkCapability.resolve();
        streamSink.ready = streamSink.sinkCapability.promise;
        this.streamSinks[streamId] = streamSink;
        Promise.try(action, data.data, streamSink).then(function() {
            comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.START_COMPLETE,
                streamId,
                success: true
            });
        }, function(reason) {
            comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.START_COMPLETE,
                streamId,
                reason: wrapReason(reason)
            });
        });
    }
    #processStreamMessage(data) {
        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
        switch(data.stream){
            case StreamKind.START_COMPLETE:
                if (data.success) streamController.startCall.resolve();
                else streamController.startCall.reject(wrapReason(data.reason));
                break;
            case StreamKind.PULL_COMPLETE:
                if (data.success) streamController.pullCall.resolve();
                else streamController.pullCall.reject(wrapReason(data.reason));
                break;
            case StreamKind.PULL:
                if (!streamSink) {
                    comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                    });
                    break;
                }
                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) streamSink.sinkCapability.resolve();
                streamSink.desiredSize = data.desiredSize;
                Promise.try(streamSink.onPull || onFn).then(function() {
                    comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                    });
                }, function(reason) {
                    comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                    });
                });
                break;
            case StreamKind.ENQUEUE:
                assert(streamController, "enqueue should have stream controller");
                if (streamController.isClosed) break;
                streamController.controller.enqueue(data.chunk);
                break;
            case StreamKind.CLOSE:
                assert(streamController, "close should have stream controller");
                if (streamController.isClosed) break;
                streamController.isClosed = true;
                streamController.controller.close();
                this.#deleteStreamController(streamController, streamId);
                break;
            case StreamKind.ERROR:
                assert(streamController, "error should have stream controller");
                streamController.controller.error(wrapReason(data.reason));
                this.#deleteStreamController(streamController, streamId);
                break;
            case StreamKind.CANCEL_COMPLETE:
                if (data.success) streamController.cancelCall.resolve();
                else streamController.cancelCall.reject(wrapReason(data.reason));
                this.#deleteStreamController(streamController, streamId);
                break;
            case StreamKind.CANCEL:
                if (!streamSink) break;
                const dataReason = wrapReason(data.reason);
                Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {
                    comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        success: true
                    });
                }, function(reason) {
                    comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                    });
                });
                streamSink.sinkCapability.reject(dataReason);
                streamSink.isCancelled = true;
                delete this.streamSinks[streamId];
                break;
            default:
                throw new Error("Unexpected stream case");
        }
    }
    async #deleteStreamController(streamController, streamId) {
        await Promise.allSettled([
            streamController.startCall?.promise,
            streamController.pullCall?.promise,
            streamController.cancelCall?.promise
        ]);
        delete this.streamControllers[streamId];
    }
    destroy() {
        this.#messageAC?.abort();
        this.#messageAC = null;
    }
}
class BaseCanvasFactory {
    #enableHWA = false;
    constructor({ enableHWA = false }){
        this.#enableHWA = enableHWA;
    }
    create(width, height) {
        if (width <= 0 || height <= 0) throw new Error("Invalid canvas size");
        const canvas = this._createCanvas(width, height);
        return {
            canvas,
            context: canvas.getContext("2d", {
                willReadFrequently: !this.#enableHWA
            })
        };
    }
    reset(canvasAndContext, width, height) {
        if (!canvasAndContext.canvas) throw new Error("Canvas is not specified");
        if (width <= 0 || height <= 0) throw new Error("Invalid canvas size");
        canvasAndContext.canvas.width = width;
        canvasAndContext.canvas.height = height;
    }
    destroy(canvasAndContext) {
        if (!canvasAndContext.canvas) throw new Error("Canvas is not specified");
        canvasAndContext.canvas.width = 0;
        canvasAndContext.canvas.height = 0;
        canvasAndContext.canvas = null;
        canvasAndContext.context = null;
    }
    _createCanvas(width, height) {
        unreachable("Abstract method `_createCanvas` called.");
    }
}
class DOMCanvasFactory extends BaseCanvasFactory {
    constructor({ ownerDocument = globalThis.document, enableHWA = false }){
        super({
            enableHWA
        });
        this._document = ownerDocument;
    }
    _createCanvas(width, height) {
        const canvas = this._document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
    }
}
class BaseCMapReaderFactory {
    constructor({ baseUrl = null, isCompressed = true }){
        this.baseUrl = baseUrl;
        this.isCompressed = isCompressed;
    }
    async fetch({ name }) {
        if (!this.baseUrl) throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
        if (!name) throw new Error("CMap name must be specified.");
        const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
        return this._fetch(url).then((cMapData)=>({
                cMapData,
                isCompressed: this.isCompressed
            })).catch((reason)=>{
            throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
        });
    }
    async _fetch(url) {
        unreachable("Abstract method `_fetch` called.");
    }
}
class DOMCMapReaderFactory extends BaseCMapReaderFactory {
    async _fetch(url) {
        const data = await fetchData(url, this.isCompressed ? "arraybuffer" : "text");
        return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);
    }
}
class BaseFilterFactory {
    addFilter(maps) {
        return "none";
    }
    addHCMFilter(fgColor, bgColor) {
        return "none";
    }
    addAlphaFilter(map) {
        return "none";
    }
    addLuminosityFilter(map) {
        return "none";
    }
    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
        return "none";
    }
    destroy(keepHCM = false) {}
}
class DOMFilterFactory extends BaseFilterFactory {
    #baseUrl;
    #_cache;
    #_defs;
    #docId;
    #document;
    #_hcmCache;
    #id = 0;
    constructor({ docId, ownerDocument = globalThis.document }){
        super();
        this.#docId = docId;
        this.#document = ownerDocument;
    }
    get #cache() {
        return this.#_cache ||= new Map();
    }
    get #hcmCache() {
        return this.#_hcmCache ||= new Map();
    }
    get #defs() {
        if (!this.#_defs) {
            const div = this.#document.createElement("div");
            const { style } = div;
            style.visibility = "hidden";
            style.contain = "strict";
            style.width = style.height = 0;
            style.position = "absolute";
            style.top = style.left = 0;
            style.zIndex = -1;
            const svg = this.#document.createElementNS(SVG_NS, "svg");
            svg.setAttribute("width", 0);
            svg.setAttribute("height", 0);
            this.#_defs = this.#document.createElementNS(SVG_NS, "defs");
            div.append(svg);
            svg.append(this.#_defs);
            this.#document.body.append(div);
        }
        return this.#_defs;
    }
    #createTables(maps) {
        if (maps.length === 1) {
            const mapR = maps[0];
            const buffer = new Array(256);
            for(let i = 0; i < 256; i++)buffer[i] = mapR[i] / 255;
            const table = buffer.join(",");
            return [
                table,
                table,
                table
            ];
        }
        const [mapR, mapG, mapB] = maps;
        const bufferR = new Array(256);
        const bufferG = new Array(256);
        const bufferB = new Array(256);
        for(let i = 0; i < 256; i++){
            bufferR[i] = mapR[i] / 255;
            bufferG[i] = mapG[i] / 255;
            bufferB[i] = mapB[i] / 255;
        }
        return [
            bufferR.join(","),
            bufferG.join(","),
            bufferB.join(",")
        ];
    }
    #createUrl(id) {
        if (this.#baseUrl === undefined) {
            this.#baseUrl = "";
            const url = this.#document.URL;
            if (url !== this.#document.baseURI) {
                if (isDataScheme(url)) warn('#createUrl: ignore "data:"-URL for performance reasons.');
                else this.#baseUrl = url.split("#", 1)[0];
            }
        }
        return `url(${this.#baseUrl}#${id})`;
    }
    addFilter(maps) {
        if (!maps) return "none";
        let value = this.#cache.get(maps);
        if (value) return value;
        const [tableR, tableG, tableB] = this.#createTables(maps);
        const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;
        value = this.#cache.get(key);
        if (value) {
            this.#cache.set(maps, value);
            return value;
        }
        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;
        const url = this.#createUrl(id);
        this.#cache.set(maps, url);
        this.#cache.set(key, url);
        const filter = this.#createFilter(id);
        this.#addTransferMapConversion(tableR, tableG, tableB, filter);
        return url;
    }
    addHCMFilter(fgColor, bgColor) {
        const key = `${fgColor}-${bgColor}`;
        const filterName = "base";
        let info = this.#hcmCache.get(filterName);
        if (info?.key === key) return info.url;
        if (info) {
            info.filter?.remove();
            info.key = key;
            info.url = "none";
            info.filter = null;
        } else {
            info = {
                key,
                url: "none",
                filter: null
            };
            this.#hcmCache.set(filterName, info);
        }
        if (!fgColor || !bgColor) return info.url;
        const fgRGB = this.#getRGB(fgColor);
        fgColor = Util.makeHexColor(...fgRGB);
        const bgRGB = this.#getRGB(bgColor);
        bgColor = Util.makeHexColor(...bgRGB);
        this.#defs.style.color = "";
        if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) return info.url;
        const map = new Array(256);
        for(let i = 0; i <= 255; i++){
            const x = i / 255;
            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
        }
        const table = map.join(",");
        const id = `g_${this.#docId}_hcm_filter`;
        const filter = info.filter = this.#createFilter(id);
        this.#addTransferMapConversion(table, table, table, filter);
        this.#addGrayConversion(filter);
        const getSteps = (c, n)=>{
            const start = fgRGB[c] / 255;
            const end = bgRGB[c] / 255;
            const arr = new Array(n + 1);
            for(let i = 0; i <= n; i++)arr[i] = start + i / n * (end - start);
            return arr.join(",");
        };
        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
        info.url = this.#createUrl(id);
        return info.url;
    }
    addAlphaFilter(map) {
        let value = this.#cache.get(map);
        if (value) return value;
        const [tableA] = this.#createTables([
            map
        ]);
        const key = `alpha_${tableA}`;
        value = this.#cache.get(key);
        if (value) {
            this.#cache.set(map, value);
            return value;
        }
        const id = `g_${this.#docId}_alpha_map_${this.#id++}`;
        const url = this.#createUrl(id);
        this.#cache.set(map, url);
        this.#cache.set(key, url);
        const filter = this.#createFilter(id);
        this.#addTransferMapAlphaConversion(tableA, filter);
        return url;
    }
    addLuminosityFilter(map) {
        let value = this.#cache.get(map || "luminosity");
        if (value) return value;
        let tableA, key;
        if (map) {
            [tableA] = this.#createTables([
                map
            ]);
            key = `luminosity_${tableA}`;
        } else key = "luminosity";
        value = this.#cache.get(key);
        if (value) {
            this.#cache.set(map, value);
            return value;
        }
        const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;
        const url = this.#createUrl(id);
        this.#cache.set(map, url);
        this.#cache.set(key, url);
        const filter = this.#createFilter(id);
        this.#addLuminosityConversion(filter);
        if (map) this.#addTransferMapAlphaConversion(tableA, filter);
        return url;
    }
    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
        let info = this.#hcmCache.get(filterName);
        if (info?.key === key) return info.url;
        if (info) {
            info.filter?.remove();
            info.key = key;
            info.url = "none";
            info.filter = null;
        } else {
            info = {
                key,
                url: "none",
                filter: null
            };
            this.#hcmCache.set(filterName, info);
        }
        if (!fgColor || !bgColor) return info.url;
        const [fgRGB, bgRGB] = [
            fgColor,
            bgColor
        ].map(this.#getRGB.bind(this));
        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
        let [newFgRGB, newBgRGB] = [
            newFgColor,
            newBgColor
        ].map(this.#getRGB.bind(this));
        if (bgGray < fgGray) [fgGray, bgGray, newFgRGB, newBgRGB] = [
            bgGray,
            fgGray,
            newBgRGB,
            newFgRGB
        ];
        this.#defs.style.color = "";
        const getSteps = (fg, bg, n)=>{
            const arr = new Array(256);
            const step = (bgGray - fgGray) / n;
            const newStart = fg / 255;
            const newStep = (bg - fg) / (255 * n);
            let prev = 0;
            for(let i = 0; i <= n; i++){
                const k = Math.round(fgGray + i * step);
                const value = newStart + i * newStep;
                for(let j = prev; j <= k; j++)arr[j] = value;
                prev = k + 1;
            }
            for(let i = prev; i < 256; i++)arr[i] = arr[prev - 1];
            return arr.join(",");
        };
        const id = `g_${this.#docId}_hcm_${filterName}_filter`;
        const filter = info.filter = this.#createFilter(id);
        this.#addGrayConversion(filter);
        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
        info.url = this.#createUrl(id);
        return info.url;
    }
    destroy(keepHCM = false) {
        if (keepHCM && this.#_hcmCache?.size) return;
        this.#_defs?.parentNode.parentNode.remove();
        this.#_defs = null;
        this.#_cache?.clear();
        this.#_cache = null;
        this.#_hcmCache?.clear();
        this.#_hcmCache = null;
        this.#id = 0;
    }
    #addLuminosityConversion(filter) {
        const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
        filter.append(feColorMatrix);
    }
    #addGrayConversion(filter) {
        const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
        filter.append(feColorMatrix);
    }
    #createFilter(id) {
        const filter = this.#document.createElementNS(SVG_NS, "filter");
        filter.setAttribute("color-interpolation-filters", "sRGB");
        filter.setAttribute("id", id);
        this.#defs.append(filter);
        return filter;
    }
    #appendFeFunc(feComponentTransfer, func, table) {
        const feFunc = this.#document.createElementNS(SVG_NS, func);
        feFunc.setAttribute("type", "discrete");
        feFunc.setAttribute("tableValues", table);
        feComponentTransfer.append(feFunc);
    }
    #addTransferMapConversion(rTable, gTable, bTable, filter) {
        const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
        filter.append(feComponentTransfer);
        this.#appendFeFunc(feComponentTransfer, "feFuncR", rTable);
        this.#appendFeFunc(feComponentTransfer, "feFuncG", gTable);
        this.#appendFeFunc(feComponentTransfer, "feFuncB", bTable);
    }
    #addTransferMapAlphaConversion(aTable, filter) {
        const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
        filter.append(feComponentTransfer);
        this.#appendFeFunc(feComponentTransfer, "feFuncA", aTable);
    }
    #getRGB(color) {
        this.#defs.style.color = color;
        return getRGB(getComputedStyle(this.#defs).getPropertyValue("color"));
    }
}
class BaseStandardFontDataFactory {
    constructor({ baseUrl = null }){
        this.baseUrl = baseUrl;
    }
    async fetch({ filename }) {
        if (!this.baseUrl) throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
        if (!filename) throw new Error("Font filename must be specified.");
        const url = `${this.baseUrl}${filename}`;
        return this._fetch(url).catch((reason)=>{
            throw new Error(`Unable to load font data at: ${url}`);
        });
    }
    async _fetch(url) {
        unreachable("Abstract method `_fetch` called.");
    }
}
class DOMStandardFontDataFactory extends BaseStandardFontDataFactory {
    async _fetch(url) {
        const data = await fetchData(url, "arraybuffer");
        return new Uint8Array(data);
    }
}
if (isNodeJS) warn("Please use the `legacy` build in Node.js environments.");
async function node_utils_fetchData(url) {
    const fs = process.getBuiltinModule("fs");
    const data = await fs.promises.readFile(url);
    return new Uint8Array(data);
}
class NodeFilterFactory extends BaseFilterFactory {
}
class NodeCanvasFactory extends BaseCanvasFactory {
    _createCanvas(width, height) {
        const require1 = process.getBuiltinModule("module").createRequire("file:///node_modules/pdfjs-dist/build/pdf.mjs");
        const canvas = require1("@napi-rs/canvas");
        return canvas.createCanvas(width, height);
    }
}
class NodeCMapReaderFactory extends BaseCMapReaderFactory {
    async _fetch(url) {
        return node_utils_fetchData(url);
    }
}
class NodeStandardFontDataFactory extends BaseStandardFontDataFactory {
    async _fetch(url) {
        return node_utils_fetchData(url);
    }
}
const PathType = {
    FILL: "Fill",
    STROKE: "Stroke",
    SHADING: "Shading"
};
function applyBoundingBox(ctx, bbox) {
    if (!bbox) return;
    const width = bbox[2] - bbox[0];
    const height = bbox[3] - bbox[1];
    const region = new Path2D();
    region.rect(bbox[0], bbox[1], width, height);
    ctx.clip(region);
}
class BaseShadingPattern {
    getPattern() {
        unreachable("Abstract method `getPattern` called.");
    }
}
class RadialAxialShadingPattern extends BaseShadingPattern {
    constructor(IR){
        super();
        this._type = IR[1];
        this._bbox = IR[2];
        this._colorStops = IR[3];
        this._p0 = IR[4];
        this._p1 = IR[5];
        this._r0 = IR[6];
        this._r1 = IR[7];
        this.matrix = null;
    }
    _createGradient(ctx) {
        let grad;
        if (this._type === "axial") grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
        else if (this._type === "radial") grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
        for (const colorStop of this._colorStops)grad.addColorStop(colorStop[0], colorStop[1]);
        return grad;
    }
    getPattern(ctx, owner, inverse, pathType) {
        let pattern;
        if (pathType === PathType.STROKE || pathType === PathType.FILL) {
            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [
                0,
                0,
                0,
                0
            ];
            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
            const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height);
            const tmpCtx = tmpCanvas.context;
            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
            tmpCtx.beginPath();
            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
            inverse = Util.transform(inverse, [
                1,
                0,
                0,
                1,
                ownerBBox[0],
                ownerBBox[1]
            ]);
            tmpCtx.transform(...owner.baseTransform);
            if (this.matrix) tmpCtx.transform(...this.matrix);
            applyBoundingBox(tmpCtx, this._bbox);
            tmpCtx.fillStyle = this._createGradient(tmpCtx);
            tmpCtx.fill();
            pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
            const domMatrix = new DOMMatrix(inverse);
            pattern.setTransform(domMatrix);
        } else {
            applyBoundingBox(ctx, this._bbox);
            pattern = this._createGradient(ctx);
        }
        return pattern;
    }
}
function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
    const coords = context.coords, colors = context.colors;
    const bytes = data.data, rowSize = data.width * 4;
    let tmp;
    if (coords[p1 + 1] > coords[p2 + 1]) {
        tmp = p1;
        p1 = p2;
        p2 = tmp;
        tmp = c1;
        c1 = c2;
        c2 = tmp;
    }
    if (coords[p2 + 1] > coords[p3 + 1]) {
        tmp = p2;
        p2 = p3;
        p3 = tmp;
        tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    if (coords[p1 + 1] > coords[p2 + 1]) {
        tmp = p1;
        p1 = p2;
        p2 = tmp;
        tmp = c1;
        c1 = c2;
        c2 = tmp;
    }
    const x1 = (coords[p1] + context.offsetX) * context.scaleX;
    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
    const x2 = (coords[p2] + context.offsetX) * context.scaleX;
    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
    const x3 = (coords[p3] + context.offsetX) * context.scaleX;
    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
    if (y1 >= y3) return;
    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
    const minY = Math.round(y1), maxY = Math.round(y3);
    let xa, car, cag, cab;
    let xb, cbr, cbg, cbb;
    for(let y = minY; y <= maxY; y++){
        if (y < y2) {
            const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);
            xa = x1 - (x1 - x2) * k;
            car = c1r - (c1r - c2r) * k;
            cag = c1g - (c1g - c2g) * k;
            cab = c1b - (c1b - c2b) * k;
        } else {
            let k;
            if (y > y3) k = 1;
            else if (y2 === y3) k = 0;
            else k = (y2 - y) / (y2 - y3);
            xa = x2 - (x2 - x3) * k;
            car = c2r - (c2r - c3r) * k;
            cag = c2g - (c2g - c3g) * k;
            cab = c2b - (c2b - c3b) * k;
        }
        let k;
        if (y < y1) k = 0;
        else if (y > y3) k = 1;
        else k = (y1 - y) / (y1 - y3);
        xb = x1 - (x1 - x3) * k;
        cbr = c1r - (c1r - c3r) * k;
        cbg = c1g - (c1g - c3g) * k;
        cbb = c1b - (c1b - c3b) * k;
        const x1_ = Math.round(Math.min(xa, xb));
        const x2_ = Math.round(Math.max(xa, xb));
        let j = rowSize * y + x1_ * 4;
        for(let x = x1_; x <= x2_; x++){
            k = (xa - x) / (xa - xb);
            if (k < 0) k = 0;
            else if (k > 1) k = 1;
            bytes[j++] = car - (car - cbr) * k | 0;
            bytes[j++] = cag - (cag - cbg) * k | 0;
            bytes[j++] = cab - (cab - cbb) * k | 0;
            bytes[j++] = 255;
        }
    }
}
function drawFigure(data, figure, context) {
    const ps = figure.coords;
    const cs = figure.colors;
    let i, ii;
    switch(figure.type){
        case "lattice":
            const verticesPerRow = figure.verticesPerRow;
            const rows = Math.floor(ps.length / verticesPerRow) - 1;
            const cols = verticesPerRow - 1;
            for(i = 0; i < rows; i++){
                let q = i * verticesPerRow;
                for(let j = 0; j < cols; j++, q++){
                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                }
            }
            break;
        case "triangles":
            for(i = 0, ii = ps.length; i < ii; i += 3)drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
            break;
        default:
            throw new Error("illegal figure");
    }
}
class MeshShadingPattern extends BaseShadingPattern {
    constructor(IR){
        super();
        this._coords = IR[2];
        this._colors = IR[3];
        this._figures = IR[4];
        this._bounds = IR[5];
        this._bbox = IR[7];
        this._background = IR[8];
        this.matrix = null;
    }
    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
        const EXPECTED_SCALE = 1.1;
        const MAX_PATTERN_SIZE = 3000;
        const BORDER_SIZE = 2;
        const offsetX = Math.floor(this._bounds[0]);
        const offsetY = Math.floor(this._bounds[1]);
        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
        const scaleX = boundsWidth / width;
        const scaleY = boundsHeight / height;
        const context = {
            coords: this._coords,
            colors: this._colors,
            offsetX: -offsetX,
            offsetY: -offsetY,
            scaleX: 1 / scaleX,
            scaleY: 1 / scaleY
        };
        const paddedWidth = width + BORDER_SIZE * 2;
        const paddedHeight = height + BORDER_SIZE * 2;
        const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight);
        const tmpCtx = tmpCanvas.context;
        const data = tmpCtx.createImageData(width, height);
        if (backgroundColor) {
            const bytes = data.data;
            for(let i = 0, ii = bytes.length; i < ii; i += 4){
                bytes[i] = backgroundColor[0];
                bytes[i + 1] = backgroundColor[1];
                bytes[i + 2] = backgroundColor[2];
                bytes[i + 3] = 255;
            }
        }
        for (const figure of this._figures)drawFigure(data, figure, context);
        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
        const canvas = tmpCanvas.canvas;
        return {
            canvas,
            offsetX: offsetX - BORDER_SIZE * scaleX,
            offsetY: offsetY - BORDER_SIZE * scaleY,
            scaleX,
            scaleY
        };
    }
    getPattern(ctx, owner, inverse, pathType) {
        applyBoundingBox(ctx, this._bbox);
        let scale;
        if (pathType === PathType.SHADING) scale = Util.singularValueDecompose2dScale(getCurrentTransform(ctx));
        else {
            scale = Util.singularValueDecompose2dScale(owner.baseTransform);
            if (this.matrix) {
                const matrixScale = Util.singularValueDecompose2dScale(this.matrix);
                scale = [
                    scale[0] * matrixScale[0],
                    scale[1] * matrixScale[1]
                ];
            }
        }
        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
        if (pathType !== PathType.SHADING) {
            ctx.setTransform(...owner.baseTransform);
            if (this.matrix) ctx.transform(...this.matrix);
        }
        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
        return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
    }
}
class DummyShadingPattern extends BaseShadingPattern {
    getPattern() {
        return "hotpink";
    }
}
function getShadingPattern(IR) {
    switch(IR[0]){
        case "RadialAxial":
            return new RadialAxialShadingPattern(IR);
        case "Mesh":
            return new MeshShadingPattern(IR);
        case "Dummy":
            return new DummyShadingPattern();
    }
    throw new Error(`Unknown IR type: ${IR[0]}`);
}
const PaintType = {
    COLORED: 1,
    UNCOLORED: 2
};
class TilingPattern {
    static MAX_PATTERN_SIZE = 3000;
    constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform){
        this.operatorList = IR[2];
        this.matrix = IR[3];
        this.bbox = IR[4];
        this.xstep = IR[5];
        this.ystep = IR[6];
        this.paintType = IR[7];
        this.tilingType = IR[8];
        this.color = color;
        this.ctx = ctx;
        this.canvasGraphicsFactory = canvasGraphicsFactory;
        this.baseTransform = baseTransform;
    }
    createPatternCanvas(owner) {
        const { bbox, operatorList, paintType, tilingType, color, canvasGraphicsFactory } = this;
        let { xstep, ystep } = this;
        xstep = Math.abs(xstep);
        ystep = Math.abs(ystep);
        info("TilingType: " + tilingType);
        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
        const width = x1 - x0;
        const height = y1 - y0;
        const matrixScale = Util.singularValueDecompose2dScale(this.matrix);
        const curMatrixScale = Util.singularValueDecompose2dScale(this.baseTransform);
        const combinedScaleX = matrixScale[0] * curMatrixScale[0];
        const combinedScaleY = matrixScale[1] * curMatrixScale[1];
        let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;
        const xScaledStep = Math.ceil(xstep * combinedScaleX);
        const yScaledStep = Math.ceil(ystep * combinedScaleY);
        const xScaledWidth = Math.ceil(width * combinedScaleX);
        const yScaledHeight = Math.ceil(height * combinedScaleY);
        if (xScaledStep >= xScaledWidth) canvasWidth = xstep;
        else redrawHorizontally = true;
        if (yScaledStep >= yScaledHeight) canvasHeight = ystep;
        else redrawVertically = true;
        const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
        const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
        const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size);
        const tmpCtx = tmpCanvas.context;
        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
        graphics.groupLevel = owner.groupLevel;
        this.setFillAndStrokeStyleToContext(graphics, paintType, color);
        tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);
        graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
        tmpCtx.save();
        this.clipBbox(graphics, x0, y0, x1, y1);
        graphics.baseTransform = getCurrentTransform(graphics.ctx);
        graphics.executeOperatorList(operatorList);
        graphics.endDrawing();
        tmpCtx.restore();
        if (redrawHorizontally || redrawVertically) {
            const image = tmpCanvas.canvas;
            if (redrawHorizontally) canvasWidth = xstep;
            if (redrawVertically) canvasHeight = ystep;
            const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
            const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
            const xSize = dimx2.size;
            const ySize = dimy2.size;
            const tmpCanvas2 = owner.cachedCanvases.getCanvas("pattern-workaround", xSize, ySize);
            const tmpCtx2 = tmpCanvas2.context;
            const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;
            const jj = redrawVertically ? Math.floor(height / ystep) : 0;
            for(let i = 0; i <= ii; i++)for(let j = 0; j <= jj; j++)tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);
            return {
                canvas: tmpCanvas2.canvas,
                scaleX: dimx2.scale,
                scaleY: dimy2.scale,
                offsetX: x0,
                offsetY: y0
            };
        }
        return {
            canvas: tmpCanvas.canvas,
            scaleX: dimx.scale,
            scaleY: dimy.scale,
            offsetX: x0,
            offsetY: y0
        };
    }
    getSizeAndScale(step, realOutputSize, scale) {
        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
        let size = Math.ceil(step * scale);
        if (size >= maxSize) size = maxSize;
        else scale = size / step;
        return {
            scale,
            size
        };
    }
    clipBbox(graphics, x0, y0, x1, y1) {
        const bboxWidth = x1 - x0;
        const bboxHeight = y1 - y0;
        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
        graphics.current.updateRectMinMax(getCurrentTransform(graphics.ctx), [
            x0,
            y0,
            x1,
            y1
        ]);
        graphics.clip();
        graphics.endPath();
    }
    setFillAndStrokeStyleToContext(graphics, paintType, color) {
        const context = graphics.ctx, current = graphics.current;
        switch(paintType){
            case PaintType.COLORED:
                const ctx = this.ctx;
                context.fillStyle = ctx.fillStyle;
                context.strokeStyle = ctx.strokeStyle;
                current.fillColor = ctx.fillStyle;
                current.strokeColor = ctx.strokeStyle;
                break;
            case PaintType.UNCOLORED:
                const cssColor = Util.makeHexColor(color[0], color[1], color[2]);
                context.fillStyle = cssColor;
                context.strokeStyle = cssColor;
                current.fillColor = cssColor;
                current.strokeColor = cssColor;
                break;
            default:
                throw new FormatError(`Unsupported paint type: ${paintType}`);
        }
    }
    getPattern(ctx, owner, inverse, pathType) {
        let matrix = inverse;
        if (pathType !== PathType.SHADING) {
            matrix = Util.transform(matrix, owner.baseTransform);
            if (this.matrix) matrix = Util.transform(matrix, this.matrix);
        }
        const temporaryPatternCanvas = this.createPatternCanvas(owner);
        let domMatrix = new DOMMatrix(matrix);
        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
        pattern.setTransform(domMatrix);
        return pattern;
    }
}
function convertToRGBA(params) {
    switch(params.kind){
        case ImageKind.GRAYSCALE_1BPP:
            return convertBlackAndWhiteToRGBA(params);
        case ImageKind.RGB_24BPP:
            return convertRGBToRGBA(params);
    }
    return null;
}
function convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {
    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
    const [zeroMapping, oneMapping] = inverseDecode ? [
        nonBlackColor,
        black
    ] : [
        black,
        nonBlackColor
    ];
    const widthInSource = width >> 3;
    const widthRemainder = width & 7;
    const srcLength = src.length;
    dest = new Uint32Array(dest.buffer);
    let destPos = 0;
    for(let i = 0; i < height; i++){
        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){
            const elem = srcPos < srcLength ? src[srcPos] : 255;
            dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;
        }
        if (widthRemainder === 0) continue;
        const elem = srcPos < srcLength ? src[srcPos++] : 255;
        for(let j = 0; j < widthRemainder; j++)dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
    return {
        srcPos,
        destPos
    };
}
function convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {
    let i = 0;
    const len = width * height * 3;
    const len32 = len >> 2;
    const src32 = new Uint32Array(src.buffer, srcPos, len32);
    if (FeatureTest.isLittleEndian) {
        for(; i < len32 - 2; i += 3, destPos += 4){
            const s1 = src32[i];
            const s2 = src32[i + 1];
            const s3 = src32[i + 2];
            dest[destPos] = s1 | 0xff000000;
            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;
            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;
            dest[destPos + 3] = s3 >>> 8 | 0xff000000;
        }
        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3)dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;
    } else {
        for(; i < len32 - 2; i += 3, destPos += 4){
            const s1 = src32[i];
            const s2 = src32[i + 1];
            const s3 = src32[i + 2];
            dest[destPos] = s1 | 0xff;
            dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;
            dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;
            dest[destPos + 3] = s3 << 8 | 0xff;
        }
        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3)dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;
    }
    return {
        srcPos: srcPos + len,
        destPos
    };
}
function grayToRGBA(src, dest) {
    if (FeatureTest.isLittleEndian) for(let i = 0, ii = src.length; i < ii; i++)dest[i] = src[i] * 0x10101 | 0xff000000;
    else for(let i = 0, ii = src.length; i < ii; i++)dest[i] = src[i] * 0x1010100 | 0x000000ff;
}
const MIN_FONT_SIZE = 16;
const MAX_FONT_SIZE = 100;
const EXECUTION_TIME = 15;
const EXECUTION_STEPS = 10;
const MAX_SIZE_TO_COMPILE = 1000;
const FULL_CHUNK_HEIGHT = 16;
function mirrorContextOperations(ctx, destCtx) {
    if (ctx._removeMirroring) throw new Error("Context is already forwarding operations.");
    ctx.__originalSave = ctx.save;
    ctx.__originalRestore = ctx.restore;
    ctx.__originalRotate = ctx.rotate;
    ctx.__originalScale = ctx.scale;
    ctx.__originalTranslate = ctx.translate;
    ctx.__originalTransform = ctx.transform;
    ctx.__originalSetTransform = ctx.setTransform;
    ctx.__originalResetTransform = ctx.resetTransform;
    ctx.__originalClip = ctx.clip;
    ctx.__originalMoveTo = ctx.moveTo;
    ctx.__originalLineTo = ctx.lineTo;
    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
    ctx.__originalRect = ctx.rect;
    ctx.__originalClosePath = ctx.closePath;
    ctx.__originalBeginPath = ctx.beginPath;
    ctx._removeMirroring = ()=>{
        ctx.save = ctx.__originalSave;
        ctx.restore = ctx.__originalRestore;
        ctx.rotate = ctx.__originalRotate;
        ctx.scale = ctx.__originalScale;
        ctx.translate = ctx.__originalTranslate;
        ctx.transform = ctx.__originalTransform;
        ctx.setTransform = ctx.__originalSetTransform;
        ctx.resetTransform = ctx.__originalResetTransform;
        ctx.clip = ctx.__originalClip;
        ctx.moveTo = ctx.__originalMoveTo;
        ctx.lineTo = ctx.__originalLineTo;
        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
        ctx.rect = ctx.__originalRect;
        ctx.closePath = ctx.__originalClosePath;
        ctx.beginPath = ctx.__originalBeginPath;
        delete ctx._removeMirroring;
    };
    ctx.save = function ctxSave() {
        destCtx.save();
        this.__originalSave();
    };
    ctx.restore = function ctxRestore() {
        destCtx.restore();
        this.__originalRestore();
    };
    ctx.translate = function ctxTranslate(x, y) {
        destCtx.translate(x, y);
        this.__originalTranslate(x, y);
    };
    ctx.scale = function ctxScale(x, y) {
        destCtx.scale(x, y);
        this.__originalScale(x, y);
    };
    ctx.transform = function ctxTransform(a, b, c, d, e, f) {
        destCtx.transform(a, b, c, d, e, f);
        this.__originalTransform(a, b, c, d, e, f);
    };
    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
        destCtx.setTransform(a, b, c, d, e, f);
        this.__originalSetTransform(a, b, c, d, e, f);
    };
    ctx.resetTransform = function ctxResetTransform() {
        destCtx.resetTransform();
        this.__originalResetTransform();
    };
    ctx.rotate = function ctxRotate(angle) {
        destCtx.rotate(angle);
        this.__originalRotate(angle);
    };
    ctx.clip = function ctxRotate(rule) {
        destCtx.clip(rule);
        this.__originalClip(rule);
    };
    ctx.moveTo = function(x, y) {
        destCtx.moveTo(x, y);
        this.__originalMoveTo(x, y);
    };
    ctx.lineTo = function(x, y) {
        destCtx.lineTo(x, y);
        this.__originalLineTo(x, y);
    };
    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    };
    ctx.rect = function(x, y, width, height) {
        destCtx.rect(x, y, width, height);
        this.__originalRect(x, y, width, height);
    };
    ctx.closePath = function() {
        destCtx.closePath();
        this.__originalClosePath();
    };
    ctx.beginPath = function() {
        destCtx.beginPath();
        this.__originalBeginPath();
    };
}
class CachedCanvases {
    constructor(canvasFactory){
        this.canvasFactory = canvasFactory;
        this.cache = Object.create(null);
    }
    getCanvas(id, width, height) {
        let canvasEntry;
        if (this.cache[id] !== undefined) {
            canvasEntry = this.cache[id];
            this.canvasFactory.reset(canvasEntry, width, height);
        } else {
            canvasEntry = this.canvasFactory.create(width, height);
            this.cache[id] = canvasEntry;
        }
        return canvasEntry;
    }
    delete(id) {
        delete this.cache[id];
    }
    clear() {
        for(const id in this.cache){
            const canvasEntry = this.cache[id];
            this.canvasFactory.destroy(canvasEntry);
            delete this.cache[id];
        }
    }
}
function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
    const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
    if (b === 0 && c === 0) {
        const tlX = destX * a + tx;
        const rTlX = Math.round(tlX);
        const tlY = destY * d + ty;
        const rTlY = Math.round(tlY);
        const brX = (destX + destW) * a + tx;
        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
        const brY = (destY + destH) * d + ty;
        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
        ctx.setTransform(a, b, c, d, tx, ty);
        return [
            rWidth,
            rHeight
        ];
    }
    if (a === 0 && d === 0) {
        const tlX = destY * c + tx;
        const rTlX = Math.round(tlX);
        const tlY = destX * b + ty;
        const rTlY = Math.round(tlY);
        const brX = (destY + destH) * c + tx;
        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
        const brY = (destX + destW) * b + ty;
        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
        ctx.setTransform(a, b, c, d, tx, ty);
        return [
            rHeight,
            rWidth
        ];
    }
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
    const scaleX = Math.hypot(a, b);
    const scaleY = Math.hypot(c, d);
    return [
        scaleX * destW,
        scaleY * destH
    ];
}
function compileType3Glyph(imgData) {
    const { width, height } = imgData;
    if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) return null;
    const POINT_TO_PROCESS_LIMIT = 1000;
    const POINT_TYPES = new Uint8Array([
        0,
        2,
        4,
        0,
        1,
        0,
        5,
        4,
        8,
        10,
        0,
        8,
        0,
        2,
        1,
        0
    ]);
    const width1 = width + 1;
    let points = new Uint8Array(width1 * (height + 1));
    let i, j, j0;
    const lineSize = width + 7 & -8;
    let data = new Uint8Array(lineSize * height), pos = 0;
    for (const elem of imgData.data){
        let mask = 128;
        while(mask > 0){
            data[pos++] = elem & mask ? 0 : 255;
            mask >>= 1;
        }
    }
    let count = 0;
    pos = 0;
    if (data[pos] !== 0) {
        points[0] = 1;
        ++count;
    }
    for(j = 1; j < width; j++){
        if (data[pos] !== data[pos + 1]) {
            points[j] = data[pos] ? 2 : 1;
            ++count;
        }
        pos++;
    }
    if (data[pos] !== 0) {
        points[j] = 2;
        ++count;
    }
    for(i = 1; i < height; i++){
        pos = i * lineSize;
        j0 = i * width1;
        if (data[pos - lineSize] !== data[pos]) {
            points[j0] = data[pos] ? 1 : 8;
            ++count;
        }
        let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
        for(j = 1; j < width; j++){
            sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
            if (POINT_TYPES[sum]) {
                points[j0 + j] = POINT_TYPES[sum];
                ++count;
            }
            pos++;
        }
        if (data[pos - lineSize] !== data[pos]) {
            points[j0 + j] = data[pos] ? 2 : 4;
            ++count;
        }
        if (count > POINT_TO_PROCESS_LIMIT) return null;
    }
    pos = lineSize * (height - 1);
    j0 = i * width1;
    if (data[pos] !== 0) {
        points[j0] = 8;
        ++count;
    }
    for(j = 1; j < width; j++){
        if (data[pos] !== data[pos + 1]) {
            points[j0 + j] = data[pos] ? 4 : 8;
            ++count;
        }
        pos++;
    }
    if (data[pos] !== 0) {
        points[j0 + j] = 4;
        ++count;
    }
    if (count > POINT_TO_PROCESS_LIMIT) return null;
    const steps = new Int32Array([
        0,
        width1,
        -1,
        0,
        -width1,
        0,
        0,
        0,
        1
    ]);
    const path = new Path2D();
    for(i = 0; count && i <= height; i++){
        let p = i * width1;
        const end = p + width;
        while(p < end && !points[p])p++;
        if (p === end) continue;
        path.moveTo(p % width1, i);
        const p0 = p;
        let type = points[p];
        do {
            const step = steps[type];
            do p += step;
            while (!points[p]);
            const pp = points[p];
            if (pp !== 5 && pp !== 10) {
                type = pp;
                points[p] = 0;
            } else {
                type = pp & 0x33 * type >> 4;
                points[p] &= type >> 2 | type << 2;
            }
            path.lineTo(p % width1, p / width1 | 0);
            if (!points[p]) --count;
        }while (p0 !== p);
        --i;
    }
    data = null;
    points = null;
    const drawOutline = function(c) {
        c.save();
        c.scale(1 / width, -1 / height);
        c.translate(0, -height);
        c.fill(path);
        c.beginPath();
        c.restore();
    };
    return drawOutline;
}
class CanvasExtraState {
    constructor(width, height){
        this.alphaIsShape = false;
        this.fontSize = 0;
        this.fontSizeScale = 1;
        this.textMatrix = IDENTITY_MATRIX;
        this.textMatrixScale = 1;
        this.fontMatrix = FONT_IDENTITY_MATRIX;
        this.leading = 0;
        this.x = 0;
        this.y = 0;
        this.lineX = 0;
        this.lineY = 0;
        this.charSpacing = 0;
        this.wordSpacing = 0;
        this.textHScale = 1;
        this.textRenderingMode = TextRenderingMode.FILL;
        this.textRise = 0;
        this.fillColor = "#000000";
        this.strokeColor = "#000000";
        this.patternFill = false;
        this.patternStroke = false;
        this.fillAlpha = 1;
        this.strokeAlpha = 1;
        this.lineWidth = 1;
        this.activeSMask = null;
        this.transferMaps = "none";
        this.startNewPathAndClipBox([
            0,
            0,
            width,
            height
        ]);
    }
    clone() {
        const clone = Object.create(this);
        clone.clipBox = this.clipBox.slice();
        return clone;
    }
    setCurrentPoint(x, y) {
        this.x = x;
        this.y = y;
    }
    updatePathMinMax(transform, x, y) {
        [x, y] = Util.applyTransform([
            x,
            y
        ], transform);
        this.minX = Math.min(this.minX, x);
        this.minY = Math.min(this.minY, y);
        this.maxX = Math.max(this.maxX, x);
        this.maxY = Math.max(this.maxY, y);
    }
    updateRectMinMax(transform, rect) {
        const p1 = Util.applyTransform(rect, transform);
        const p2 = Util.applyTransform(rect.slice(2), transform);
        const p3 = Util.applyTransform([
            rect[0],
            rect[3]
        ], transform);
        const p4 = Util.applyTransform([
            rect[2],
            rect[1]
        ], transform);
        this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);
        this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);
        this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);
        this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);
    }
    updateScalingPathMinMax(transform, minMax) {
        Util.scaleMinMax(transform, minMax);
        this.minX = Math.min(this.minX, minMax[0]);
        this.minY = Math.min(this.minY, minMax[1]);
        this.maxX = Math.max(this.maxX, minMax[2]);
        this.maxY = Math.max(this.maxY, minMax[3]);
    }
    updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
        const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);
        if (minMax) return;
        this.updateRectMinMax(transform, box);
    }
    getPathBoundingBox(pathType = PathType.FILL, transform = null) {
        const box = [
            this.minX,
            this.minY,
            this.maxX,
            this.maxY
        ];
        if (pathType === PathType.STROKE) {
            if (!transform) unreachable("Stroke bounding box must include transform.");
            const scale = Util.singularValueDecompose2dScale(transform);
            const xStrokePad = scale[0] * this.lineWidth / 2;
            const yStrokePad = scale[1] * this.lineWidth / 2;
            box[0] -= xStrokePad;
            box[1] -= yStrokePad;
            box[2] += xStrokePad;
            box[3] += yStrokePad;
        }
        return box;
    }
    updateClipFromPath() {
        const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
        this.startNewPathAndClipBox(intersect || [
            0,
            0,
            0,
            0
        ]);
    }
    isEmptyClip() {
        return this.minX === Infinity;
    }
    startNewPathAndClipBox(box) {
        this.clipBox = box;
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = 0;
        this.maxY = 0;
    }
    getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
        return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
    }
}
function putBinaryImageData(ctx, imgData) {
    if (imgData instanceof ImageData) {
        ctx.putImageData(imgData, 0, 0);
        return;
    }
    const height = imgData.height, width = imgData.width;
    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
    let srcPos = 0, destPos;
    const src = imgData.data;
    const dest = chunkImgData.data;
    let i, j, thisChunkHeight, elemsInThisChunk;
    if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {
        const srcLength = src.byteLength;
        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
        const dest32DataLength = dest32.length;
        const fullSrcDiff = width + 7 >> 3;
        const white = 0xffffffff;
        const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
        for(i = 0; i < totalChunks; i++){
            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
            destPos = 0;
            for(j = 0; j < thisChunkHeight; j++){
                const srcDiff = srcLength - srcPos;
                let k = 0;
                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                const kEndUnrolled = kEnd & -8;
                let mask = 0;
                let srcByte = 0;
                for(; k < kEndUnrolled; k += 8){
                    srcByte = src[srcPos++];
                    dest32[destPos++] = srcByte & 128 ? white : black;
                    dest32[destPos++] = srcByte & 64 ? white : black;
                    dest32[destPos++] = srcByte & 32 ? white : black;
                    dest32[destPos++] = srcByte & 16 ? white : black;
                    dest32[destPos++] = srcByte & 8 ? white : black;
                    dest32[destPos++] = srcByte & 4 ? white : black;
                    dest32[destPos++] = srcByte & 2 ? white : black;
                    dest32[destPos++] = srcByte & 1 ? white : black;
                }
                for(; k < kEnd; k++){
                    if (mask === 0) {
                        srcByte = src[srcPos++];
                        mask = 128;
                    }
                    dest32[destPos++] = srcByte & mask ? white : black;
                    mask >>= 1;
                }
            }
            while(destPos < dest32DataLength)dest32[destPos++] = 0;
            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
        }
    } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {
        j = 0;
        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
        for(i = 0; i < fullChunks; i++){
            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
            srcPos += elemsInThisChunk;
            ctx.putImageData(chunkImgData, 0, j);
            j += FULL_CHUNK_HEIGHT;
        }
        if (i < totalChunks) {
            elemsInThisChunk = width * partialChunkHeight * 4;
            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
            ctx.putImageData(chunkImgData, 0, j);
        }
    } else if (imgData.kind === util_ImageKind.RGB_24BPP) {
        thisChunkHeight = FULL_CHUNK_HEIGHT;
        elemsInThisChunk = width * thisChunkHeight;
        for(i = 0; i < totalChunks; i++){
            if (i >= fullChunks) {
                thisChunkHeight = partialChunkHeight;
                elemsInThisChunk = width * thisChunkHeight;
            }
            destPos = 0;
            for(j = elemsInThisChunk; j--;){
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = 255;
            }
            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
        }
    } else throw new Error(`bad image kind: ${imgData.kind}`);
}
function putBinaryImageMask(ctx, imgData) {
    if (imgData.bitmap) {
        ctx.drawImage(imgData.bitmap, 0, 0);
        return;
    }
    const height = imgData.height, width = imgData.width;
    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
    let srcPos = 0;
    const src = imgData.data;
    const dest = chunkImgData.data;
    for(let i = 0; i < totalChunks; i++){
        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
        ({ srcPos } = convertBlackAndWhiteToRGBA({
            src,
            srcPos,
            dest,
            width,
            height: thisChunkHeight,
            nonBlackColor: 0
        }));
        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
}
function copyCtxState(sourceCtx, destCtx) {
    const properties = [
        "strokeStyle",
        "fillStyle",
        "fillRule",
        "globalAlpha",
        "lineWidth",
        "lineCap",
        "lineJoin",
        "miterLimit",
        "globalCompositeOperation",
        "font",
        "filter"
    ];
    for (const property of properties)if (sourceCtx[property] !== undefined) destCtx[property] = sourceCtx[property];
    if (sourceCtx.setLineDash !== undefined) {
        destCtx.setLineDash(sourceCtx.getLineDash());
        destCtx.lineDashOffset = sourceCtx.lineDashOffset;
    }
}
function resetCtxToDefault(ctx) {
    ctx.strokeStyle = ctx.fillStyle = "#000000";
    ctx.fillRule = "nonzero";
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 10;
    ctx.globalCompositeOperation = "source-over";
    ctx.font = "10px sans-serif";
    if (ctx.setLineDash !== undefined) {
        ctx.setLineDash([]);
        ctx.lineDashOffset = 0;
    }
    if (!isNodeJS) {
        const { filter } = ctx;
        if (filter !== "none" && filter !== "") ctx.filter = "none";
    }
}
function getImageSmoothingEnabled(transform, interpolate) {
    if (interpolate) return true;
    const scale = Util.singularValueDecompose2dScale(transform);
    scale[0] = Math.fround(scale[0]);
    scale[1] = Math.fround(scale[1]);
    const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS);
    return scale[0] <= actualScale && scale[1] <= actualScale;
}
const LINE_CAP_STYLES = [
    "butt",
    "round",
    "square"
];
const LINE_JOIN_STYLES = [
    "miter",
    "round",
    "bevel"
];
const NORMAL_CLIP = {};
const EO_CLIP = {};
class CanvasGraphics {
    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors){
        this.ctx = canvasCtx;
        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
        this.stateStack = [];
        this.pendingClip = null;
        this.pendingEOFill = false;
        this.res = null;
        this.xobjs = null;
        this.commonObjs = commonObjs;
        this.objs = objs;
        this.canvasFactory = canvasFactory;
        this.filterFactory = filterFactory;
        this.groupStack = [];
        this.processingType3 = null;
        this.baseTransform = null;
        this.baseTransformStack = [];
        this.groupLevel = 0;
        this.smaskStack = [];
        this.smaskCounter = 0;
        this.tempSMask = null;
        this.suspendedCtx = null;
        this.contentVisible = true;
        this.markedContentStack = markedContentStack || [];
        this.optionalContentConfig = optionalContentConfig;
        this.cachedCanvases = new CachedCanvases(this.canvasFactory);
        this.cachedPatterns = new Map();
        this.annotationCanvasMap = annotationCanvasMap;
        this.viewportScale = 1;
        this.outputScaleX = 1;
        this.outputScaleY = 1;
        this.pageColors = pageColors;
        this._cachedScaleForStroking = [
            -1,
            0
        ];
        this._cachedGetSinglePixelWidth = null;
        this._cachedBitmapsMap = new Map();
    }
    getObject(data, fallback = null) {
        if (typeof data === "string") return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
        return fallback;
    }
    beginDrawing({ transform, viewport, transparency = false, background = null }) {
        const width = this.ctx.canvas.width;
        const height = this.ctx.canvas.height;
        const savedFillStyle = this.ctx.fillStyle;
        this.ctx.fillStyle = background || "#ffffff";
        this.ctx.fillRect(0, 0, width, height);
        this.ctx.fillStyle = savedFillStyle;
        if (transparency) {
            const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
            this.compositeCtx = this.ctx;
            this.transparentCanvas = transparentCanvas.canvas;
            this.ctx = transparentCanvas.context;
            this.ctx.save();
            this.ctx.transform(...getCurrentTransform(this.compositeCtx));
        }
        this.ctx.save();
        resetCtxToDefault(this.ctx);
        if (transform) {
            this.ctx.transform(...transform);
            this.outputScaleX = transform[0];
            this.outputScaleY = transform[0];
        }
        this.ctx.transform(...viewport.transform);
        this.viewportScale = viewport.scale;
        this.baseTransform = getCurrentTransform(this.ctx);
    }
    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
        const argsArray = operatorList.argsArray;
        const fnArray = operatorList.fnArray;
        let i = executionStartIdx || 0;
        const argsArrayLen = argsArray.length;
        if (argsArrayLen === i) return i;
        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
        let steps = 0;
        const commonObjs = this.commonObjs;
        const objs = this.objs;
        let fnId;
        while(true){
            if (stepper !== undefined && i === stepper.nextBreakPoint) {
                stepper.breakIt(i, continueCallback);
                return i;
            }
            fnId = fnArray[i];
            if (fnId !== OPS.dependency) this[fnId].apply(this, argsArray[i]);
            else for (const depObjId of argsArray[i]){
                const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                if (!objsPool.has(depObjId)) {
                    objsPool.get(depObjId, continueCallback);
                    return i;
                }
            }
            i++;
            if (i === argsArrayLen) return i;
            if (chunkOperations && ++steps > EXECUTION_STEPS) {
                if (Date.now() > endTime) {
                    continueCallback();
                    return i;
                }
                steps = 0;
            }
        }
    }
    #restoreInitialState() {
        while(this.stateStack.length || this.inSMaskMode)this.restore();
        this.current.activeSMask = null;
        this.ctx.restore();
        if (this.transparentCanvas) {
            this.ctx = this.compositeCtx;
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.drawImage(this.transparentCanvas, 0, 0);
            this.ctx.restore();
            this.transparentCanvas = null;
        }
    }
    endDrawing() {
        this.#restoreInitialState();
        this.cachedCanvases.clear();
        this.cachedPatterns.clear();
        for (const cache of this._cachedBitmapsMap.values()){
            for (const canvas of cache.values())if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) canvas.width = canvas.height = 0;
            cache.clear();
        }
        this._cachedBitmapsMap.clear();
        this.#drawFilter();
    }
    #drawFilter() {
        if (this.pageColors) {
            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
            if (hcmFilterId !== "none") {
                const savedFilter = this.ctx.filter;
                this.ctx.filter = hcmFilterId;
                this.ctx.drawImage(this.ctx.canvas, 0, 0);
                this.ctx.filter = savedFilter;
            }
        }
    }
    _scaleImage(img, inverseTransform) {
        const width = img.width ?? img.displayWidth;
        const height = img.height ?? img.displayHeight;
        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
        let paintWidth = width, paintHeight = height;
        let tmpCanvasId = "prescale1";
        let tmpCanvas, tmpCtx;
        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){
            let newWidth = paintWidth, newHeight = paintHeight;
            if (widthScale > 2 && paintWidth > 1) {
                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
                widthScale /= paintWidth / newWidth;
            }
            if (heightScale > 2 && paintHeight > 1) {
                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
                heightScale /= paintHeight / newHeight;
            }
            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
            tmpCtx = tmpCanvas.context;
            tmpCtx.clearRect(0, 0, newWidth, newHeight);
            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
            img = tmpCanvas.canvas;
            paintWidth = newWidth;
            paintHeight = newHeight;
            tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
        }
        return {
            img,
            paintWidth,
            paintHeight
        };
    }
    _createMaskCanvas(img) {
        const ctx = this.ctx;
        const { width, height } = img;
        const fillColor = this.current.fillColor;
        const isPatternFill = this.current.patternFill;
        const currentTransform = getCurrentTransform(ctx);
        let cache, cacheKey, scaled, maskCanvas;
        if ((img.bitmap || img.data) && img.count > 1) {
            const mainKey = img.bitmap || img.data.buffer;
            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [
                currentTransform.slice(0, 4),
                fillColor
            ]);
            cache = this._cachedBitmapsMap.get(mainKey);
            if (!cache) {
                cache = new Map();
                this._cachedBitmapsMap.set(mainKey, cache);
            }
            const cachedImage = cache.get(cacheKey);
            if (cachedImage && !isPatternFill) {
                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                return {
                    canvas: cachedImage,
                    offsetX,
                    offsetY
                };
            }
            scaled = cachedImage;
        }
        if (!scaled) {
            maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
            putBinaryImageMask(maskCanvas.context, img);
        }
        let maskToCanvas = Util.transform(currentTransform, [
            1 / width,
            0,
            0,
            -1 / height,
            0,
            0
        ]);
        maskToCanvas = Util.transform(maskToCanvas, [
            1,
            0,
            0,
            1,
            0,
            -height
        ]);
        const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox([
            0,
            0,
            width,
            height
        ], maskToCanvas);
        const drawnWidth = Math.round(maxX - minX) || 1;
        const drawnHeight = Math.round(maxY - minY) || 1;
        const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
        const fillCtx = fillCanvas.context;
        const offsetX = minX;
        const offsetY = minY;
        fillCtx.translate(-offsetX, -offsetY);
        fillCtx.transform(...maskToCanvas);
        if (!scaled) {
            scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));
            scaled = scaled.img;
            if (cache && isPatternFill) cache.set(cacheKey, scaled);
        }
        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);
        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
        fillCtx.globalCompositeOperation = "source-in";
        const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [
            1,
            0,
            0,
            1,
            -offsetX,
            -offsetY
        ]);
        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;
        fillCtx.fillRect(0, 0, width, height);
        if (cache && !isPatternFill) {
            this.cachedCanvases.delete("fillCanvas");
            cache.set(cacheKey, fillCanvas.canvas);
        }
        return {
            canvas: fillCanvas.canvas,
            offsetX: Math.round(offsetX),
            offsetY: Math.round(offsetY)
        };
    }
    setLineWidth(width) {
        if (width !== this.current.lineWidth) this._cachedScaleForStroking[0] = -1;
        this.current.lineWidth = width;
        this.ctx.lineWidth = width;
    }
    setLineCap(style) {
        this.ctx.lineCap = LINE_CAP_STYLES[style];
    }
    setLineJoin(style) {
        this.ctx.lineJoin = LINE_JOIN_STYLES[style];
    }
    setMiterLimit(limit) {
        this.ctx.miterLimit = limit;
    }
    setDash(dashArray, dashPhase) {
        const ctx = this.ctx;
        if (ctx.setLineDash !== undefined) {
            ctx.setLineDash(dashArray);
            ctx.lineDashOffset = dashPhase;
        }
    }
    setRenderingIntent(intent) {}
    setFlatness(flatness) {}
    setGState(states) {
        for (const [key, value] of states)switch(key){
            case "LW":
                this.setLineWidth(value);
                break;
            case "LC":
                this.setLineCap(value);
                break;
            case "LJ":
                this.setLineJoin(value);
                break;
            case "ML":
                this.setMiterLimit(value);
                break;
            case "D":
                this.setDash(value[0], value[1]);
                break;
            case "RI":
                this.setRenderingIntent(value);
                break;
            case "FL":
                this.setFlatness(value);
                break;
            case "Font":
                this.setFont(value[0], value[1]);
                break;
            case "CA":
                this.current.strokeAlpha = value;
                break;
            case "ca":
                this.current.fillAlpha = value;
                this.ctx.globalAlpha = value;
                break;
            case "BM":
                this.ctx.globalCompositeOperation = value;
                break;
            case "SMask":
                this.current.activeSMask = value ? this.tempSMask : null;
                this.tempSMask = null;
                this.checkSMaskState();
                break;
            case "TR":
                this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
                break;
        }
    }
    get inSMaskMode() {
        return !!this.suspendedCtx;
    }
    checkSMaskState() {
        const inSMaskMode = this.inSMaskMode;
        if (this.current.activeSMask && !inSMaskMode) this.beginSMaskMode();
        else if (!this.current.activeSMask && inSMaskMode) this.endSMaskMode();
    }
    beginSMaskMode() {
        if (this.inSMaskMode) throw new Error("beginSMaskMode called while already in smask mode");
        const drawnWidth = this.ctx.canvas.width;
        const drawnHeight = this.ctx.canvas.height;
        const cacheId = "smaskGroupAt" + this.groupLevel;
        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
        this.suspendedCtx = this.ctx;
        this.ctx = scratchCanvas.context;
        const ctx = this.ctx;
        ctx.setTransform(...getCurrentTransform(this.suspendedCtx));
        copyCtxState(this.suspendedCtx, ctx);
        mirrorContextOperations(ctx, this.suspendedCtx);
        this.setGState([
            [
                "BM",
                "source-over"
            ],
            [
                "ca",
                1
            ],
            [
                "CA",
                1
            ]
        ]);
    }
    endSMaskMode() {
        if (!this.inSMaskMode) throw new Error("endSMaskMode called while not in smask mode");
        this.ctx._removeMirroring();
        copyCtxState(this.ctx, this.suspendedCtx);
        this.ctx = this.suspendedCtx;
        this.suspendedCtx = null;
    }
    compose(dirtyBox) {
        if (!this.current.activeSMask) return;
        if (!dirtyBox) dirtyBox = [
            0,
            0,
            this.ctx.canvas.width,
            this.ctx.canvas.height
        ];
        else {
            dirtyBox[0] = Math.floor(dirtyBox[0]);
            dirtyBox[1] = Math.floor(dirtyBox[1]);
            dirtyBox[2] = Math.ceil(dirtyBox[2]);
            dirtyBox[3] = Math.ceil(dirtyBox[3]);
        }
        const smask = this.current.activeSMask;
        const suspendedCtx = this.suspendedCtx;
        this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        this.ctx.restore();
    }
    composeSMask(ctx, smask, layerCtx, layerBox) {
        const layerOffsetX = layerBox[0];
        const layerOffsetY = layerBox[1];
        const layerWidth = layerBox[2] - layerOffsetX;
        const layerHeight = layerBox[3] - layerOffsetY;
        if (layerWidth === 0 || layerHeight === 0) return;
        this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(layerCtx.canvas, 0, 0);
        ctx.restore();
    }
    genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
        let maskCanvas = maskCtx.canvas;
        let maskX = layerOffsetX - maskOffsetX;
        let maskY = layerOffsetY - maskOffsetY;
        if (backdrop) {
            const backdropRGB = Util.makeHexColor(...backdrop);
            if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {
                const canvas = this.cachedCanvases.getCanvas("maskExtension", width, height);
                const ctx = canvas.context;
                ctx.drawImage(maskCanvas, -maskX, -maskY);
                ctx.globalCompositeOperation = "destination-atop";
                ctx.fillStyle = backdropRGB;
                ctx.fillRect(0, 0, width, height);
                ctx.globalCompositeOperation = "source-over";
                maskCanvas = canvas.canvas;
                maskX = maskY = 0;
            } else {
                maskCtx.save();
                maskCtx.globalAlpha = 1;
                maskCtx.setTransform(1, 0, 0, 1, 0, 0);
                const clip = new Path2D();
                clip.rect(maskX, maskY, width, height);
                maskCtx.clip(clip);
                maskCtx.globalCompositeOperation = "destination-atop";
                maskCtx.fillStyle = backdropRGB;
                maskCtx.fillRect(maskX, maskY, width, height);
                maskCtx.restore();
            }
        }
        layerCtx.save();
        layerCtx.globalAlpha = 1;
        layerCtx.setTransform(1, 0, 0, 1, 0, 0);
        if (subtype === "Alpha" && transferMap) layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
        else if (subtype === "Luminosity") layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
        const clip = new Path2D();
        clip.rect(layerOffsetX, layerOffsetY, width, height);
        layerCtx.clip(clip);
        layerCtx.globalCompositeOperation = "destination-in";
        layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);
        layerCtx.restore();
    }
    save() {
        if (this.inSMaskMode) {
            copyCtxState(this.ctx, this.suspendedCtx);
            this.suspendedCtx.save();
        } else this.ctx.save();
        const old = this.current;
        this.stateStack.push(old);
        this.current = old.clone();
    }
    restore() {
        if (this.stateStack.length === 0 && this.inSMaskMode) this.endSMaskMode();
        if (this.stateStack.length !== 0) {
            this.current = this.stateStack.pop();
            if (this.inSMaskMode) {
                this.suspendedCtx.restore();
                copyCtxState(this.suspendedCtx, this.ctx);
            } else this.ctx.restore();
            this.checkSMaskState();
            this.pendingClip = null;
            this._cachedScaleForStroking[0] = -1;
            this._cachedGetSinglePixelWidth = null;
        }
    }
    transform(a, b, c, d, e, f) {
        this.ctx.transform(a, b, c, d, e, f);
        this._cachedScaleForStroking[0] = -1;
        this._cachedGetSinglePixelWidth = null;
    }
    constructPath(ops, args, minMax) {
        const ctx = this.ctx;
        const current = this.current;
        let x = current.x, y = current.y;
        let startX, startY;
        const currentTransform = getCurrentTransform(ctx);
        const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
        const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
        for(let i = 0, j = 0, ii = ops.length; i < ii; i++)switch(ops[i] | 0){
            case OPS.rectangle:
                x = args[j++];
                y = args[j++];
                const width = args[j++];
                const height = args[j++];
                const xw = x + width;
                const yh = y + height;
                ctx.moveTo(x, y);
                if (width === 0 || height === 0) ctx.lineTo(xw, yh);
                else {
                    ctx.lineTo(xw, y);
                    ctx.lineTo(xw, yh);
                    ctx.lineTo(x, yh);
                }
                if (!isScalingMatrix) current.updateRectMinMax(currentTransform, [
                    x,
                    y,
                    xw,
                    yh
                ]);
                ctx.closePath();
                break;
            case OPS.moveTo:
                x = args[j++];
                y = args[j++];
                ctx.moveTo(x, y);
                if (!isScalingMatrix) current.updatePathMinMax(currentTransform, x, y);
                break;
            case OPS.lineTo:
                x = args[j++];
                y = args[j++];
                ctx.lineTo(x, y);
                if (!isScalingMatrix) current.updatePathMinMax(currentTransform, x, y);
                break;
            case OPS.curveTo:
                startX = x;
                startY = y;
                x = args[j + 4];
                y = args[j + 5];
                ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                j += 6;
                break;
            case OPS.curveTo2:
                startX = x;
                startY = y;
                ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                x = args[j + 2];
                y = args[j + 3];
                j += 4;
                break;
            case OPS.curveTo3:
                startX = x;
                startY = y;
                x = args[j + 2];
                y = args[j + 3];
                ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                j += 4;
                break;
            case OPS.closePath:
                ctx.closePath();
                break;
        }
        if (isScalingMatrix) current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
        current.setCurrentPoint(x, y);
    }
    closePath() {
        this.ctx.closePath();
    }
    stroke(consumePath = true) {
        const ctx = this.ctx;
        const strokeColor = this.current.strokeColor;
        ctx.globalAlpha = this.current.strokeAlpha;
        if (this.contentVisible) {
            if (typeof strokeColor === "object" && strokeColor?.getPattern) {
                ctx.save();
                ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);
                this.rescaleAndStroke(false);
                ctx.restore();
            } else this.rescaleAndStroke(true);
        }
        if (consumePath) this.consumePath(this.current.getClippedPathBoundingBox());
        ctx.globalAlpha = this.current.fillAlpha;
    }
    closeStroke() {
        this.closePath();
        this.stroke();
    }
    fill(consumePath = true) {
        const ctx = this.ctx;
        const fillColor = this.current.fillColor;
        const isPatternFill = this.current.patternFill;
        let needRestore = false;
        if (isPatternFill) {
            ctx.save();
            ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);
            needRestore = true;
        }
        const intersect = this.current.getClippedPathBoundingBox();
        if (this.contentVisible && intersect !== null) {
            if (this.pendingEOFill) {
                ctx.fill("evenodd");
                this.pendingEOFill = false;
            } else ctx.fill();
        }
        if (needRestore) ctx.restore();
        if (consumePath) this.consumePath(intersect);
    }
    eoFill() {
        this.pendingEOFill = true;
        this.fill();
    }
    fillStroke() {
        this.fill(false);
        this.stroke(false);
        this.consumePath();
    }
    eoFillStroke() {
        this.pendingEOFill = true;
        this.fillStroke();
    }
    closeFillStroke() {
        this.closePath();
        this.fillStroke();
    }
    closeEOFillStroke() {
        this.pendingEOFill = true;
        this.closePath();
        this.fillStroke();
    }
    endPath() {
        this.consumePath();
    }
    clip() {
        this.pendingClip = NORMAL_CLIP;
    }
    eoClip() {
        this.pendingClip = EO_CLIP;
    }
    beginText() {
        this.current.textMatrix = IDENTITY_MATRIX;
        this.current.textMatrixScale = 1;
        this.current.x = this.current.lineX = 0;
        this.current.y = this.current.lineY = 0;
    }
    endText() {
        const paths = this.pendingTextPaths;
        const ctx = this.ctx;
        if (paths === undefined) {
            ctx.beginPath();
            return;
        }
        const newPath = new Path2D();
        const invTransf = ctx.getTransform().invertSelf();
        for (const { transform, x, y, fontSize, path } of paths)newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));
        ctx.clip(newPath);
        ctx.beginPath();
        delete this.pendingTextPaths;
    }
    setCharSpacing(spacing) {
        this.current.charSpacing = spacing;
    }
    setWordSpacing(spacing) {
        this.current.wordSpacing = spacing;
    }
    setHScale(scale) {
        this.current.textHScale = scale / 100;
    }
    setLeading(leading) {
        this.current.leading = -leading;
    }
    setFont(fontRefName, size) {
        const fontObj = this.commonObjs.get(fontRefName);
        const current = this.current;
        if (!fontObj) throw new Error(`Can't find font for ${fontRefName}`);
        current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) warn("Invalid font matrix for font " + fontRefName);
        if (size < 0) {
            size = -size;
            current.fontDirection = -1;
        } else current.fontDirection = 1;
        this.current.font = fontObj;
        this.current.fontSize = size;
        if (fontObj.isType3Font) return;
        const name = fontObj.loadedName || "sans-serif";
        const typeface = fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
        let bold = "normal";
        if (fontObj.black) bold = "900";
        else if (fontObj.bold) bold = "bold";
        const italic = fontObj.italic ? "italic" : "normal";
        let browserFontSize = size;
        if (size < MIN_FONT_SIZE) browserFontSize = MIN_FONT_SIZE;
        else if (size > MAX_FONT_SIZE) browserFontSize = MAX_FONT_SIZE;
        this.current.fontSizeScale = size / browserFontSize;
        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
    }
    setTextRenderingMode(mode) {
        this.current.textRenderingMode = mode;
    }
    setTextRise(rise) {
        this.current.textRise = rise;
    }
    moveText(x, y) {
        this.current.x = this.current.lineX += x;
        this.current.y = this.current.lineY += y;
    }
    setLeadingMoveText(x, y) {
        this.setLeading(-y);
        this.moveText(x, y);
    }
    setTextMatrix(a, b, c, d, e, f) {
        this.current.textMatrix = [
            a,
            b,
            c,
            d,
            e,
            f
        ];
        this.current.textMatrixScale = Math.hypot(a, b);
        this.current.x = this.current.lineX = 0;
        this.current.y = this.current.lineY = 0;
    }
    nextLine() {
        this.moveText(0, this.current.leading);
    }
    #getScaledPath(path, currentTransform, transform) {
        const newPath = new Path2D();
        newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));
        return newPath;
    }
    paintChar(character, x, y, patternFillTransform, patternStrokeTransform) {
        const ctx = this.ctx;
        const current = this.current;
        const font = current.font;
        const textRenderingMode = current.textRenderingMode;
        const fontSize = current.fontSize / current.fontSizeScale;
        const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
        const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
        const patternFill = current.patternFill && !font.missingFile;
        const patternStroke = current.patternStroke && !font.missingFile;
        let path;
        if (font.disableFontFace || isAddToPathSet || patternFill || patternStroke) path = font.getPathGenerator(this.commonObjs, character);
        if (font.disableFontFace || patternFill || patternStroke) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(fontSize, -fontSize);
            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                if (patternFillTransform) {
                    const currentTransform = ctx.getTransform();
                    ctx.setTransform(...patternFillTransform);
                    ctx.fill(this.#getScaledPath(path, currentTransform, patternFillTransform));
                } else ctx.fill(path);
            }
            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                if (patternStrokeTransform) {
                    const currentTransform = ctx.getTransform();
                    ctx.setTransform(...patternStrokeTransform);
                    ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));
                } else {
                    ctx.lineWidth /= fontSize;
                    ctx.stroke(path);
                }
            }
            ctx.restore();
        } else {
            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) ctx.fillText(character, x, y);
            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) ctx.strokeText(character, x, y);
        }
        if (isAddToPathSet) {
            const paths = this.pendingTextPaths ||= [];
            paths.push({
                transform: getCurrentTransform(ctx),
                x,
                y,
                fontSize,
                path
            });
        }
    }
    get isFontSubpixelAAEnabled() {
        const { context: ctx } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
        ctx.scale(1.5, 1);
        ctx.fillText("I", 0, 10);
        const data = ctx.getImageData(0, 0, 10, 10).data;
        let enabled = false;
        for(let i = 3; i < data.length; i += 4)if (data[i] > 0 && data[i] < 255) {
            enabled = true;
            break;
        }
        return shadow(this, "isFontSubpixelAAEnabled", enabled);
    }
    showText(glyphs) {
        const current = this.current;
        const font = current.font;
        if (font.isType3Font) return this.showType3Text(glyphs);
        const fontSize = current.fontSize;
        if (fontSize === 0) return undefined;
        const ctx = this.ctx;
        const fontSizeScale = current.fontSizeScale;
        const charSpacing = current.charSpacing;
        const wordSpacing = current.wordSpacing;
        const fontDirection = current.fontDirection;
        const textHScale = current.textHScale * fontDirection;
        const glyphsLength = glyphs.length;
        const vertical = font.vertical;
        const spacingDir = vertical ? 1 : -1;
        const defaultVMetrics = font.defaultVMetrics;
        const widthAdvanceScale = fontSize * current.fontMatrix[0];
        const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
        ctx.save();
        ctx.transform(...current.textMatrix);
        ctx.translate(current.x, current.y + current.textRise);
        if (fontDirection > 0) ctx.scale(textHScale, -1);
        else ctx.scale(textHScale, 1);
        let patternFillTransform, patternStrokeTransform;
        if (current.patternFill) {
            ctx.save();
            const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);
            patternFillTransform = getCurrentTransform(ctx);
            ctx.restore();
            ctx.fillStyle = pattern;
        }
        if (current.patternStroke) {
            ctx.save();
            const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);
            patternStrokeTransform = getCurrentTransform(ctx);
            ctx.restore();
            ctx.strokeStyle = pattern;
        }
        let lineWidth = current.lineWidth;
        const scale = current.textMatrixScale;
        if (scale === 0 || lineWidth === 0) {
            const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) lineWidth = this.getSinglePixelWidth();
        } else lineWidth /= scale;
        if (fontSizeScale !== 1.0) {
            ctx.scale(fontSizeScale, fontSizeScale);
            lineWidth /= fontSizeScale;
        }
        ctx.lineWidth = lineWidth;
        if (font.isInvalidPDFjsFont) {
            const chars = [];
            let width = 0;
            for (const glyph of glyphs){
                chars.push(glyph.unicode);
                width += glyph.width;
            }
            ctx.fillText(chars.join(""), 0, 0);
            current.x += width * widthAdvanceScale * textHScale;
            ctx.restore();
            this.compose();
            return undefined;
        }
        let x = 0, i;
        for(i = 0; i < glyphsLength; ++i){
            const glyph = glyphs[i];
            if (typeof glyph === "number") {
                x += spacingDir * glyph * fontSize / 1000;
                continue;
            }
            let restoreNeeded = false;
            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
            const character = glyph.fontChar;
            const accent = glyph.accent;
            let scaledX, scaledY;
            let width = glyph.width;
            if (vertical) {
                const vmetric = glyph.vmetric || defaultVMetrics;
                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                const vy = vmetric[2] * widthAdvanceScale;
                width = vmetric ? -vmetric[0] : width;
                scaledX = vx / fontSizeScale;
                scaledY = (x + vy) / fontSizeScale;
            } else {
                scaledX = x / fontSizeScale;
                scaledY = 0;
            }
            if (font.remeasure && width > 0) {
                const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;
                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                    const characterScaleX = width / measuredWidth;
                    restoreNeeded = true;
                    ctx.save();
                    ctx.scale(characterScaleX, 1);
                    scaledX /= characterScaleX;
                } else if (width !== measuredWidth) scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
            }
            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                if (simpleFillText && !accent) ctx.fillText(character, scaledX, scaledY);
                else {
                    this.paintChar(character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);
                    if (accent) {
                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                        this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);
                    }
                }
            }
            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
            x += charWidth;
            if (restoreNeeded) ctx.restore();
        }
        if (vertical) current.y -= x;
        else current.x += x * textHScale;
        ctx.restore();
        this.compose();
        return undefined;
    }
    showType3Text(glyphs) {
        const ctx = this.ctx;
        const current = this.current;
        const font = current.font;
        const fontSize = current.fontSize;
        const fontDirection = current.fontDirection;
        const spacingDir = font.vertical ? 1 : -1;
        const charSpacing = current.charSpacing;
        const wordSpacing = current.wordSpacing;
        const textHScale = current.textHScale * fontDirection;
        const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
        const glyphsLength = glyphs.length;
        const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;
        let i, glyph, width, spacingLength;
        if (isTextInvisible || fontSize === 0) return;
        this._cachedScaleForStroking[0] = -1;
        this._cachedGetSinglePixelWidth = null;
        ctx.save();
        ctx.transform(...current.textMatrix);
        ctx.translate(current.x, current.y);
        ctx.scale(textHScale, fontDirection);
        for(i = 0; i < glyphsLength; ++i){
            glyph = glyphs[i];
            if (typeof glyph === "number") {
                spacingLength = spacingDir * glyph * fontSize / 1000;
                this.ctx.translate(spacingLength, 0);
                current.x += spacingLength * textHScale;
                continue;
            }
            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
            const operatorList = font.charProcOperatorList[glyph.operatorListId];
            if (!operatorList) {
                warn(`Type3 character "${glyph.operatorListId}" is not available.`);
                continue;
            }
            if (this.contentVisible) {
                this.processingType3 = glyph;
                this.save();
                ctx.scale(fontSize, fontSize);
                ctx.transform(...fontMatrix);
                this.executeOperatorList(operatorList);
                this.restore();
            }
            const transformed = Util.applyTransform([
                glyph.width,
                0
            ], fontMatrix);
            width = transformed[0] * fontSize + spacing;
            ctx.translate(width, 0);
            current.x += width * textHScale;
        }
        ctx.restore();
        this.processingType3 = null;
    }
    setCharWidth(xWidth, yWidth) {}
    setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
        this.ctx.rect(llx, lly, urx - llx, ury - lly);
        this.ctx.clip();
        this.endPath();
    }
    getColorN_Pattern(IR) {
        let pattern;
        if (IR[0] === "TilingPattern") {
            const color = IR[1];
            const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
            const canvasGraphicsFactory = {
                createCanvasGraphics: (ctx)=>new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                        optionalContentConfig: this.optionalContentConfig,
                        markedContentStack: this.markedContentStack
                    })
            };
            pattern = new TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
        } else pattern = this._getPattern(IR[1], IR[2]);
        return pattern;
    }
    setStrokeColorN() {
        this.current.strokeColor = this.getColorN_Pattern(arguments);
        this.current.patternStroke = true;
    }
    setFillColorN() {
        this.current.fillColor = this.getColorN_Pattern(arguments);
        this.current.patternFill = true;
    }
    setStrokeRGBColor(r, g, b) {
        this.ctx.strokeStyle = this.current.strokeColor = Util.makeHexColor(r, g, b);
        this.current.patternStroke = false;
    }
    setStrokeTransparent() {
        this.ctx.strokeStyle = this.current.strokeColor = "transparent";
        this.current.patternStroke = false;
    }
    setFillRGBColor(r, g, b) {
        this.ctx.fillStyle = this.current.fillColor = Util.makeHexColor(r, g, b);
        this.current.patternFill = false;
    }
    setFillTransparent() {
        this.ctx.fillStyle = this.current.fillColor = "transparent";
        this.current.patternFill = false;
    }
    _getPattern(objId, matrix = null) {
        let pattern;
        if (this.cachedPatterns.has(objId)) pattern = this.cachedPatterns.get(objId);
        else {
            pattern = getShadingPattern(this.getObject(objId));
            this.cachedPatterns.set(objId, pattern);
        }
        if (matrix) pattern.matrix = matrix;
        return pattern;
    }
    shadingFill(objId) {
        if (!this.contentVisible) return;
        const ctx = this.ctx;
        this.save();
        const pattern = this._getPattern(objId);
        ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);
        const inv = getCurrentTransformInverse(ctx);
        if (inv) {
            const { width, height } = ctx.canvas;
            const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox([
                0,
                0,
                width,
                height
            ], inv);
            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
        } else this.ctx.fillRect(-10000000000, -10000000000, 2e10, 2e10);
        this.compose(this.current.getClippedPathBoundingBox());
        this.restore();
    }
    beginInlineImage() {
        unreachable("Should not call beginInlineImage");
    }
    beginImageData() {
        unreachable("Should not call beginImageData");
    }
    paintFormXObjectBegin(matrix, bbox) {
        if (!this.contentVisible) return;
        this.save();
        this.baseTransformStack.push(this.baseTransform);
        if (matrix) this.transform(...matrix);
        this.baseTransform = getCurrentTransform(this.ctx);
        if (bbox) {
            const width = bbox[2] - bbox[0];
            const height = bbox[3] - bbox[1];
            this.ctx.rect(bbox[0], bbox[1], width, height);
            this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);
            this.clip();
            this.endPath();
        }
    }
    paintFormXObjectEnd() {
        if (!this.contentVisible) return;
        this.restore();
        this.baseTransform = this.baseTransformStack.pop();
    }
    beginGroup(group) {
        if (!this.contentVisible) return;
        this.save();
        if (this.inSMaskMode) {
            this.endSMaskMode();
            this.current.activeSMask = null;
        }
        const currentCtx = this.ctx;
        if (!group.isolated) info("TODO: Support non-isolated groups.");
        if (group.knockout) warn("Knockout groups not supported.");
        const currentTransform = getCurrentTransform(currentCtx);
        if (group.matrix) currentCtx.transform(...group.matrix);
        if (!group.bbox) throw new Error("Bounding box is required.");
        let bounds = Util.getAxialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx));
        const canvasBounds = [
            0,
            0,
            currentCtx.canvas.width,
            currentCtx.canvas.height
        ];
        bounds = Util.intersect(bounds, canvasBounds) || [
            0,
            0,
            0,
            0
        ];
        const offsetX = Math.floor(bounds[0]);
        const offsetY = Math.floor(bounds[1]);
        const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
        const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
        this.current.startNewPathAndClipBox([
            0,
            0,
            drawnWidth,
            drawnHeight
        ]);
        let cacheId = "groupAt" + this.groupLevel;
        if (group.smask) cacheId += "_smask_" + this.smaskCounter++ % 2;
        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
        const groupCtx = scratchCanvas.context;
        groupCtx.translate(-offsetX, -offsetY);
        groupCtx.transform(...currentTransform);
        if (group.smask) this.smaskStack.push({
            canvas: scratchCanvas.canvas,
            context: groupCtx,
            offsetX,
            offsetY,
            subtype: group.smask.subtype,
            backdrop: group.smask.backdrop,
            transferMap: group.smask.transferMap || null,
            startTransformInverse: null
        });
        else {
            currentCtx.setTransform(1, 0, 0, 1, 0, 0);
            currentCtx.translate(offsetX, offsetY);
            currentCtx.save();
        }
        copyCtxState(currentCtx, groupCtx);
        this.ctx = groupCtx;
        this.setGState([
            [
                "BM",
                "source-over"
            ],
            [
                "ca",
                1
            ],
            [
                "CA",
                1
            ]
        ]);
        this.groupStack.push(currentCtx);
        this.groupLevel++;
    }
    endGroup(group) {
        if (!this.contentVisible) return;
        this.groupLevel--;
        const groupCtx = this.ctx;
        const ctx = this.groupStack.pop();
        this.ctx = ctx;
        this.ctx.imageSmoothingEnabled = false;
        if (group.smask) {
            this.tempSMask = this.smaskStack.pop();
            this.restore();
        } else {
            this.ctx.restore();
            const currentMtx = getCurrentTransform(this.ctx);
            this.restore();
            this.ctx.save();
            this.ctx.setTransform(...currentMtx);
            const dirtyBox = Util.getAxialAlignedBoundingBox([
                0,
                0,
                groupCtx.canvas.width,
                groupCtx.canvas.height
            ], currentMtx);
            this.ctx.drawImage(groupCtx.canvas, 0, 0);
            this.ctx.restore();
            this.compose(dirtyBox);
        }
    }
    beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
        this.#restoreInitialState();
        resetCtxToDefault(this.ctx);
        this.ctx.save();
        this.save();
        if (this.baseTransform) this.ctx.setTransform(...this.baseTransform);
        if (rect) {
            const width = rect[2] - rect[0];
            const height = rect[3] - rect[1];
            if (hasOwnCanvas && this.annotationCanvasMap) {
                transform = transform.slice();
                transform[4] -= rect[0];
                transform[5] -= rect[1];
                rect = rect.slice();
                rect[0] = rect[1] = 0;
                rect[2] = width;
                rect[3] = height;
                const [scaleX, scaleY] = Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx));
                const { viewportScale } = this;
                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                const { canvas, context } = this.annotationCanvas;
                this.annotationCanvasMap.set(id, canvas);
                this.annotationCanvas.savedCtx = this.ctx;
                this.ctx = context;
                this.ctx.save();
                this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                resetCtxToDefault(this.ctx);
            } else {
                resetCtxToDefault(this.ctx);
                this.endPath();
                this.ctx.rect(rect[0], rect[1], width, height);
                this.ctx.clip();
                this.ctx.beginPath();
            }
        }
        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
        this.transform(...transform);
        this.transform(...matrix);
    }
    endAnnotation() {
        if (this.annotationCanvas) {
            this.ctx.restore();
            this.#drawFilter();
            this.ctx = this.annotationCanvas.savedCtx;
            delete this.annotationCanvas.savedCtx;
            delete this.annotationCanvas;
        }
    }
    paintImageMaskXObject(img) {
        if (!this.contentVisible) return;
        const count = img.count;
        img = this.getObject(img.data, img);
        img.count = count;
        const ctx = this.ctx;
        const glyph = this.processingType3;
        if (glyph) {
            if (glyph.compiled === undefined) glyph.compiled = compileType3Glyph(img);
            if (glyph.compiled) {
                glyph.compiled(ctx);
                return;
            }
        }
        const mask = this._createMaskCanvas(img);
        const maskCanvas = mask.canvas;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
        ctx.restore();
        this.compose();
    }
    paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
        if (!this.contentVisible) return;
        img = this.getObject(img.data, img);
        const ctx = this.ctx;
        ctx.save();
        const currentTransform = getCurrentTransform(ctx);
        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
        const mask = this._createMaskCanvas(img);
        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
        for(let i = 0, ii = positions.length; i < ii; i += 2){
            const trans = Util.transform(currentTransform, [
                scaleX,
                skewX,
                skewY,
                scaleY,
                positions[i],
                positions[i + 1]
            ]);
            const [x, y] = Util.applyTransform([
                0,
                0
            ], trans);
            ctx.drawImage(mask.canvas, x, y);
        }
        ctx.restore();
        this.compose();
    }
    paintImageMaskXObjectGroup(images) {
        if (!this.contentVisible) return;
        const ctx = this.ctx;
        const fillColor = this.current.fillColor;
        const isPatternFill = this.current.patternFill;
        for (const image of images){
            const { data, width, height, transform } = image;
            const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
            const maskCtx = maskCanvas.context;
            maskCtx.save();
            const img = this.getObject(data, image);
            putBinaryImageMask(maskCtx, img);
            maskCtx.globalCompositeOperation = "source-in";
            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;
            maskCtx.fillRect(0, 0, width, height);
            maskCtx.restore();
            ctx.save();
            ctx.transform(...transform);
            ctx.scale(1, -1);
            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
            ctx.restore();
        }
        this.compose();
    }
    paintImageXObject(objId) {
        if (!this.contentVisible) return;
        const imgData = this.getObject(objId);
        if (!imgData) {
            warn("Dependent image isn't ready yet");
            return;
        }
        this.paintInlineImageXObject(imgData);
    }
    paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
        if (!this.contentVisible) return;
        const imgData = this.getObject(objId);
        if (!imgData) {
            warn("Dependent image isn't ready yet");
            return;
        }
        const width = imgData.width;
        const height = imgData.height;
        const map = [];
        for(let i = 0, ii = positions.length; i < ii; i += 2)map.push({
            transform: [
                scaleX,
                0,
                0,
                scaleY,
                positions[i],
                positions[i + 1]
            ],
            x: 0,
            y: 0,
            w: width,
            h: height
        });
        this.paintInlineImageXObjectGroup(imgData, map);
    }
    applyTransferMapsToCanvas(ctx) {
        if (this.current.transferMaps !== "none") {
            ctx.filter = this.current.transferMaps;
            ctx.drawImage(ctx.canvas, 0, 0);
            ctx.filter = "none";
        }
        return ctx.canvas;
    }
    applyTransferMapsToBitmap(imgData) {
        if (this.current.transferMaps === "none") return imgData.bitmap;
        const { bitmap, width, height } = imgData;
        const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
        const tmpCtx = tmpCanvas.context;
        tmpCtx.filter = this.current.transferMaps;
        tmpCtx.drawImage(bitmap, 0, 0);
        tmpCtx.filter = "none";
        return tmpCanvas.canvas;
    }
    paintInlineImageXObject(imgData) {
        if (!this.contentVisible) return;
        const width = imgData.width;
        const height = imgData.height;
        const ctx = this.ctx;
        this.save();
        if (!isNodeJS) {
            const { filter } = ctx;
            if (filter !== "none" && filter !== "") ctx.filter = "none";
        }
        ctx.scale(1 / width, -1 / height);
        let imgToPaint;
        if (imgData.bitmap) imgToPaint = this.applyTransferMapsToBitmap(imgData);
        else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) imgToPaint = imgData;
        else {
            const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
            const tmpCtx = tmpCanvas.context;
            putBinaryImageData(tmpCtx, imgData);
            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
        }
        const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));
        ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);
        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
        this.compose();
        this.restore();
    }
    paintInlineImageXObjectGroup(imgData, map) {
        if (!this.contentVisible) return;
        const ctx = this.ctx;
        let imgToPaint;
        if (imgData.bitmap) imgToPaint = imgData.bitmap;
        else {
            const w = imgData.width;
            const h = imgData.height;
            const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
            const tmpCtx = tmpCanvas.context;
            putBinaryImageData(tmpCtx, imgData);
            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
        }
        for (const entry of map){
            ctx.save();
            ctx.transform(...entry.transform);
            ctx.scale(1, -1);
            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
            ctx.restore();
        }
        this.compose();
    }
    paintSolidColorImageMask() {
        if (!this.contentVisible) return;
        this.ctx.fillRect(0, 0, 1, 1);
        this.compose();
    }
    markPoint(tag) {}
    markPointProps(tag, properties) {}
    beginMarkedContent(tag) {
        this.markedContentStack.push({
            visible: true
        });
    }
    beginMarkedContentProps(tag, properties) {
        if (tag === "OC") this.markedContentStack.push({
            visible: this.optionalContentConfig.isVisible(properties)
        });
        else this.markedContentStack.push({
            visible: true
        });
        this.contentVisible = this.isContentVisible();
    }
    endMarkedContent() {
        this.markedContentStack.pop();
        this.contentVisible = this.isContentVisible();
    }
    beginCompat() {}
    endCompat() {}
    consumePath(clipBox) {
        const isEmpty = this.current.isEmptyClip();
        if (this.pendingClip) this.current.updateClipFromPath();
        if (!this.pendingClip) this.compose(clipBox);
        const ctx = this.ctx;
        if (this.pendingClip) {
            if (!isEmpty) {
                if (this.pendingClip === EO_CLIP) ctx.clip("evenodd");
                else ctx.clip();
            }
            this.pendingClip = null;
        }
        this.current.startNewPathAndClipBox(this.current.clipBox);
        ctx.beginPath();
    }
    getSinglePixelWidth() {
        if (!this._cachedGetSinglePixelWidth) {
            const m = getCurrentTransform(this.ctx);
            if (m[1] === 0 && m[2] === 0) this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
            else {
                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                const normX = Math.hypot(m[0], m[2]);
                const normY = Math.hypot(m[1], m[3]);
                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
            }
        }
        return this._cachedGetSinglePixelWidth;
    }
    getScaleForStroking() {
        if (this._cachedScaleForStroking[0] === -1) {
            const { lineWidth } = this.current;
            const { a, b, c, d } = this.ctx.getTransform();
            let scaleX, scaleY;
            if (b === 0 && c === 0) {
                const normX = Math.abs(a);
                const normY = Math.abs(d);
                if (normX === normY) {
                    if (lineWidth === 0) scaleX = scaleY = 1 / normX;
                    else {
                        const scaledLineWidth = normX * lineWidth;
                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
                    }
                } else if (lineWidth === 0) {
                    scaleX = 1 / normX;
                    scaleY = 1 / normY;
                } else {
                    const scaledXLineWidth = normX * lineWidth;
                    const scaledYLineWidth = normY * lineWidth;
                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                }
            } else {
                const absDet = Math.abs(a * d - b * c);
                const normX = Math.hypot(a, b);
                const normY = Math.hypot(c, d);
                if (lineWidth === 0) {
                    scaleX = normY / absDet;
                    scaleY = normX / absDet;
                } else {
                    const baseArea = lineWidth * absDet;
                    scaleX = normY > baseArea ? normY / baseArea : 1;
                    scaleY = normX > baseArea ? normX / baseArea : 1;
                }
            }
            this._cachedScaleForStroking[0] = scaleX;
            this._cachedScaleForStroking[1] = scaleY;
        }
        return this._cachedScaleForStroking;
    }
    rescaleAndStroke(saveRestore) {
        const { ctx } = this;
        const { lineWidth } = this.current;
        const [scaleX, scaleY] = this.getScaleForStroking();
        ctx.lineWidth = lineWidth || 1;
        if (scaleX === 1 && scaleY === 1) {
            ctx.stroke();
            return;
        }
        const dashes = ctx.getLineDash();
        if (saveRestore) ctx.save();
        ctx.scale(scaleX, scaleY);
        if (dashes.length > 0) {
            const scale = Math.max(scaleX, scaleY);
            ctx.setLineDash(dashes.map((x)=>x / scale));
            ctx.lineDashOffset /= scale;
        }
        ctx.stroke();
        if (saveRestore) ctx.restore();
    }
    isContentVisible() {
        for(let i = this.markedContentStack.length - 1; i >= 0; i--){
            if (!this.markedContentStack[i].visible) return false;
        }
        return true;
    }
}
for(const op in OPS)if (CanvasGraphics.prototype[op] !== undefined) CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
class GlobalWorkerOptions {
    static #port = null;
    static #src = "";
    static get workerPort() {
        return this.#port;
    }
    static set workerPort(val) {
        if (!(typeof Worker !== "undefined" && val instanceof Worker) && val !== null) throw new Error("Invalid `workerPort` type.");
        this.#port = val;
    }
    static get workerSrc() {
        return this.#src;
    }
    static set workerSrc(val) {
        if (typeof val !== "string") throw new Error("Invalid `workerSrc` type.");
        this.#src = val;
    }
}
class Metadata {
    #metadataMap;
    #data;
    constructor({ parsedData, rawData }){
        this.#metadataMap = parsedData;
        this.#data = rawData;
    }
    getRaw() {
        return this.#data;
    }
    get(name) {
        return this.#metadataMap.get(name) ?? null;
    }
    getAll() {
        return objectFromMap(this.#metadataMap);
    }
    has(name) {
        return this.#metadataMap.has(name);
    }
}
const INTERNAL = Symbol("INTERNAL");
class OptionalContentGroup {
    #isDisplay = false;
    #isPrint = false;
    #userSet = false;
    #visible = true;
    constructor(renderingIntent, { name, intent, usage, rbGroups }){
        this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);
        this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
        this.name = name;
        this.intent = intent;
        this.usage = usage;
        this.rbGroups = rbGroups;
    }
    get visible() {
        if (this.#userSet) return this.#visible;
        if (!this.#visible) return false;
        const { print, view } = this.usage;
        if (this.#isDisplay) return view?.viewState !== "OFF";
        else if (this.#isPrint) return print?.printState !== "OFF";
        return true;
    }
    _setVisible(internal, visible, userSet = false) {
        if (internal !== INTERNAL) unreachable("Internal method `_setVisible` called.");
        this.#userSet = userSet;
        this.#visible = visible;
    }
}
class OptionalContentConfig {
    #cachedGetHash = null;
    #groups = new Map();
    #initialHash = null;
    #order = null;
    constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY){
        this.renderingIntent = renderingIntent;
        this.name = null;
        this.creator = null;
        if (data === null) return;
        this.name = data.name;
        this.creator = data.creator;
        this.#order = data.order;
        for (const group of data.groups)this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));
        if (data.baseState === "OFF") for (const group of this.#groups.values())group._setVisible(INTERNAL, false);
        for (const on of data.on)this.#groups.get(on)._setVisible(INTERNAL, true);
        for (const off of data.off)this.#groups.get(off)._setVisible(INTERNAL, false);
        this.#initialHash = this.getHash();
    }
    #evaluateVisibilityExpression(array) {
        const length = array.length;
        if (length < 2) return true;
        const operator = array[0];
        for(let i = 1; i < length; i++){
            const element = array[i];
            let state;
            if (Array.isArray(element)) state = this.#evaluateVisibilityExpression(element);
            else if (this.#groups.has(element)) state = this.#groups.get(element).visible;
            else {
                warn(`Optional content group not found: ${element}`);
                return true;
            }
            switch(operator){
                case "And":
                    if (!state) return false;
                    break;
                case "Or":
                    if (state) return true;
                    break;
                case "Not":
                    return !state;
                default:
                    return true;
            }
        }
        return operator === "And";
    }
    isVisible(group) {
        if (this.#groups.size === 0) return true;
        if (!group) {
            info("Optional content group not defined.");
            return true;
        }
        if (group.type === "OCG") {
            if (!this.#groups.has(group.id)) {
                warn(`Optional content group not found: ${group.id}`);
                return true;
            }
            return this.#groups.get(group.id).visible;
        } else if (group.type === "OCMD") {
            if (group.expression) return this.#evaluateVisibilityExpression(group.expression);
            if (!group.policy || group.policy === "AnyOn") {
                for (const id of group.ids){
                    if (!this.#groups.has(id)) {
                        warn(`Optional content group not found: ${id}`);
                        return true;
                    }
                    if (this.#groups.get(id).visible) return true;
                }
                return false;
            } else if (group.policy === "AllOn") {
                for (const id of group.ids){
                    if (!this.#groups.has(id)) {
                        warn(`Optional content group not found: ${id}`);
                        return true;
                    }
                    if (!this.#groups.get(id).visible) return false;
                }
                return true;
            } else if (group.policy === "AnyOff") {
                for (const id of group.ids){
                    if (!this.#groups.has(id)) {
                        warn(`Optional content group not found: ${id}`);
                        return true;
                    }
                    if (!this.#groups.get(id).visible) return true;
                }
                return false;
            } else if (group.policy === "AllOff") {
                for (const id of group.ids){
                    if (!this.#groups.has(id)) {
                        warn(`Optional content group not found: ${id}`);
                        return true;
                    }
                    if (this.#groups.get(id).visible) return false;
                }
                return true;
            }
            warn(`Unknown optional content policy ${group.policy}.`);
            return true;
        }
        warn(`Unknown group type ${group.type}.`);
        return true;
    }
    setVisibility(id, visible = true, preserveRB = true) {
        const group = this.#groups.get(id);
        if (!group) {
            warn(`Optional content group not found: ${id}`);
            return;
        }
        if (preserveRB && visible && group.rbGroups.length) for (const rbGroup of group.rbGroups){
            for (const otherId of rbGroup)if (otherId !== id) this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);
        }
        group._setVisible(INTERNAL, !!visible, true);
        this.#cachedGetHash = null;
    }
    setOCGState({ state, preserveRB }) {
        let operator;
        for (const elem of state){
            switch(elem){
                case "ON":
                case "OFF":
                case "Toggle":
                    operator = elem;
                    continue;
            }
            const group = this.#groups.get(elem);
            if (!group) continue;
            switch(operator){
                case "ON":
                    this.setVisibility(elem, true, preserveRB);
                    break;
                case "OFF":
                    this.setVisibility(elem, false, preserveRB);
                    break;
                case "Toggle":
                    this.setVisibility(elem, !group.visible, preserveRB);
                    break;
            }
        }
        this.#cachedGetHash = null;
    }
    get hasInitialVisibility() {
        return this.#initialHash === null || this.getHash() === this.#initialHash;
    }
    getOrder() {
        if (!this.#groups.size) return null;
        if (this.#order) return this.#order.slice();
        return [
            ...this.#groups.keys()
        ];
    }
    getGroups() {
        return this.#groups.size > 0 ? objectFromMap(this.#groups) : null;
    }
    getGroup(id) {
        return this.#groups.get(id) || null;
    }
    getHash() {
        if (this.#cachedGetHash !== null) return this.#cachedGetHash;
        const hash = new MurmurHash3_64();
        for (const [id, group] of this.#groups)hash.update(`${id}:${group.visible}`);
        return this.#cachedGetHash = hash.hexdigest();
    }
}
class PDFDataTransportStream {
    constructor(pdfDataRangeTransport, { disableRange = false, disableStream = false }){
        assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
        const { length, initialData, progressiveDone, contentDispositionFilename } = pdfDataRangeTransport;
        this._queuedChunks = [];
        this._progressiveDone = progressiveDone;
        this._contentDispositionFilename = contentDispositionFilename;
        if (initialData?.length > 0) {
            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
            this._queuedChunks.push(buffer);
        }
        this._pdfDataRangeTransport = pdfDataRangeTransport;
        this._isStreamingSupported = !disableStream;
        this._isRangeSupported = !disableRange;
        this._contentLength = length;
        this._fullRequestReader = null;
        this._rangeReaders = [];
        pdfDataRangeTransport.addRangeListener((begin, chunk)=>{
            this._onReceiveData({
                begin,
                chunk
            });
        });
        pdfDataRangeTransport.addProgressListener((loaded, total)=>{
            this._onProgress({
                loaded,
                total
            });
        });
        pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{
            this._onReceiveData({
                chunk
            });
        });
        pdfDataRangeTransport.addProgressiveDoneListener(()=>{
            this._onProgressiveDone();
        });
        pdfDataRangeTransport.transportReady();
    }
    _onReceiveData({ begin, chunk }) {
        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
        if (begin === undefined) {
            if (this._fullRequestReader) this._fullRequestReader._enqueue(buffer);
            else this._queuedChunks.push(buffer);
        } else {
            const found = this._rangeReaders.some(function(rangeReader) {
                if (rangeReader._begin !== begin) return false;
                rangeReader._enqueue(buffer);
                return true;
            });
            assert(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
        }
    }
    get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
    }
    _onProgress(evt) {
        if (evt.total === undefined) this._rangeReaders[0]?.onProgress?.({
            loaded: evt.loaded
        });
        else this._fullRequestReader?.onProgress?.({
            loaded: evt.loaded,
            total: evt.total
        });
    }
    _onProgressiveDone() {
        this._fullRequestReader?.progressiveDone();
        this._progressiveDone = true;
    }
    _removeRangeReader(reader) {
        const i = this._rangeReaders.indexOf(reader);
        if (i >= 0) this._rangeReaders.splice(i, 1);
    }
    getFullReader() {
        assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
        const queuedChunks = this._queuedChunks;
        this._queuedChunks = null;
        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
    }
    getRangeReader(begin, end) {
        if (end <= this._progressiveDataLength) return null;
        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
        this._pdfDataRangeTransport.requestDataRange(begin, end);
        this._rangeReaders.push(reader);
        return reader;
    }
    cancelAllRequests(reason) {
        this._fullRequestReader?.cancel(reason);
        for (const reader of this._rangeReaders.slice(0))reader.cancel(reason);
        this._pdfDataRangeTransport.abort();
    }
}
class PDFDataTransportStreamReader {
    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){
        this._stream = stream;
        this._done = progressiveDone || false;
        this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;
        this._queuedChunks = queuedChunks || [];
        this._loaded = 0;
        for (const chunk of this._queuedChunks)this._loaded += chunk.byteLength;
        this._requests = [];
        this._headersReady = Promise.resolve();
        stream._fullRequestReader = this;
        this.onProgress = null;
    }
    _enqueue(chunk) {
        if (this._done) return;
        if (this._requests.length > 0) {
            const requestCapability = this._requests.shift();
            requestCapability.resolve({
                value: chunk,
                done: false
            });
        } else this._queuedChunks.push(chunk);
        this._loaded += chunk.byteLength;
    }
    get headersReady() {
        return this._headersReady;
    }
    get filename() {
        return this._filename;
    }
    get isRangeSupported() {
        return this._stream._isRangeSupported;
    }
    get isStreamingSupported() {
        return this._stream._isStreamingSupported;
    }
    get contentLength() {
        return this._stream._contentLength;
    }
    async read() {
        if (this._queuedChunks.length > 0) {
            const chunk = this._queuedChunks.shift();
            return {
                value: chunk,
                done: false
            };
        }
        if (this._done) return {
            value: undefined,
            done: true
        };
        const requestCapability = Promise.withResolvers();
        this._requests.push(requestCapability);
        return requestCapability.promise;
    }
    cancel(reason) {
        this._done = true;
        for (const requestCapability of this._requests)requestCapability.resolve({
            value: undefined,
            done: true
        });
        this._requests.length = 0;
    }
    progressiveDone() {
        if (this._done) return;
        this._done = true;
    }
}
class PDFDataTransportStreamRangeReader {
    constructor(stream, begin, end){
        this._stream = stream;
        this._begin = begin;
        this._end = end;
        this._queuedChunk = null;
        this._requests = [];
        this._done = false;
        this.onProgress = null;
    }
    _enqueue(chunk) {
        if (this._done) return;
        if (this._requests.length === 0) this._queuedChunk = chunk;
        else {
            const requestsCapability = this._requests.shift();
            requestsCapability.resolve({
                value: chunk,
                done: false
            });
            for (const requestCapability of this._requests)requestCapability.resolve({
                value: undefined,
                done: true
            });
            this._requests.length = 0;
        }
        this._done = true;
        this._stream._removeRangeReader(this);
    }
    get isStreamingSupported() {
        return false;
    }
    async read() {
        if (this._queuedChunk) {
            const chunk = this._queuedChunk;
            this._queuedChunk = null;
            return {
                value: chunk,
                done: false
            };
        }
        if (this._done) return {
            value: undefined,
            done: true
        };
        const requestCapability = Promise.withResolvers();
        this._requests.push(requestCapability);
        return requestCapability.promise;
    }
    cancel(reason) {
        this._done = true;
        for (const requestCapability of this._requests)requestCapability.resolve({
            value: undefined,
            done: true
        });
        this._requests.length = 0;
        this._stream._removeRangeReader(this);
    }
}
function getFilenameFromContentDispositionHeader(contentDisposition) {
    let needsEncodingFixup = true;
    let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
    if (tmp) {
        tmp = tmp[1];
        let filename = rfc2616unquote(tmp);
        filename = unescape(filename);
        filename = rfc5987decode(filename);
        filename = rfc2047decode(filename);
        return fixupEncoding(filename);
    }
    tmp = rfc2231getparam(contentDisposition);
    if (tmp) {
        const filename = rfc2047decode(tmp);
        return fixupEncoding(filename);
    }
    tmp = toParamRegExp("filename", "i").exec(contentDisposition);
    if (tmp) {
        tmp = tmp[1];
        let filename = rfc2616unquote(tmp);
        filename = rfc2047decode(filename);
        return fixupEncoding(filename);
    }
    function toParamRegExp(attributePattern, flags) {
        return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
    }
    function textdecode(encoding, value) {
        if (encoding) {
            if (!/^[\x00-\xFF]+$/.test(value)) return value;
            try {
                const decoder = new TextDecoder(encoding, {
                    fatal: true
                });
                const buffer = stringToBytes(value);
                value = decoder.decode(buffer);
                needsEncodingFixup = false;
            } catch  {}
        }
        return value;
    }
    function fixupEncoding(value) {
        if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
            value = textdecode("utf-8", value);
            if (needsEncodingFixup) value = textdecode("iso-8859-1", value);
        }
        return value;
    }
    function rfc2231getparam(contentDispositionStr) {
        const matches = [];
        let match;
        const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
        while((match = iter.exec(contentDispositionStr)) !== null){
            let [, n, quot, part] = match;
            n = parseInt(n, 10);
            if (n in matches) {
                if (n === 0) break;
                continue;
            }
            matches[n] = [
                quot,
                part
            ];
        }
        const parts = [];
        for(let n = 0; n < matches.length; ++n){
            if (!(n in matches)) break;
            let [quot, part] = matches[n];
            part = rfc2616unquote(part);
            if (quot) {
                part = unescape(part);
                if (n === 0) part = rfc5987decode(part);
            }
            parts.push(part);
        }
        return parts.join("");
    }
    function rfc2616unquote(value) {
        if (value.startsWith('"')) {
            const parts = value.slice(1).split('\\"');
            for(let i = 0; i < parts.length; ++i){
                const quotindex = parts[i].indexOf('"');
                if (quotindex !== -1) {
                    parts[i] = parts[i].slice(0, quotindex);
                    parts.length = i + 1;
                }
                parts[i] = parts[i].replaceAll(/\\(.)/g, "$1");
            }
            value = parts.join('"');
        }
        return value;
    }
    function rfc5987decode(extvalue) {
        const encodingend = extvalue.indexOf("'");
        if (encodingend === -1) return extvalue;
        const encoding = extvalue.slice(0, encodingend);
        const langvalue = extvalue.slice(encodingend + 1);
        const value = langvalue.replace(/^[^']*'/, "");
        return textdecode(encoding, value);
    }
    function rfc2047decode(value) {
        if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) return value;
        return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
            if (encoding === "q" || encoding === "Q") {
                text = text.replaceAll("_", " ");
                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                    return String.fromCharCode(parseInt(hex, 16));
                });
                return textdecode(charset, text);
            }
            try {
                text = atob(text);
            } catch  {}
            return textdecode(charset, text);
        });
    }
    return "";
}
function createHeaders(isHttp, httpHeaders) {
    const headers = new Headers();
    if (!isHttp || !httpHeaders || typeof httpHeaders !== "object") return headers;
    for(const key in httpHeaders){
        const val = httpHeaders[key];
        if (val !== undefined) headers.append(key, val);
    }
    return headers;
}
function getResponseOrigin(url) {
    try {
        return new URL(url).origin;
    } catch  {}
    return null;
}
function validateRangeRequestCapabilities({ responseHeaders, isHttp, rangeChunkSize, disableRange }) {
    const returnValues = {
        allowRangeRequests: false,
        suggestedLength: undefined
    };
    const length = parseInt(responseHeaders.get("Content-Length"), 10);
    if (!Number.isInteger(length)) return returnValues;
    returnValues.suggestedLength = length;
    if (length <= 2 * rangeChunkSize) return returnValues;
    if (disableRange || !isHttp) return returnValues;
    if (responseHeaders.get("Accept-Ranges") !== "bytes") return returnValues;
    const contentEncoding = responseHeaders.get("Content-Encoding") || "identity";
    if (contentEncoding !== "identity") return returnValues;
    returnValues.allowRangeRequests = true;
    return returnValues;
}
function extractFilenameFromHeader(responseHeaders) {
    const contentDisposition = responseHeaders.get("Content-Disposition");
    if (contentDisposition) {
        let filename = getFilenameFromContentDispositionHeader(contentDisposition);
        if (filename.includes("%")) try {
            filename = decodeURIComponent(filename);
        } catch  {}
        if (isPdfFile(filename)) return filename;
    }
    return null;
}
function createResponseStatusError(status, url) {
    if (status === 404 || status === 0 && url.startsWith("file:")) return new MissingPDFException('Missing PDF "' + url + '".');
    return new UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
}
function validateResponseStatus(status) {
    return status === 200 || status === 206;
}
function createFetchOptions(headers, withCredentials, abortController) {
    return {
        method: "GET",
        headers,
        signal: abortController.signal,
        mode: "cors",
        credentials: withCredentials ? "include" : "same-origin",
        redirect: "follow"
    };
}
function getArrayBuffer(val) {
    if (val instanceof Uint8Array) return val.buffer;
    if (val instanceof ArrayBuffer) return val;
    warn(`getArrayBuffer - unexpected data format: ${val}`);
    return new Uint8Array(val).buffer;
}
class PDFFetchStream {
    _responseOrigin = null;
    constructor(source){
        this.source = source;
        this.isHttp = /^https?:/i.test(source.url);
        this.headers = createHeaders(this.isHttp, source.httpHeaders);
        this._fullRequestReader = null;
        this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
    }
    getFullReader() {
        assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
        this._fullRequestReader = new PDFFetchStreamReader(this);
        return this._fullRequestReader;
    }
    getRangeReader(begin, end) {
        if (end <= this._progressiveDataLength) return null;
        const reader = new PDFFetchStreamRangeReader(this, begin, end);
        this._rangeRequestReaders.push(reader);
        return reader;
    }
    cancelAllRequests(reason) {
        this._fullRequestReader?.cancel(reason);
        for (const reader of this._rangeRequestReaders.slice(0))reader.cancel(reason);
    }
}
class PDFFetchStreamReader {
    constructor(stream){
        this._stream = stream;
        this._reader = null;
        this._loaded = 0;
        this._filename = null;
        const source = stream.source;
        this._withCredentials = source.withCredentials || false;
        this._contentLength = source.length;
        this._headersCapability = Promise.withResolvers();
        this._disableRange = source.disableRange || false;
        this._rangeChunkSize = source.rangeChunkSize;
        if (!this._rangeChunkSize && !this._disableRange) this._disableRange = true;
        this._abortController = new AbortController();
        this._isStreamingSupported = !source.disableStream;
        this._isRangeSupported = !source.disableRange;
        const headers = new Headers(stream.headers);
        const url = source.url;
        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{
            stream._responseOrigin = getResponseOrigin(response.url);
            if (!validateResponseStatus(response.status)) throw createResponseStatusError(response.status, url);
            this._reader = response.body.getReader();
            this._headersCapability.resolve();
            const responseHeaders = response.headers;
            const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({
                responseHeaders,
                isHttp: stream.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
            });
            this._isRangeSupported = allowRangeRequests;
            this._contentLength = suggestedLength || this._contentLength;
            this._filename = extractFilenameFromHeader(responseHeaders);
            if (!this._isStreamingSupported && this._isRangeSupported) this.cancel(new AbortException("Streaming is disabled."));
        }).catch(this._headersCapability.reject);
        this.onProgress = null;
    }
    get headersReady() {
        return this._headersCapability.promise;
    }
    get filename() {
        return this._filename;
    }
    get contentLength() {
        return this._contentLength;
    }
    get isRangeSupported() {
        return this._isRangeSupported;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    async read() {
        await this._headersCapability.promise;
        const { value, done } = await this._reader.read();
        if (done) return {
            value,
            done
        };
        this._loaded += value.byteLength;
        this.onProgress?.({
            loaded: this._loaded,
            total: this._contentLength
        });
        return {
            value: getArrayBuffer(value),
            done: false
        };
    }
    cancel(reason) {
        this._reader?.cancel(reason);
        this._abortController.abort();
    }
}
class PDFFetchStreamRangeReader {
    constructor(stream, begin, end){
        this._stream = stream;
        this._reader = null;
        this._loaded = 0;
        const source = stream.source;
        this._withCredentials = source.withCredentials || false;
        this._readCapability = Promise.withResolvers();
        this._isStreamingSupported = !source.disableStream;
        this._abortController = new AbortController();
        const headers = new Headers(stream.headers);
        headers.append("Range", `bytes=${begin}-${end - 1}`);
        const url = source.url;
        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{
            const responseOrigin = getResponseOrigin(response.url);
            if (responseOrigin !== stream._responseOrigin) throw new Error(`Expected range response-origin "${responseOrigin}" to match "${stream._responseOrigin}".`);
            if (!validateResponseStatus(response.status)) throw createResponseStatusError(response.status, url);
            this._readCapability.resolve();
            this._reader = response.body.getReader();
        }).catch(this._readCapability.reject);
        this.onProgress = null;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    async read() {
        await this._readCapability.promise;
        const { value, done } = await this._reader.read();
        if (done) return {
            value,
            done
        };
        this._loaded += value.byteLength;
        this.onProgress?.({
            loaded: this._loaded
        });
        return {
            value: getArrayBuffer(value),
            done: false
        };
    }
    cancel(reason) {
        this._reader?.cancel(reason);
        this._abortController.abort();
    }
}
const OK_RESPONSE = 200;
const PARTIAL_CONTENT_RESPONSE = 206;
function network_getArrayBuffer(xhr) {
    const data = xhr.response;
    if (typeof data !== "string") return data;
    return stringToBytes(data).buffer;
}
class NetworkManager {
    _responseOrigin = null;
    constructor({ url, httpHeaders, withCredentials }){
        this.url = url;
        this.isHttp = /^https?:/i.test(url);
        this.headers = createHeaders(this.isHttp, httpHeaders);
        this.withCredentials = withCredentials || false;
        this.currXhrId = 0;
        this.pendingRequests = Object.create(null);
    }
    request(args) {
        const xhr = new XMLHttpRequest();
        const xhrId = this.currXhrId++;
        const pendingRequest = this.pendingRequests[xhrId] = {
            xhr
        };
        xhr.open("GET", this.url);
        xhr.withCredentials = this.withCredentials;
        for (const [key, val] of this.headers)xhr.setRequestHeader(key, val);
        if (this.isHttp && "begin" in args && "end" in args) {
            xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
        } else pendingRequest.expectedStatus = OK_RESPONSE;
        xhr.responseType = "arraybuffer";
        assert(args.onError, "Expected `onError` callback to be provided.");
        xhr.onerror = ()=>{
            args.onError(xhr.status);
        };
        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
        xhr.onprogress = this.onProgress.bind(this, xhrId);
        pendingRequest.onHeadersReceived = args.onHeadersReceived;
        pendingRequest.onDone = args.onDone;
        pendingRequest.onError = args.onError;
        pendingRequest.onProgress = args.onProgress;
        xhr.send(null);
        return xhrId;
    }
    onProgress(xhrId, evt) {
        const pendingRequest = this.pendingRequests[xhrId];
        if (!pendingRequest) return;
        pendingRequest.onProgress?.(evt);
    }
    onStateChange(xhrId, evt) {
        const pendingRequest = this.pendingRequests[xhrId];
        if (!pendingRequest) return;
        const xhr = pendingRequest.xhr;
        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
            pendingRequest.onHeadersReceived();
            delete pendingRequest.onHeadersReceived;
        }
        if (xhr.readyState !== 4) return;
        if (!(xhrId in this.pendingRequests)) return;
        delete this.pendingRequests[xhrId];
        if (xhr.status === 0 && this.isHttp) {
            pendingRequest.onError(xhr.status);
            return;
        }
        const xhrStatus = xhr.status || OK_RESPONSE;
        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
            pendingRequest.onError(xhr.status);
            return;
        }
        const chunk = network_getArrayBuffer(xhr);
        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
            const rangeHeader = xhr.getResponseHeader("Content-Range");
            const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
            if (matches) pendingRequest.onDone({
                begin: parseInt(matches[1], 10),
                chunk
            });
            else {
                warn(`Missing or invalid "Content-Range" header.`);
                pendingRequest.onError(0);
            }
        } else if (chunk) pendingRequest.onDone({
            begin: 0,
            chunk
        });
        else pendingRequest.onError(xhr.status);
    }
    getRequestXhr(xhrId) {
        return this.pendingRequests[xhrId].xhr;
    }
    isPendingRequest(xhrId) {
        return xhrId in this.pendingRequests;
    }
    abortRequest(xhrId) {
        const xhr = this.pendingRequests[xhrId].xhr;
        delete this.pendingRequests[xhrId];
        xhr.abort();
    }
}
class PDFNetworkStream {
    constructor(source){
        this._source = source;
        this._manager = new NetworkManager(source);
        this._rangeChunkSize = source.rangeChunkSize;
        this._fullRequestReader = null;
        this._rangeRequestReaders = [];
    }
    _onRangeRequestReaderClosed(reader) {
        const i = this._rangeRequestReaders.indexOf(reader);
        if (i >= 0) this._rangeRequestReaders.splice(i, 1);
    }
    getFullReader() {
        assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
        return this._fullRequestReader;
    }
    getRangeReader(begin, end) {
        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
        this._rangeRequestReaders.push(reader);
        return reader;
    }
    cancelAllRequests(reason) {
        this._fullRequestReader?.cancel(reason);
        for (const reader of this._rangeRequestReaders.slice(0))reader.cancel(reason);
    }
}
class PDFNetworkStreamFullRequestReader {
    constructor(manager, source){
        this._manager = manager;
        this._url = source.url;
        this._fullRequestId = manager.request({
            onHeadersReceived: this._onHeadersReceived.bind(this),
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this)
        });
        this._headersCapability = Promise.withResolvers();
        this._disableRange = source.disableRange || false;
        this._contentLength = source.length;
        this._rangeChunkSize = source.rangeChunkSize;
        if (!this._rangeChunkSize && !this._disableRange) this._disableRange = true;
        this._isStreamingSupported = false;
        this._isRangeSupported = false;
        this._cachedChunks = [];
        this._requests = [];
        this._done = false;
        this._storedError = undefined;
        this._filename = null;
        this.onProgress = null;
    }
    _onHeadersReceived() {
        const fullRequestXhrId = this._fullRequestId;
        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
        this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);
        const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();
        const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((x)=>{
            const [key, ...val] = x.split(": ");
            return [
                key,
                val.join(": ")
            ];
        }) : []);
        const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({
            responseHeaders,
            isHttp: this._manager.isHttp,
            rangeChunkSize: this._rangeChunkSize,
            disableRange: this._disableRange
        });
        if (allowRangeRequests) this._isRangeSupported = true;
        this._contentLength = suggestedLength || this._contentLength;
        this._filename = extractFilenameFromHeader(responseHeaders);
        if (this._isRangeSupported) this._manager.abortRequest(fullRequestXhrId);
        this._headersCapability.resolve();
    }
    _onDone(data) {
        if (data) {
            if (this._requests.length > 0) {
                const requestCapability = this._requests.shift();
                requestCapability.resolve({
                    value: data.chunk,
                    done: false
                });
            } else this._cachedChunks.push(data.chunk);
        }
        this._done = true;
        if (this._cachedChunks.length > 0) return;
        for (const requestCapability of this._requests)requestCapability.resolve({
            value: undefined,
            done: true
        });
        this._requests.length = 0;
    }
    _onError(status) {
        this._storedError = createResponseStatusError(status, this._url);
        this._headersCapability.reject(this._storedError);
        for (const requestCapability of this._requests)requestCapability.reject(this._storedError);
        this._requests.length = 0;
        this._cachedChunks.length = 0;
    }
    _onProgress(evt) {
        this.onProgress?.({
            loaded: evt.loaded,
            total: evt.lengthComputable ? evt.total : this._contentLength
        });
    }
    get filename() {
        return this._filename;
    }
    get isRangeSupported() {
        return this._isRangeSupported;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    get contentLength() {
        return this._contentLength;
    }
    get headersReady() {
        return this._headersCapability.promise;
    }
    async read() {
        await this._headersCapability.promise;
        if (this._storedError) throw this._storedError;
        if (this._cachedChunks.length > 0) {
            const chunk = this._cachedChunks.shift();
            return {
                value: chunk,
                done: false
            };
        }
        if (this._done) return {
            value: undefined,
            done: true
        };
        const requestCapability = Promise.withResolvers();
        this._requests.push(requestCapability);
        return requestCapability.promise;
    }
    cancel(reason) {
        this._done = true;
        this._headersCapability.reject(reason);
        for (const requestCapability of this._requests)requestCapability.resolve({
            value: undefined,
            done: true
        });
        this._requests.length = 0;
        if (this._manager.isPendingRequest(this._fullRequestId)) this._manager.abortRequest(this._fullRequestId);
        this._fullRequestReader = null;
    }
}
class PDFNetworkStreamRangeRequestReader {
    constructor(manager, begin, end){
        this._manager = manager;
        this._url = manager.url;
        this._requestId = manager.request({
            begin,
            end,
            onHeadersReceived: this._onHeadersReceived.bind(this),
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this)
        });
        this._requests = [];
        this._queuedChunk = null;
        this._done = false;
        this._storedError = undefined;
        this.onProgress = null;
        this.onClosed = null;
    }
    _onHeadersReceived() {
        const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);
        if (responseOrigin !== this._manager._responseOrigin) {
            this._storedError = new Error(`Expected range response-origin "${responseOrigin}" to match "${this._manager._responseOrigin}".`);
            this._onError(0);
        }
    }
    _close() {
        this.onClosed?.(this);
    }
    _onDone(data) {
        const chunk = data.chunk;
        if (this._requests.length > 0) {
            const requestCapability = this._requests.shift();
            requestCapability.resolve({
                value: chunk,
                done: false
            });
        } else this._queuedChunk = chunk;
        this._done = true;
        for (const requestCapability of this._requests)requestCapability.resolve({
            value: undefined,
            done: true
        });
        this._requests.length = 0;
        this._close();
    }
    _onError(status) {
        this._storedError ??= createResponseStatusError(status, this._url);
        for (const requestCapability of this._requests)requestCapability.reject(this._storedError);
        this._requests.length = 0;
        this._queuedChunk = null;
    }
    _onProgress(evt) {
        if (!this.isStreamingSupported) this.onProgress?.({
            loaded: evt.loaded
        });
    }
    get isStreamingSupported() {
        return false;
    }
    async read() {
        if (this._storedError) throw this._storedError;
        if (this._queuedChunk !== null) {
            const chunk = this._queuedChunk;
            this._queuedChunk = null;
            return {
                value: chunk,
                done: false
            };
        }
        if (this._done) return {
            value: undefined,
            done: true
        };
        const requestCapability = Promise.withResolvers();
        this._requests.push(requestCapability);
        return requestCapability.promise;
    }
    cancel(reason) {
        this._done = true;
        for (const requestCapability of this._requests)requestCapability.resolve({
            value: undefined,
            done: true
        });
        this._requests.length = 0;
        if (this._manager.isPendingRequest(this._requestId)) this._manager.abortRequest(this._requestId);
        this._close();
    }
}
const urlRegex = /^[a-z][a-z0-9\-+.]+:/i;
function parseUrlOrPath(sourceUrl) {
    if (urlRegex.test(sourceUrl)) return new URL(sourceUrl);
    const url = process.getBuiltinModule("url");
    return new URL(url.pathToFileURL(sourceUrl));
}
class PDFNodeStream {
    constructor(source){
        this.source = source;
        this.url = parseUrlOrPath(source.url);
        assert(this.url.protocol === "file:", "PDFNodeStream only supports file:// URLs.");
        this._fullRequestReader = null;
        this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
    }
    getFullReader() {
        assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
        this._fullRequestReader = new PDFNodeStreamFsFullReader(this);
        return this._fullRequestReader;
    }
    getRangeReader(start, end) {
        if (end <= this._progressiveDataLength) return null;
        const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);
        this._rangeRequestReaders.push(rangeReader);
        return rangeReader;
    }
    cancelAllRequests(reason) {
        this._fullRequestReader?.cancel(reason);
        for (const reader of this._rangeRequestReaders.slice(0))reader.cancel(reason);
    }
}
class PDFNodeStreamFsFullReader {
    constructor(stream){
        this._url = stream.url;
        this._done = false;
        this._storedError = null;
        this.onProgress = null;
        const source = stream.source;
        this._contentLength = source.length;
        this._loaded = 0;
        this._filename = null;
        this._disableRange = source.disableRange || false;
        this._rangeChunkSize = source.rangeChunkSize;
        if (!this._rangeChunkSize && !this._disableRange) this._disableRange = true;
        this._isStreamingSupported = !source.disableStream;
        this._isRangeSupported = !source.disableRange;
        this._readableStream = null;
        this._readCapability = Promise.withResolvers();
        this._headersCapability = Promise.withResolvers();
        const fs = process.getBuiltinModule("fs");
        fs.promises.lstat(this._url).then((stat)=>{
            this._contentLength = stat.size;
            this._setReadableStream(fs.createReadStream(this._url));
            this._headersCapability.resolve();
        }, (error)=>{
            if (error.code === "ENOENT") error = new MissingPDFException(`Missing PDF "${this._url}".`);
            this._storedError = error;
            this._headersCapability.reject(error);
        });
    }
    get headersReady() {
        return this._headersCapability.promise;
    }
    get filename() {
        return this._filename;
    }
    get contentLength() {
        return this._contentLength;
    }
    get isRangeSupported() {
        return this._isRangeSupported;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    async read() {
        await this._readCapability.promise;
        if (this._done) return {
            value: undefined,
            done: true
        };
        if (this._storedError) throw this._storedError;
        const chunk = this._readableStream.read();
        if (chunk === null) {
            this._readCapability = Promise.withResolvers();
            return this.read();
        }
        this._loaded += chunk.length;
        this.onProgress?.({
            loaded: this._loaded,
            total: this._contentLength
        });
        const buffer = new Uint8Array(chunk).buffer;
        return {
            value: buffer,
            done: false
        };
    }
    cancel(reason) {
        if (!this._readableStream) {
            this._error(reason);
            return;
        }
        this._readableStream.destroy(reason);
    }
    _error(reason) {
        this._storedError = reason;
        this._readCapability.resolve();
    }
    _setReadableStream(readableStream) {
        this._readableStream = readableStream;
        readableStream.on("readable", ()=>{
            this._readCapability.resolve();
        });
        readableStream.on("end", ()=>{
            readableStream.destroy();
            this._done = true;
            this._readCapability.resolve();
        });
        readableStream.on("error", (reason)=>{
            this._error(reason);
        });
        if (!this._isStreamingSupported && this._isRangeSupported) this._error(new AbortException("streaming is disabled"));
        if (this._storedError) this._readableStream.destroy(this._storedError);
    }
}
class PDFNodeStreamFsRangeReader {
    constructor(stream, start, end){
        this._url = stream.url;
        this._done = false;
        this._storedError = null;
        this.onProgress = null;
        this._loaded = 0;
        this._readableStream = null;
        this._readCapability = Promise.withResolvers();
        const source = stream.source;
        this._isStreamingSupported = !source.disableStream;
        const fs = process.getBuiltinModule("fs");
        this._setReadableStream(fs.createReadStream(this._url, {
            start,
            end: end - 1
        }));
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    async read() {
        await this._readCapability.promise;
        if (this._done) return {
            value: undefined,
            done: true
        };
        if (this._storedError) throw this._storedError;
        const chunk = this._readableStream.read();
        if (chunk === null) {
            this._readCapability = Promise.withResolvers();
            return this.read();
        }
        this._loaded += chunk.length;
        this.onProgress?.({
            loaded: this._loaded
        });
        const buffer = new Uint8Array(chunk).buffer;
        return {
            value: buffer,
            done: false
        };
    }
    cancel(reason) {
        if (!this._readableStream) {
            this._error(reason);
            return;
        }
        this._readableStream.destroy(reason);
    }
    _error(reason) {
        this._storedError = reason;
        this._readCapability.resolve();
    }
    _setReadableStream(readableStream) {
        this._readableStream = readableStream;
        readableStream.on("readable", ()=>{
            this._readCapability.resolve();
        });
        readableStream.on("end", ()=>{
            readableStream.destroy();
            this._done = true;
            this._readCapability.resolve();
        });
        readableStream.on("error", (reason)=>{
            this._error(reason);
        });
        if (this._storedError) this._readableStream.destroy(this._storedError);
    }
}
const MAX_TEXT_DIVS_TO_RENDER = 100000;
const DEFAULT_FONT_SIZE = 30;
const DEFAULT_FONT_ASCENT = 0.8;
class TextLayer {
    #capability = Promise.withResolvers();
    #container = null;
    #disableProcessItems = false;
    #fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
    #lang = null;
    #layoutTextParams = null;
    #pageHeight = 0;
    #pageWidth = 0;
    #reader = null;
    #rootContainer = null;
    #rotation = 0;
    #scale = 0;
    #styleCache = Object.create(null);
    #textContentItemsStr = [];
    #textContentSource = null;
    #textDivs = [];
    #textDivProperties = new WeakMap();
    #transform = null;
    static #ascentCache = new Map();
    static #canvasContexts = new Map();
    static #canvasCtxFonts = new WeakMap();
    static #minFontSize = null;
    static #pendingTextLayers = new Set();
    constructor({ textContentSource, container, viewport }){
        if (textContentSource instanceof ReadableStream) this.#textContentSource = textContentSource;
        else if (typeof textContentSource === "object") this.#textContentSource = new ReadableStream({
            start (controller) {
                controller.enqueue(textContentSource);
                controller.close();
            }
        });
        else throw new Error('No "textContentSource" parameter specified.');
        this.#container = this.#rootContainer = container;
        this.#scale = viewport.scale * (globalThis.devicePixelRatio || 1);
        this.#rotation = viewport.rotation;
        this.#layoutTextParams = {
            div: null,
            properties: null,
            ctx: null
        };
        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;
        this.#transform = [
            1,
            0,
            0,
            -1,
            -pageX,
            pageY + pageHeight
        ];
        this.#pageWidth = pageWidth;
        this.#pageHeight = pageHeight;
        TextLayer.#ensureMinFontSizeComputed();
        setLayerDimensions(container, viewport);
        this.#capability.promise.finally(()=>{
            TextLayer.#pendingTextLayers.delete(this);
            this.#layoutTextParams = null;
            this.#styleCache = null;
        }).catch(()=>{});
    }
    static get fontFamilyMap() {
        const { isWindows, isFirefox } = util_FeatureTest.platform;
        return shadow(this, "fontFamilyMap", new Map([
            [
                "sans-serif",
                `${isWindows && isFirefox ? "Calibri, " : ""}sans-serif`
            ],
            [
                "monospace",
                `${isWindows && isFirefox ? "Lucida Console, " : ""}monospace`
            ]
        ]));
    }
    render() {
        const pump = ()=>{
            this.#reader.read().then(({ value, done })=>{
                if (done) {
                    this.#capability.resolve();
                    return;
                }
                this.#lang ??= value.lang;
                Object.assign(this.#styleCache, value.styles);
                this.#processItems(value.items);
                pump();
            }, this.#capability.reject);
        };
        this.#reader = this.#textContentSource.getReader();
        TextLayer.#pendingTextLayers.add(this);
        pump();
        return this.#capability.promise;
    }
    update({ viewport, onBefore = null }) {
        const scale = viewport.scale * (globalThis.devicePixelRatio || 1);
        const rotation = viewport.rotation;
        if (rotation !== this.#rotation) {
            onBefore?.();
            this.#rotation = rotation;
            setLayerDimensions(this.#rootContainer, {
                rotation
            });
        }
        if (scale !== this.#scale) {
            onBefore?.();
            this.#scale = scale;
            const params = {
                div: null,
                properties: null,
                ctx: TextLayer.#getCtx(this.#lang)
            };
            for (const div of this.#textDivs){
                params.properties = this.#textDivProperties.get(div);
                params.div = div;
                this.#layout(params);
            }
        }
    }
    cancel() {
        const abortEx = new AbortException("TextLayer task cancelled.");
        this.#reader?.cancel(abortEx).catch(()=>{});
        this.#reader = null;
        this.#capability.reject(abortEx);
    }
    get textDivs() {
        return this.#textDivs;
    }
    get textContentItemsStr() {
        return this.#textContentItemsStr;
    }
    #processItems(items) {
        if (this.#disableProcessItems) return;
        this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);
        const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;
        for (const item of items){
            if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {
                warn("Ignoring additional textDivs for performance reasons.");
                this.#disableProcessItems = true;
                return;
            }
            if (item.str === undefined) {
                if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
                    const parent = this.#container;
                    this.#container = document.createElement("span");
                    this.#container.classList.add("markedContent");
                    if (item.id !== null) this.#container.setAttribute("id", `${item.id}`);
                    parent.append(this.#container);
                } else if (item.type === "endMarkedContent") this.#container = this.#container.parentNode;
                continue;
            }
            textContentItemsStr.push(item.str);
            this.#appendText(item);
        }
    }
    #appendText(geom) {
        const textDiv = document.createElement("span");
        const textDivProperties = {
            angle: 0,
            canvasWidth: 0,
            hasText: geom.str !== "",
            hasEOL: geom.hasEOL,
            fontSize: 0
        };
        this.#textDivs.push(textDiv);
        const tx = Util.transform(this.#transform, geom.transform);
        let angle = Math.atan2(tx[1], tx[0]);
        const style = this.#styleCache[geom.fontName];
        if (style.vertical) angle += Math.PI / 2;
        let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;
        fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;
        const fontHeight = Math.hypot(tx[2], tx[3]);
        const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, this.#lang);
        let left, top;
        if (angle === 0) {
            left = tx[4];
            top = tx[5] - fontAscent;
        } else {
            left = tx[4] + fontAscent * Math.sin(angle);
            top = tx[5] - fontAscent * Math.cos(angle);
        }
        const scaleFactorStr = "calc(var(--scale-factor)*";
        const divStyle = textDiv.style;
        if (this.#container === this.#rootContainer) {
            divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;
            divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;
        } else {
            divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
            divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
        }
        divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;
        divStyle.fontFamily = fontFamily;
        textDivProperties.fontSize = fontHeight;
        textDiv.setAttribute("role", "presentation");
        textDiv.textContent = geom.str;
        textDiv.dir = geom.dir;
        if (this.#fontInspectorEnabled) textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;
        if (angle !== 0) textDivProperties.angle = angle * (180 / Math.PI);
        let shouldScaleText = false;
        if (geom.str.length > 1) shouldScaleText = true;
        else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
            const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) shouldScaleText = true;
        }
        if (shouldScaleText) textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
        this.#textDivProperties.set(textDiv, textDivProperties);
        this.#layoutTextParams.div = textDiv;
        this.#layoutTextParams.properties = textDivProperties;
        this.#layout(this.#layoutTextParams);
        if (textDivProperties.hasText) this.#container.append(textDiv);
        if (textDivProperties.hasEOL) {
            const br = document.createElement("br");
            br.setAttribute("role", "presentation");
            this.#container.append(br);
        }
    }
    #layout(params) {
        const { div, properties, ctx } = params;
        const { style } = div;
        let transform = "";
        if (TextLayer.#minFontSize > 1) transform = `scale(${1 / TextLayer.#minFontSize})`;
        if (properties.canvasWidth !== 0 && properties.hasText) {
            const { fontFamily } = style;
            const { canvasWidth, fontSize } = properties;
            TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);
            const { width } = ctx.measureText(div.textContent);
            if (width > 0) transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;
        }
        if (properties.angle !== 0) transform = `rotate(${properties.angle}deg) ${transform}`;
        if (transform.length > 0) style.transform = transform;
    }
    static cleanup() {
        if (this.#pendingTextLayers.size > 0) return;
        this.#ascentCache.clear();
        for (const { canvas } of this.#canvasContexts.values())canvas.remove();
        this.#canvasContexts.clear();
    }
    static #getCtx(lang = null) {
        let ctx = this.#canvasContexts.get(lang ||= "");
        if (!ctx) {
            const canvas = document.createElement("canvas");
            canvas.className = "hiddenCanvasElement";
            canvas.lang = lang;
            document.body.append(canvas);
            ctx = canvas.getContext("2d", {
                alpha: false,
                willReadFrequently: true
            });
            this.#canvasContexts.set(lang, ctx);
            this.#canvasCtxFonts.set(ctx, {
                size: 0,
                family: ""
            });
        }
        return ctx;
    }
    static #ensureCtxFont(ctx, size, family) {
        const cached = this.#canvasCtxFonts.get(ctx);
        if (size === cached.size && family === cached.family) return;
        ctx.font = `${size}px ${family}`;
        cached.size = size;
        cached.family = family;
    }
    static #ensureMinFontSizeComputed() {
        if (this.#minFontSize !== null) return;
        const div = document.createElement("div");
        div.style.opacity = 0;
        div.style.lineHeight = 1;
        div.style.fontSize = "1px";
        div.style.position = "absolute";
        div.textContent = "X";
        document.body.append(div);
        this.#minFontSize = div.getBoundingClientRect().height;
        div.remove();
    }
    static #getAscent(fontFamily, lang) {
        const cachedAscent = this.#ascentCache.get(fontFamily);
        if (cachedAscent) return cachedAscent;
        const ctx = this.#getCtx(lang);
        ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;
        this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);
        const metrics = ctx.measureText("");
        let ascent = metrics.fontBoundingBoxAscent;
        let descent = Math.abs(metrics.fontBoundingBoxDescent);
        if (ascent) {
            const ratio = ascent / (ascent + descent);
            this.#ascentCache.set(fontFamily, ratio);
            ctx.canvas.width = ctx.canvas.height = 0;
            return ratio;
        }
        ctx.strokeStyle = "red";
        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
        ctx.strokeText("g", 0, 0);
        let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
        descent = 0;
        for(let i = pixels.length - 1 - 3; i >= 0; i -= 4)if (pixels[i] > 0) {
            descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
            break;
        }
        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
        ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
        pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
        ascent = 0;
        for(let i = 0, ii = pixels.length; i < ii; i += 4)if (pixels[i] > 0) {
            ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
            break;
        }
        ctx.canvas.width = ctx.canvas.height = 0;
        const ratio = ascent ? ascent / (ascent + descent) : DEFAULT_FONT_ASCENT;
        this.#ascentCache.set(fontFamily, ratio);
        return ratio;
    }
}
class XfaText {
    static textContent(xfa) {
        const items = [];
        const output = {
            items,
            styles: Object.create(null)
        };
        function walk(node) {
            if (!node) return;
            let str = null;
            const name = node.name;
            if (name === "#text") str = node.value;
            else if (!XfaText.shouldBuildText(name)) return;
            else if (node?.attributes?.textContent) str = node.attributes.textContent;
            else if (node.value) str = node.value;
            if (str !== null) items.push({
                str
            });
            if (!node.children) return;
            for (const child of node.children)walk(child);
        }
        walk(xfa);
        return output;
    }
    static shouldBuildText(name) {
        return !(name === "textarea" || name === "input" || name === "option" || name === "select");
    }
}
const DEFAULT_RANGE_CHUNK_SIZE = 65536;
const RENDERING_CANCELLED_TIMEOUT = 100;
const DELAYED_CLEANUP_TIMEOUT = 5000;
const DefaultCanvasFactory = isNodeJS ? NodeCanvasFactory : DOMCanvasFactory;
const DefaultCMapReaderFactory = isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory;
const DefaultFilterFactory = isNodeJS ? NodeFilterFactory : DOMFilterFactory;
const DefaultStandardFontDataFactory = isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory;
function getDocument(src = {}) {
    if (typeof src === "string" || src instanceof URL) src = {
        url: src
    };
    else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) src = {
        data: src
    };
    const task = new PDFDocumentLoadingTask();
    const { docId } = task;
    const url = src.url ? getUrlProp(src.url) : null;
    const data = src.data ? getDataProp(src.data) : null;
    const httpHeaders = src.httpHeaders || null;
    const withCredentials = src.withCredentials === true;
    const password = src.password ?? null;
    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
    let worker = src.worker instanceof PDFWorker ? src.worker : null;
    const verbosity = src.verbosity;
    const docBaseUrl = typeof src.docBaseUrl === "string" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;
    const cMapUrl = typeof src.cMapUrl === "string" ? src.cMapUrl : null;
    const cMapPacked = src.cMapPacked !== false;
    const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;
    const standardFontDataUrl = typeof src.standardFontDataUrl === "string" ? src.standardFontDataUrl : null;
    const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;
    const ignoreErrors = src.stopAtErrors !== true;
    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
    const isEvalSupported = src.isEvalSupported !== false;
    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !isNodeJS;
    const isImageDecoderSupported = typeof src.isImageDecoderSupported === "boolean" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);
    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
    const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : isNodeJS;
    const fontExtraProperties = src.fontExtraProperties === true;
    const enableXfa = src.enableXfa === true;
    const ownerDocument = src.ownerDocument || globalThis.document;
    const disableRange = src.disableRange === true;
    const disableStream = src.disableStream === true;
    const disableAutoFetch = src.disableAutoFetch === true;
    const pdfBug = src.pdfBug === true;
    const CanvasFactory = src.CanvasFactory || DefaultCanvasFactory;
    const FilterFactory = src.FilterFactory || DefaultFilterFactory;
    const enableHWA = src.enableHWA === true;
    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
    const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !isNodeJS && !disableFontFace;
    const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI);
    const styleElement = null;
    setVerbosityLevel(verbosity);
    const transportFactory = {
        canvasFactory: new CanvasFactory({
            ownerDocument,
            enableHWA
        }),
        filterFactory: new FilterFactory({
            docId,
            ownerDocument
        }),
        cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({
            baseUrl: cMapUrl,
            isCompressed: cMapPacked
        }),
        standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({
            baseUrl: standardFontDataUrl
        })
    };
    if (!worker) {
        const workerParams = {
            verbosity,
            port: GlobalWorkerOptions.workerPort
        };
        worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
        task._worker = worker;
    }
    const docParams = {
        docId,
        apiVersion: "4.10.38",
        data,
        password,
        disableAutoFetch,
        rangeChunkSize,
        length,
        docBaseUrl,
        enableXfa,
        evaluatorOptions: {
            maxImageSize,
            disableFontFace,
            ignoreErrors,
            isEvalSupported,
            isOffscreenCanvasSupported,
            isImageDecoderSupported,
            canvasMaxAreaInBytes,
            fontExtraProperties,
            useSystemFonts,
            cMapUrl: useWorkerFetch ? cMapUrl : null,
            standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null
        }
    };
    const transportParams = {
        disableFontFace,
        fontExtraProperties,
        ownerDocument,
        pdfBug,
        styleElement,
        loadingParams: {
            disableAutoFetch,
            enableXfa
        }
    };
    worker.promise.then(function() {
        if (task.destroyed) throw new Error("Loading aborted");
        if (worker.destroyed) throw new Error("Worker was destroyed");
        const workerIdPromise = worker.messageHandler.sendWithPromise("GetDocRequest", docParams, data ? [
            data.buffer
        ] : null);
        let networkStream;
        if (rangeTransport) networkStream = new PDFDataTransportStream(rangeTransport, {
            disableRange,
            disableStream
        });
        else if (!data) {
            if (!url) throw new Error("getDocument - no `url` parameter provided.");
            let NetworkStream;
            if (isNodeJS) {
                if (isValidFetchUrl(url)) {
                    if (typeof fetch === "undefined" || typeof Response === "undefined" || !("body" in Response.prototype)) throw new Error("getDocument - the Fetch API was disabled in Node.js, see `--no-experimental-fetch`.");
                    NetworkStream = PDFFetchStream;
                } else NetworkStream = PDFNodeStream;
            } else NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : PDFNetworkStream;
            networkStream = new NetworkStream({
                url,
                length,
                httpHeaders,
                withCredentials,
                rangeChunkSize,
                disableRange,
                disableStream
            });
        }
        return workerIdPromise.then((workerId)=>{
            if (task.destroyed) throw new Error("Loading aborted");
            if (worker.destroyed) throw new Error("Worker was destroyed");
            const messageHandler = new MessageHandler(docId, workerId, worker.port);
            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);
            task._transport = transport;
            messageHandler.send("Ready", null);
        });
    }).catch(task._capability.reject);
    return task;
}
function getUrlProp(val) {
    if (val instanceof URL) return val.href;
    try {
        return new URL(val, window.location).href;
    } catch  {
        if (isNodeJS && typeof val === "string") return val;
    }
    throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function getDataProp(val) {
    if (isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) return val;
    if (typeof val === "string") return stringToBytes(val);
    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === "object" && !isNaN(val?.length)) return new Uint8Array(val);
    throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function isRefProxy(ref) {
    return typeof ref === "object" && Number.isInteger(ref?.num) && ref.num >= 0 && Number.isInteger(ref?.gen) && ref.gen >= 0;
}
class PDFDocumentLoadingTask {
    static #docId = 0;
    constructor(){
        this._capability = Promise.withResolvers();
        this._transport = null;
        this._worker = null;
        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;
        this.destroyed = false;
        this.onPassword = null;
        this.onProgress = null;
    }
    get promise() {
        return this._capability.promise;
    }
    async destroy() {
        this.destroyed = true;
        try {
            if (this._worker?.port) this._worker._pendingDestroy = true;
            await this._transport?.destroy();
        } catch (ex) {
            if (this._worker?.port) delete this._worker._pendingDestroy;
            throw ex;
        }
        this._transport = null;
        this._worker?.destroy();
        this._worker = null;
    }
}
class PDFDataRangeTransport {
    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){
        this.length = length;
        this.initialData = initialData;
        this.progressiveDone = progressiveDone;
        this.contentDispositionFilename = contentDispositionFilename;
        this._rangeListeners = [];
        this._progressListeners = [];
        this._progressiveReadListeners = [];
        this._progressiveDoneListeners = [];
        this._readyCapability = Promise.withResolvers();
    }
    addRangeListener(listener) {
        this._rangeListeners.push(listener);
    }
    addProgressListener(listener) {
        this._progressListeners.push(listener);
    }
    addProgressiveReadListener(listener) {
        this._progressiveReadListeners.push(listener);
    }
    addProgressiveDoneListener(listener) {
        this._progressiveDoneListeners.push(listener);
    }
    onDataRange(begin, chunk) {
        for (const listener of this._rangeListeners)listener(begin, chunk);
    }
    onDataProgress(loaded, total) {
        this._readyCapability.promise.then(()=>{
            for (const listener of this._progressListeners)listener(loaded, total);
        });
    }
    onDataProgressiveRead(chunk) {
        this._readyCapability.promise.then(()=>{
            for (const listener of this._progressiveReadListeners)listener(chunk);
        });
    }
    onDataProgressiveDone() {
        this._readyCapability.promise.then(()=>{
            for (const listener of this._progressiveDoneListeners)listener();
        });
    }
    transportReady() {
        this._readyCapability.resolve();
    }
    requestDataRange(begin, end) {
        unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
    }
    abort() {}
}
class PDFDocumentProxy {
    constructor(pdfInfo, transport){
        this._pdfInfo = pdfInfo;
        this._transport = transport;
    }
    get annotationStorage() {
        return this._transport.annotationStorage;
    }
    get canvasFactory() {
        return this._transport.canvasFactory;
    }
    get filterFactory() {
        return this._transport.filterFactory;
    }
    get numPages() {
        return this._pdfInfo.numPages;
    }
    get fingerprints() {
        return this._pdfInfo.fingerprints;
    }
    get isPureXfa() {
        return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    get allXfaHtml() {
        return this._transport._htmlForXfa;
    }
    getPage(pageNumber) {
        return this._transport.getPage(pageNumber);
    }
    getPageIndex(ref) {
        return this._transport.getPageIndex(ref);
    }
    getDestinations() {
        return this._transport.getDestinations();
    }
    getDestination(id) {
        return this._transport.getDestination(id);
    }
    getPageLabels() {
        return this._transport.getPageLabels();
    }
    getPageLayout() {
        return this._transport.getPageLayout();
    }
    getPageMode() {
        return this._transport.getPageMode();
    }
    getViewerPreferences() {
        return this._transport.getViewerPreferences();
    }
    getOpenAction() {
        return this._transport.getOpenAction();
    }
    getAttachments() {
        return this._transport.getAttachments();
    }
    getJSActions() {
        return this._transport.getDocJSActions();
    }
    getOutline() {
        return this._transport.getOutline();
    }
    getOptionalContentConfig({ intent = "display" } = {}) {
        const { renderingIntent } = this._transport.getRenderingIntent(intent);
        return this._transport.getOptionalContentConfig(renderingIntent);
    }
    getPermissions() {
        return this._transport.getPermissions();
    }
    getMetadata() {
        return this._transport.getMetadata();
    }
    getMarkInfo() {
        return this._transport.getMarkInfo();
    }
    getData() {
        return this._transport.getData();
    }
    saveDocument() {
        return this._transport.saveDocument();
    }
    getDownloadInfo() {
        return this._transport.downloadInfoCapability.promise;
    }
    cleanup(keepLoadedFonts = false) {
        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
    }
    destroy() {
        return this.loadingTask.destroy();
    }
    cachedPageNumber(ref) {
        return this._transport.cachedPageNumber(ref);
    }
    get loadingParams() {
        return this._transport.loadingParams;
    }
    get loadingTask() {
        return this._transport.loadingTask;
    }
    getFieldObjects() {
        return this._transport.getFieldObjects();
    }
    hasJSActions() {
        return this._transport.hasJSActions();
    }
    getCalculationOrderIds() {
        return this._transport.getCalculationOrderIds();
    }
}
class PDFPageProxy {
    #delayedCleanupTimeout = null;
    #pendingCleanup = false;
    constructor(pageIndex, pageInfo, transport, pdfBug = false){
        this._pageIndex = pageIndex;
        this._pageInfo = pageInfo;
        this._transport = transport;
        this._stats = pdfBug ? new StatTimer() : null;
        this._pdfBug = pdfBug;
        this.commonObjs = transport.commonObjs;
        this.objs = new PDFObjects();
        this._maybeCleanupAfterRender = false;
        this._intentStates = new Map();
        this.destroyed = false;
    }
    get pageNumber() {
        return this._pageIndex + 1;
    }
    get rotate() {
        return this._pageInfo.rotate;
    }
    get ref() {
        return this._pageInfo.ref;
    }
    get userUnit() {
        return this._pageInfo.userUnit;
    }
    get view() {
        return this._pageInfo.view;
    }
    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {
        return new PageViewport({
            viewBox: this.view,
            userUnit: this.userUnit,
            scale,
            rotation,
            offsetX,
            offsetY,
            dontFlip
        });
    }
    getAnnotations({ intent = "display" } = {}) {
        const { renderingIntent } = this._transport.getRenderingIntent(intent);
        return this._transport.getAnnotations(this._pageIndex, renderingIntent);
    }
    getJSActions() {
        return this._transport.getPageJSActions(this._pageIndex);
    }
    get filterFactory() {
        return this._transport.filterFactory;
    }
    get isPureXfa() {
        return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    async getXfa() {
        return this._transport._htmlForXfa?.children[this._pageIndex] || null;
    }
    render({ canvasContext, viewport, intent = "display", annotationMode = AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null, isEditing = false }) {
        this._stats?.time("Overall");
        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);
        const { renderingIntent, cacheKey } = intentArgs;
        this.#pendingCleanup = false;
        this.#abortDelayedCleanup();
        optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);
        let intentState = this._intentStates.get(cacheKey);
        if (!intentState) {
            intentState = Object.create(null);
            this._intentStates.set(cacheKey, intentState);
        }
        if (intentState.streamReaderCancelTimeout) {
            clearTimeout(intentState.streamReaderCancelTimeout);
            intentState.streamReaderCancelTimeout = null;
        }
        const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
        if (!intentState.displayReadyCapability) {
            intentState.displayReadyCapability = Promise.withResolvers();
            intentState.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: false,
                separateAnnots: null
            };
            this._stats?.time("Page Request");
            this._pumpOperatorList(intentArgs);
        }
        const complete = (error)=>{
            intentState.renderTasks.delete(internalRenderTask);
            if (this._maybeCleanupAfterRender || intentPrint) this.#pendingCleanup = true;
            this.#tryCleanup(!intentPrint);
            if (error) {
                internalRenderTask.capability.reject(error);
                this._abortOperatorList({
                    intentState,
                    reason: error instanceof Error ? error : new Error(error)
                });
            } else internalRenderTask.capability.resolve();
            if (this._stats) {
                this._stats.timeEnd("Rendering");
                this._stats.timeEnd("Overall");
                if (globalThis.Stats?.enabled) globalThis.Stats.add(this.pageNumber, this._stats);
            }
        };
        const internalRenderTask = new InternalRenderTask({
            callback: complete,
            params: {
                canvasContext,
                viewport,
                transform,
                background
            },
            objs: this.objs,
            commonObjs: this.commonObjs,
            annotationCanvasMap,
            operatorList: intentState.operatorList,
            pageIndex: this._pageIndex,
            canvasFactory: this._transport.canvasFactory,
            filterFactory: this._transport.filterFactory,
            useRequestAnimationFrame: !intentPrint,
            pdfBug: this._pdfBug,
            pageColors
        });
        (intentState.renderTasks ||= new Set()).add(internalRenderTask);
        const renderTask = internalRenderTask.task;
        Promise.all([
            intentState.displayReadyCapability.promise,
            optionalContentConfigPromise
        ]).then(([transparency, optionalContentConfig])=>{
            if (this.destroyed) {
                complete();
                return;
            }
            this._stats?.time("Rendering");
            if (!(optionalContentConfig.renderingIntent & renderingIntent)) throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
            internalRenderTask.initializeGraphics({
                transparency,
                optionalContentConfig
            });
            internalRenderTask.operatorListChanged();
        }).catch(complete);
        return renderTask;
    }
    getOperatorList({ intent = "display", annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false } = {}) {
        function operatorListChanged() {
            if (intentState.operatorList.lastChunk) {
                intentState.opListReadCapability.resolve(intentState.operatorList);
                intentState.renderTasks.delete(opListTask);
            }
        }
        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);
        let intentState = this._intentStates.get(intentArgs.cacheKey);
        if (!intentState) {
            intentState = Object.create(null);
            this._intentStates.set(intentArgs.cacheKey, intentState);
        }
        let opListTask;
        if (!intentState.opListReadCapability) {
            opListTask = Object.create(null);
            opListTask.operatorListChanged = operatorListChanged;
            intentState.opListReadCapability = Promise.withResolvers();
            (intentState.renderTasks ||= new Set()).add(opListTask);
            intentState.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: false,
                separateAnnots: null
            };
            this._stats?.time("Page Request");
            this._pumpOperatorList(intentArgs);
        }
        return intentState.opListReadCapability.promise;
    }
    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {
        const TEXT_CONTENT_CHUNK_SIZE = 100;
        return this._transport.messageHandler.sendWithStream("GetTextContent", {
            pageIndex: this._pageIndex,
            includeMarkedContent: includeMarkedContent === true,
            disableNormalization: disableNormalization === true
        }, {
            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
            size (textContent) {
                return textContent.items.length;
            }
        });
    }
    getTextContent(params = {}) {
        if (this._transport._htmlForXfa) return this.getXfa().then((xfa)=>XfaText.textContent(xfa));
        const readableStream = this.streamTextContent(params);
        return new Promise(function(resolve, reject) {
            function pump() {
                reader.read().then(function({ value, done }) {
                    if (done) {
                        resolve(textContent);
                        return;
                    }
                    textContent.lang ??= value.lang;
                    Object.assign(textContent.styles, value.styles);
                    textContent.items.push(...value.items);
                    pump();
                }, reject);
            }
            const reader = readableStream.getReader();
            const textContent = {
                items: [],
                styles: Object.create(null),
                lang: null
            };
            pump();
        });
    }
    getStructTree() {
        return this._transport.getStructTree(this._pageIndex);
    }
    _destroy() {
        this.destroyed = true;
        const waitOn = [];
        for (const intentState of this._intentStates.values()){
            this._abortOperatorList({
                intentState,
                reason: new Error("Page was destroyed."),
                force: true
            });
            if (intentState.opListReadCapability) continue;
            for (const internalRenderTask of intentState.renderTasks){
                waitOn.push(internalRenderTask.completed);
                internalRenderTask.cancel();
            }
        }
        this.objs.clear();
        this.#pendingCleanup = false;
        this.#abortDelayedCleanup();
        return Promise.all(waitOn);
    }
    cleanup(resetStats = false) {
        this.#pendingCleanup = true;
        const success = this.#tryCleanup(false);
        if (resetStats && success) this._stats &&= new StatTimer();
        return success;
    }
    #tryCleanup(delayed = false) {
        this.#abortDelayedCleanup();
        if (!this.#pendingCleanup || this.destroyed) return false;
        if (delayed) {
            this.#delayedCleanupTimeout = setTimeout(()=>{
                this.#delayedCleanupTimeout = null;
                this.#tryCleanup(false);
            }, DELAYED_CLEANUP_TIMEOUT);
            return false;
        }
        for (const { renderTasks, operatorList } of this._intentStates.values()){
            if (renderTasks.size > 0 || !operatorList.lastChunk) return false;
        }
        this._intentStates.clear();
        this.objs.clear();
        this.#pendingCleanup = false;
        return true;
    }
    #abortDelayedCleanup() {
        if (this.#delayedCleanupTimeout) {
            clearTimeout(this.#delayedCleanupTimeout);
            this.#delayedCleanupTimeout = null;
        }
    }
    _startRenderPage(transparency, cacheKey) {
        const intentState = this._intentStates.get(cacheKey);
        if (!intentState) return;
        this._stats?.timeEnd("Page Request");
        intentState.displayReadyCapability?.resolve(transparency);
    }
    _renderPageChunk(operatorListChunk, intentState) {
        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){
            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
        }
        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
        for (const internalRenderTask of intentState.renderTasks)internalRenderTask.operatorListChanged();
        if (operatorListChunk.lastChunk) this.#tryCleanup(true);
    }
    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable, modifiedIds }) {
        const { map, transfer } = annotationStorageSerializable;
        const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
            pageIndex: this._pageIndex,
            intent: renderingIntent,
            cacheKey,
            annotationStorage: map,
            modifiedIds
        }, transfer);
        const reader = readableStream.getReader();
        const intentState = this._intentStates.get(cacheKey);
        intentState.streamReader = reader;
        const pump = ()=>{
            reader.read().then(({ value, done })=>{
                if (done) {
                    intentState.streamReader = null;
                    return;
                }
                if (this._transport.destroyed) return;
                this._renderPageChunk(value, intentState);
                pump();
            }, (reason)=>{
                intentState.streamReader = null;
                if (this._transport.destroyed) return;
                if (intentState.operatorList) {
                    intentState.operatorList.lastChunk = true;
                    for (const internalRenderTask of intentState.renderTasks)internalRenderTask.operatorListChanged();
                    this.#tryCleanup(true);
                }
                if (intentState.displayReadyCapability) intentState.displayReadyCapability.reject(reason);
                else if (intentState.opListReadCapability) intentState.opListReadCapability.reject(reason);
                else throw reason;
            });
        };
        pump();
    }
    _abortOperatorList({ intentState, reason, force = false }) {
        if (!intentState.streamReader) return;
        if (intentState.streamReaderCancelTimeout) {
            clearTimeout(intentState.streamReaderCancelTimeout);
            intentState.streamReaderCancelTimeout = null;
        }
        if (!force) {
            if (intentState.renderTasks.size > 0) return;
            if (reason instanceof RenderingCancelledException) {
                let delay = RENDERING_CANCELLED_TIMEOUT;
                if (reason.extraDelay > 0 && reason.extraDelay < 1000) delay += reason.extraDelay;
                intentState.streamReaderCancelTimeout = setTimeout(()=>{
                    intentState.streamReaderCancelTimeout = null;
                    this._abortOperatorList({
                        intentState,
                        reason,
                        force: true
                    });
                }, delay);
                return;
            }
        }
        intentState.streamReader.cancel(new AbortException(reason.message)).catch(()=>{});
        intentState.streamReader = null;
        if (this._transport.destroyed) return;
        for (const [curCacheKey, curIntentState] of this._intentStates)if (curIntentState === intentState) {
            this._intentStates.delete(curCacheKey);
            break;
        }
        this.cleanup();
    }
    get stats() {
        return this._stats;
    }
}
class LoopbackPort {
    #listeners = new Map();
    #deferred = Promise.resolve();
    postMessage(obj, transfer) {
        const event = {
            data: structuredClone(obj, transfer ? {
                transfer
            } : null)
        };
        this.#deferred.then(()=>{
            for (const [listener] of this.#listeners)listener.call(this, event);
        });
    }
    addEventListener(name, listener, options = null) {
        let rmAbort = null;
        if (options?.signal instanceof AbortSignal) {
            const { signal } = options;
            if (signal.aborted) {
                warn("LoopbackPort - cannot use an `aborted` signal.");
                return;
            }
            const onAbort = ()=>this.removeEventListener(name, listener);
            rmAbort = ()=>signal.removeEventListener("abort", onAbort);
            signal.addEventListener("abort", onAbort);
        }
        this.#listeners.set(listener, rmAbort);
    }
    removeEventListener(name, listener) {
        const rmAbort = this.#listeners.get(listener);
        rmAbort?.();
        this.#listeners.delete(listener);
    }
    terminate() {
        for (const [, rmAbort] of this.#listeners)rmAbort?.();
        this.#listeners.clear();
    }
}
class PDFWorker {
    static #fakeWorkerId = 0;
    static #isWorkerDisabled = false;
    static #workerPorts;
    static{
        if (isNodeJS) {
            this.#isWorkerDisabled = true;
            GlobalWorkerOptions.workerSrc ||= "./pdf.worker.mjs";
        }
        this._isSameOrigin = (baseUrl, otherUrl)=>{
            let base;
            try {
                base = new URL(baseUrl);
                if (!base.origin || base.origin === "null") return false;
            } catch  {
                return false;
            }
            const other = new URL(otherUrl, base);
            return base.origin === other.origin;
        };
        this._createCDNWrapper = (url)=>{
            const wrapper = `await import("${url}");`;
            return URL.createObjectURL(new Blob([
                wrapper
            ], {
                type: "text/javascript"
            }));
        };
    }
    constructor({ name = null, port = null, verbosity = getVerbosityLevel() } = {}){
        this.name = name;
        this.destroyed = false;
        this.verbosity = verbosity;
        this._readyCapability = Promise.withResolvers();
        this._port = null;
        this._webWorker = null;
        this._messageHandler = null;
        if (port) {
            if (PDFWorker.#workerPorts?.has(port)) throw new Error("Cannot use more than one PDFWorker per port.");
            (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);
            this._initializeFromPort(port);
            return;
        }
        this._initialize();
    }
    get promise() {
        return this._readyCapability.promise;
    }
    #resolve() {
        this._readyCapability.resolve();
        this._messageHandler.send("configure", {
            verbosity: this.verbosity
        });
    }
    get port() {
        return this._port;
    }
    get messageHandler() {
        return this._messageHandler;
    }
    _initializeFromPort(port) {
        this._port = port;
        this._messageHandler = new MessageHandler("main", "worker", port);
        this._messageHandler.on("ready", function() {});
        this.#resolve();
    }
    _initialize() {
        if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {
            this._setupFakeWorker();
            return;
        }
        let { workerSrc } = PDFWorker;
        try {
            if (!PDFWorker._isSameOrigin(window.location.href, workerSrc)) workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);
            const worker = new Worker(workerSrc, {
                type: "module"
            });
            const messageHandler = new MessageHandler("main", "worker", worker);
            const terminateEarly = ()=>{
                ac.abort();
                messageHandler.destroy();
                worker.terminate();
                if (this.destroyed) this._readyCapability.reject(new Error("Worker was destroyed"));
                else this._setupFakeWorker();
            };
            const ac = new AbortController();
            worker.addEventListener("error", ()=>{
                if (!this._webWorker) terminateEarly();
            }, {
                signal: ac.signal
            });
            messageHandler.on("test", (data)=>{
                ac.abort();
                if (this.destroyed || !data) {
                    terminateEarly();
                    return;
                }
                this._messageHandler = messageHandler;
                this._port = worker;
                this._webWorker = worker;
                this.#resolve();
            });
            messageHandler.on("ready", (data)=>{
                ac.abort();
                if (this.destroyed) {
                    terminateEarly();
                    return;
                }
                try {
                    sendTest();
                } catch  {
                    this._setupFakeWorker();
                }
            });
            const sendTest = ()=>{
                const testObj = new Uint8Array();
                messageHandler.send("test", testObj, [
                    testObj.buffer
                ]);
            };
            sendTest();
            return;
        } catch  {
            info("The worker has been disabled.");
        }
        this._setupFakeWorker();
    }
    _setupFakeWorker() {
        if (!PDFWorker.#isWorkerDisabled) {
            warn("Setting up fake worker.");
            PDFWorker.#isWorkerDisabled = true;
        }
        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{
            if (this.destroyed) {
                this._readyCapability.reject(new Error("Worker was destroyed"));
                return;
            }
            const port = new LoopbackPort();
            this._port = port;
            const id = `fake${PDFWorker.#fakeWorkerId++}`;
            const workerHandler = new MessageHandler(id + "_worker", id, port);
            WorkerMessageHandler.setup(workerHandler, port);
            this._messageHandler = new MessageHandler(id, id + "_worker", port);
            this.#resolve();
        }).catch((reason)=>{
            this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
        });
    }
    destroy() {
        this.destroyed = true;
        this._webWorker?.terminate();
        this._webWorker = null;
        PDFWorker.#workerPorts?.delete(this._port);
        this._port = null;
        this._messageHandler?.destroy();
        this._messageHandler = null;
    }
    static fromPort(params) {
        if (!params?.port) throw new Error("PDFWorker.fromPort - invalid method signature.");
        const cachedPort = this.#workerPorts?.get(params.port);
        if (cachedPort) {
            if (cachedPort._pendingDestroy) throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
            return cachedPort;
        }
        return new PDFWorker(params);
    }
    static get workerSrc() {
        if (GlobalWorkerOptions.workerSrc) return GlobalWorkerOptions.workerSrc;
        throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
    }
    static get #mainThreadWorkerMessageHandler() {
        try {
            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
        } catch  {
            return null;
        }
    }
    static get _setupFakeWorkerGlobal() {
        const loader = async ()=>{
            if (this.#mainThreadWorkerMessageHandler) return this.#mainThreadWorkerMessageHandler;
            const worker = await import(/*webpackIgnore: true*/ this.workerSrc);
            return worker.WorkerMessageHandler;
        };
        return shadow(this, "_setupFakeWorkerGlobal", loader());
    }
}
class WorkerTransport {
    #methodPromises = new Map();
    #pageCache = new Map();
    #pagePromises = new Map();
    #pageRefCache = new Map();
    #passwordCapability = null;
    constructor(messageHandler, loadingTask, networkStream, params, factory){
        this.messageHandler = messageHandler;
        this.loadingTask = loadingTask;
        this.commonObjs = new PDFObjects();
        this.fontLoader = new FontLoader({
            ownerDocument: params.ownerDocument,
            styleElement: params.styleElement
        });
        this.loadingParams = params.loadingParams;
        this._params = params;
        this.canvasFactory = factory.canvasFactory;
        this.filterFactory = factory.filterFactory;
        this.cMapReaderFactory = factory.cMapReaderFactory;
        this.standardFontDataFactory = factory.standardFontDataFactory;
        this.destroyed = false;
        this.destroyCapability = null;
        this._networkStream = networkStream;
        this._fullReader = null;
        this._lastProgress = null;
        this.downloadInfoCapability = Promise.withResolvers();
        this.setupMessageHandler();
    }
    #cacheSimpleMethod(name, data = null) {
        const cachedPromise = this.#methodPromises.get(name);
        if (cachedPromise) return cachedPromise;
        const promise = this.messageHandler.sendWithPromise(name, data);
        this.#methodPromises.set(name, promise);
        return promise;
    }
    get annotationStorage() {
        return shadow(this, "annotationStorage", new AnnotationStorage());
    }
    getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {
        let renderingIntent = RenderingIntentFlag.DISPLAY;
        let annotationStorageSerializable = SerializableEmpty;
        switch(intent){
            case "any":
                renderingIntent = RenderingIntentFlag.ANY;
                break;
            case "display":
                break;
            case "print":
                renderingIntent = RenderingIntentFlag.PRINT;
                break;
            default:
                warn(`getRenderingIntent - invalid intent: ${intent}`);
        }
        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
        switch(annotationMode){
            case AnnotationMode.DISABLE:
                renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;
                break;
            case AnnotationMode.ENABLE:
                break;
            case AnnotationMode.ENABLE_FORMS:
                renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;
                break;
            case AnnotationMode.ENABLE_STORAGE:
                renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;
                annotationStorageSerializable = annotationStorage.serializable;
                break;
            default:
                warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
        }
        if (isEditing) renderingIntent += RenderingIntentFlag.IS_EDITING;
        if (isOpList) renderingIntent += RenderingIntentFlag.OPLIST;
        const { ids: modifiedIds, hash: modifiedIdsHash } = annotationStorage.modifiedIds;
        const cacheKeyBuf = [
            renderingIntent,
            annotationStorageSerializable.hash,
            modifiedIdsHash
        ];
        return {
            renderingIntent,
            cacheKey: cacheKeyBuf.join("_"),
            annotationStorageSerializable,
            modifiedIds
        };
    }
    destroy() {
        if (this.destroyCapability) return this.destroyCapability.promise;
        this.destroyed = true;
        this.destroyCapability = Promise.withResolvers();
        this.#passwordCapability?.reject(new Error("Worker was destroyed during onPassword callback"));
        const waitOn = [];
        for (const page of this.#pageCache.values())waitOn.push(page._destroy());
        this.#pageCache.clear();
        this.#pagePromises.clear();
        this.#pageRefCache.clear();
        if (this.hasOwnProperty("annotationStorage")) this.annotationStorage.resetModified();
        const terminated = this.messageHandler.sendWithPromise("Terminate", null);
        waitOn.push(terminated);
        Promise.all(waitOn).then(()=>{
            this.commonObjs.clear();
            this.fontLoader.clear();
            this.#methodPromises.clear();
            this.filterFactory.destroy();
            TextLayer.cleanup();
            this._networkStream?.cancelAllRequests(new AbortException("Worker was terminated."));
            this.messageHandler?.destroy();
            this.messageHandler = null;
            this.destroyCapability.resolve();
        }, this.destroyCapability.reject);
        return this.destroyCapability.promise;
    }
    setupMessageHandler() {
        const { messageHandler, loadingTask } = this;
        messageHandler.on("GetReader", (data, sink)=>{
            assert(this._networkStream, "GetReader - no `IPDFStream` instance available.");
            this._fullReader = this._networkStream.getFullReader();
            this._fullReader.onProgress = (evt)=>{
                this._lastProgress = {
                    loaded: evt.loaded,
                    total: evt.total
                };
            };
            sink.onPull = ()=>{
                this._fullReader.read().then(function({ value, done }) {
                    if (done) {
                        sink.close();
                        return;
                    }
                    assert(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
                    sink.enqueue(new Uint8Array(value), 1, [
                        value
                    ]);
                }).catch((reason)=>{
                    sink.error(reason);
                });
            };
            sink.onCancel = (reason)=>{
                this._fullReader.cancel(reason);
                sink.ready.catch((readyReason)=>{
                    if (this.destroyed) return;
                    throw readyReason;
                });
            };
        });
        messageHandler.on("ReaderHeadersReady", async (data)=>{
            await this._fullReader.headersReady;
            const { isStreamingSupported, isRangeSupported, contentLength } = this._fullReader;
            if (!isStreamingSupported || !isRangeSupported) {
                if (this._lastProgress) loadingTask.onProgress?.(this._lastProgress);
                this._fullReader.onProgress = (evt)=>{
                    loadingTask.onProgress?.({
                        loaded: evt.loaded,
                        total: evt.total
                    });
                };
            }
            return {
                isStreamingSupported,
                isRangeSupported,
                contentLength
            };
        });
        messageHandler.on("GetRangeReader", (data, sink)=>{
            assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
            if (!rangeReader) {
                sink.close();
                return;
            }
            sink.onPull = ()=>{
                rangeReader.read().then(function({ value, done }) {
                    if (done) {
                        sink.close();
                        return;
                    }
                    assert(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
                    sink.enqueue(new Uint8Array(value), 1, [
                        value
                    ]);
                }).catch((reason)=>{
                    sink.error(reason);
                });
            };
            sink.onCancel = (reason)=>{
                rangeReader.cancel(reason);
                sink.ready.catch((readyReason)=>{
                    if (this.destroyed) return;
                    throw readyReason;
                });
            };
        });
        messageHandler.on("GetDoc", ({ pdfInfo })=>{
            this._numPages = pdfInfo.numPages;
            this._htmlForXfa = pdfInfo.htmlForXfa;
            delete pdfInfo.htmlForXfa;
            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
        });
        messageHandler.on("DocException", (ex)=>{
            loadingTask._capability.reject(wrapReason(ex));
        });
        messageHandler.on("PasswordRequest", (ex)=>{
            this.#passwordCapability = Promise.withResolvers();
            try {
                if (!loadingTask.onPassword) throw wrapReason(ex);
                const updatePassword = (password)=>{
                    if (password instanceof Error) this.#passwordCapability.reject(password);
                    else this.#passwordCapability.resolve({
                        password
                    });
                };
                loadingTask.onPassword(updatePassword, ex.code);
            } catch (err) {
                this.#passwordCapability.reject(err);
            }
            return this.#passwordCapability.promise;
        });
        messageHandler.on("DataLoaded", (data)=>{
            loadingTask.onProgress?.({
                loaded: data.length,
                total: data.length
            });
            this.downloadInfoCapability.resolve(data);
        });
        messageHandler.on("StartRenderPage", (data)=>{
            if (this.destroyed) return;
            const page = this.#pageCache.get(data.pageIndex);
            page._startRenderPage(data.transparency, data.cacheKey);
        });
        messageHandler.on("commonobj", ([id, type, exportedData])=>{
            if (this.destroyed) return null;
            if (this.commonObjs.has(id)) return null;
            switch(type){
                case "Font":
                    const { disableFontFace, fontExtraProperties, pdfBug } = this._params;
                    if ("error" in exportedData) {
                        const exportedError = exportedData.error;
                        warn(`Error during font loading: ${exportedError}`);
                        this.commonObjs.resolve(id, exportedError);
                        break;
                    }
                    const inspectFont = pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;
                    const font = new FontFaceObject(exportedData, {
                        disableFontFace,
                        fontExtraProperties,
                        inspectFont
                    });
                    this.fontLoader.bind(font).catch(()=>messageHandler.sendWithPromise("FontFallback", {
                            id
                        })).finally(()=>{
                        if (!fontExtraProperties && font.data) font.data = null;
                        this.commonObjs.resolve(id, font);
                    });
                    break;
                case "CopyLocalImage":
                    const { imageRef } = exportedData;
                    assert(imageRef, "The imageRef must be defined.");
                    for (const pageProxy of this.#pageCache.values())for (const [, data] of pageProxy.objs){
                        if (data?.ref !== imageRef) continue;
                        if (!data.dataLen) return null;
                        this.commonObjs.resolve(id, structuredClone(data));
                        return data.dataLen;
                    }
                    break;
                case "FontPath":
                case "Image":
                case "Pattern":
                    this.commonObjs.resolve(id, exportedData);
                    break;
                default:
                    throw new Error(`Got unknown common object type ${type}`);
            }
            return null;
        });
        messageHandler.on("obj", ([id, pageIndex, type, imageData])=>{
            if (this.destroyed) return;
            const pageProxy = this.#pageCache.get(pageIndex);
            if (pageProxy.objs.has(id)) return;
            if (pageProxy._intentStates.size === 0) {
                imageData?.bitmap?.close();
                return;
            }
            switch(type){
                case "Image":
                    pageProxy.objs.resolve(id, imageData);
                    if (imageData?.dataLen > MAX_IMAGE_SIZE_TO_CACHE) pageProxy._maybeCleanupAfterRender = true;
                    break;
                case "Pattern":
                    pageProxy.objs.resolve(id, imageData);
                    break;
                default:
                    throw new Error(`Got unknown object type ${type}`);
            }
        });
        messageHandler.on("DocProgress", (data)=>{
            if (this.destroyed) return;
            loadingTask.onProgress?.({
                loaded: data.loaded,
                total: data.total
            });
        });
        messageHandler.on("FetchBuiltInCMap", async (data)=>{
            if (this.destroyed) throw new Error("Worker was destroyed.");
            if (!this.cMapReaderFactory) throw new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.");
            return this.cMapReaderFactory.fetch(data);
        });
        messageHandler.on("FetchStandardFontData", async (data)=>{
            if (this.destroyed) throw new Error("Worker was destroyed.");
            if (!this.standardFontDataFactory) throw new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.");
            return this.standardFontDataFactory.fetch(data);
        });
    }
    getData() {
        return this.messageHandler.sendWithPromise("GetData", null);
    }
    saveDocument() {
        if (this.annotationStorage.size <= 0) warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
        const { map, transfer } = this.annotationStorage.serializable;
        return this.messageHandler.sendWithPromise("SaveDocument", {
            isPureXfa: !!this._htmlForXfa,
            numPages: this._numPages,
            annotationStorage: map,
            filename: this._fullReader?.filename ?? null
        }, transfer).finally(()=>{
            this.annotationStorage.resetModified();
        });
    }
    getPage(pageNumber) {
        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) return Promise.reject(new Error("Invalid page request."));
        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);
        if (cachedPromise) return cachedPromise;
        const promise = this.messageHandler.sendWithPromise("GetPage", {
            pageIndex
        }).then((pageInfo)=>{
            if (this.destroyed) throw new Error("Transport destroyed");
            if (pageInfo.refStr) this.#pageRefCache.set(pageInfo.refStr, pageNumber);
            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
            this.#pageCache.set(pageIndex, page);
            return page;
        });
        this.#pagePromises.set(pageIndex, promise);
        return promise;
    }
    getPageIndex(ref) {
        if (!isRefProxy(ref)) return Promise.reject(new Error("Invalid pageIndex request."));
        return this.messageHandler.sendWithPromise("GetPageIndex", {
            num: ref.num,
            gen: ref.gen
        });
    }
    getAnnotations(pageIndex, intent) {
        return this.messageHandler.sendWithPromise("GetAnnotations", {
            pageIndex,
            intent
        });
    }
    getFieldObjects() {
        return this.#cacheSimpleMethod("GetFieldObjects");
    }
    hasJSActions() {
        return this.#cacheSimpleMethod("HasJSActions");
    }
    getCalculationOrderIds() {
        return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
    }
    getDestinations() {
        return this.messageHandler.sendWithPromise("GetDestinations", null);
    }
    getDestination(id) {
        if (typeof id !== "string") return Promise.reject(new Error("Invalid destination request."));
        return this.messageHandler.sendWithPromise("GetDestination", {
            id
        });
    }
    getPageLabels() {
        return this.messageHandler.sendWithPromise("GetPageLabels", null);
    }
    getPageLayout() {
        return this.messageHandler.sendWithPromise("GetPageLayout", null);
    }
    getPageMode() {
        return this.messageHandler.sendWithPromise("GetPageMode", null);
    }
    getViewerPreferences() {
        return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
    }
    getOpenAction() {
        return this.messageHandler.sendWithPromise("GetOpenAction", null);
    }
    getAttachments() {
        return this.messageHandler.sendWithPromise("GetAttachments", null);
    }
    getDocJSActions() {
        return this.#cacheSimpleMethod("GetDocJSActions");
    }
    getPageJSActions(pageIndex) {
        return this.messageHandler.sendWithPromise("GetPageJSActions", {
            pageIndex
        });
    }
    getStructTree(pageIndex) {
        return this.messageHandler.sendWithPromise("GetStructTree", {
            pageIndex
        });
    }
    getOutline() {
        return this.messageHandler.sendWithPromise("GetOutline", null);
    }
    getOptionalContentConfig(renderingIntent) {
        return this.#cacheSimpleMethod("GetOptionalContentConfig").then((data)=>new OptionalContentConfig(data, renderingIntent));
    }
    getPermissions() {
        return this.messageHandler.sendWithPromise("GetPermissions", null);
    }
    getMetadata() {
        const name = "GetMetadata", cachedPromise = this.#methodPromises.get(name);
        if (cachedPromise) return cachedPromise;
        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>({
                info: results[0],
                metadata: results[1] ? new Metadata(results[1]) : null,
                contentDispositionFilename: this._fullReader?.filename ?? null,
                contentLength: this._fullReader?.contentLength ?? null
            }));
        this.#methodPromises.set(name, promise);
        return promise;
    }
    getMarkInfo() {
        return this.messageHandler.sendWithPromise("GetMarkInfo", null);
    }
    async startCleanup(keepLoadedFonts = false) {
        if (this.destroyed) return;
        await this.messageHandler.sendWithPromise("Cleanup", null);
        for (const page of this.#pageCache.values()){
            const cleanupSuccessful = page.cleanup();
            if (!cleanupSuccessful) throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
        }
        this.commonObjs.clear();
        if (!keepLoadedFonts) this.fontLoader.clear();
        this.#methodPromises.clear();
        this.filterFactory.destroy(true);
        TextLayer.cleanup();
    }
    cachedPageNumber(ref) {
        if (!isRefProxy(ref)) return null;
        const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;
        return this.#pageRefCache.get(refStr) ?? null;
    }
}
const INITIAL_DATA = Symbol("INITIAL_DATA");
class PDFObjects {
    #objs = Object.create(null);
    #ensureObj(objId) {
        return this.#objs[objId] ||= {
            ...Promise.withResolvers(),
            data: INITIAL_DATA
        };
    }
    get(objId, callback = null) {
        if (callback) {
            const obj = this.#ensureObj(objId);
            obj.promise.then(()=>callback(obj.data));
            return null;
        }
        const obj = this.#objs[objId];
        if (!obj || obj.data === INITIAL_DATA) throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
        return obj.data;
    }
    has(objId) {
        const obj = this.#objs[objId];
        return !!obj && obj.data !== INITIAL_DATA;
    }
    delete(objId) {
        const obj = this.#objs[objId];
        if (!obj || obj.data === INITIAL_DATA) return false;
        delete this.#objs[objId];
        return true;
    }
    resolve(objId, data = null) {
        const obj = this.#ensureObj(objId);
        obj.data = data;
        obj.resolve();
    }
    clear() {
        for(const objId in this.#objs){
            const { data } = this.#objs[objId];
            data?.bitmap?.close();
        }
        this.#objs = Object.create(null);
    }
    *[Symbol.iterator]() {
        for(const objId in this.#objs){
            const { data } = this.#objs[objId];
            if (data === INITIAL_DATA) continue;
            yield [
                objId,
                data
            ];
        }
    }
}
class RenderTask {
    #internalRenderTask = null;
    constructor(internalRenderTask){
        this.#internalRenderTask = internalRenderTask;
        this.onContinue = null;
    }
    get promise() {
        return this.#internalRenderTask.capability.promise;
    }
    cancel(extraDelay = 0) {
        this.#internalRenderTask.cancel(null, extraDelay);
    }
    get separateAnnots() {
        const { separateAnnots } = this.#internalRenderTask.operatorList;
        if (!separateAnnots) return false;
        const { annotationCanvasMap } = this.#internalRenderTask;
        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
    }
}
class InternalRenderTask {
    #rAF = null;
    static #canvasInUse = new WeakSet();
    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null }){
        this.callback = callback;
        this.params = params;
        this.objs = objs;
        this.commonObjs = commonObjs;
        this.annotationCanvasMap = annotationCanvasMap;
        this.operatorListIdx = null;
        this.operatorList = operatorList;
        this._pageIndex = pageIndex;
        this.canvasFactory = canvasFactory;
        this.filterFactory = filterFactory;
        this._pdfBug = pdfBug;
        this.pageColors = pageColors;
        this.running = false;
        this.graphicsReadyCallback = null;
        this.graphicsReady = false;
        this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
        this.cancelled = false;
        this.capability = Promise.withResolvers();
        this.task = new RenderTask(this);
        this._cancelBound = this.cancel.bind(this);
        this._continueBound = this._continue.bind(this);
        this._scheduleNextBound = this._scheduleNext.bind(this);
        this._nextBound = this._next.bind(this);
        this._canvas = params.canvasContext.canvas;
    }
    get completed() {
        return this.capability.promise.catch(function() {});
    }
    initializeGraphics({ transparency = false, optionalContentConfig }) {
        if (this.cancelled) return;
        if (this._canvas) {
            if (InternalRenderTask.#canvasInUse.has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
            InternalRenderTask.#canvasInUse.add(this._canvas);
        }
        if (this._pdfBug && globalThis.StepperManager?.enabled) {
            this.stepper = globalThis.StepperManager.create(this._pageIndex);
            this.stepper.init(this.operatorList);
            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
        }
        const { canvasContext, viewport, transform, background } = this.params;
        this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
            optionalContentConfig
        }, this.annotationCanvasMap, this.pageColors);
        this.gfx.beginDrawing({
            transform,
            viewport,
            transparency,
            background
        });
        this.operatorListIdx = 0;
        this.graphicsReady = true;
        this.graphicsReadyCallback?.();
    }
    cancel(error = null, extraDelay = 0) {
        this.running = false;
        this.cancelled = true;
        this.gfx?.endDrawing();
        if (this.#rAF) {
            window.cancelAnimationFrame(this.#rAF);
            this.#rAF = null;
        }
        InternalRenderTask.#canvasInUse.delete(this._canvas);
        this.callback(error || new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));
    }
    operatorListChanged() {
        if (!this.graphicsReady) {
            this.graphicsReadyCallback ||= this._continueBound;
            return;
        }
        this.stepper?.updateOperatorList(this.operatorList);
        if (this.running) return;
        this._continue();
    }
    _continue() {
        this.running = true;
        if (this.cancelled) return;
        if (this.task.onContinue) this.task.onContinue(this._scheduleNextBound);
        else this._scheduleNext();
    }
    _scheduleNext() {
        if (this._useRequestAnimationFrame) this.#rAF = window.requestAnimationFrame(()=>{
            this.#rAF = null;
            this._nextBound().catch(this._cancelBound);
        });
        else Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
    async _next() {
        if (this.cancelled) return;
        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
        if (this.operatorListIdx === this.operatorList.argsArray.length) {
            this.running = false;
            if (this.operatorList.lastChunk) {
                this.gfx.endDrawing();
                InternalRenderTask.#canvasInUse.delete(this._canvas);
                this.callback();
            }
        }
    }
}
const version = "4.10.38";
const build = "f9bea397f";
function makeColorComp(n) {
    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}
function scaleAndClamp(x) {
    return Math.max(0, Math.min(255, 255 * x));
}
class ColorConverters {
    static CMYK_G([c, y, m, k]) {
        return [
            "G",
            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)
        ];
    }
    static G_CMYK([g]) {
        return [
            "CMYK",
            0,
            0,
            0,
            1 - g
        ];
    }
    static G_RGB([g]) {
        return [
            "RGB",
            g,
            g,
            g
        ];
    }
    static G_rgb([g]) {
        g = scaleAndClamp(g);
        return [
            g,
            g,
            g
        ];
    }
    static G_HTML([g]) {
        const G = makeColorComp(g);
        return `#${G}${G}${G}`;
    }
    static RGB_G([r, g, b]) {
        return [
            "G",
            0.3 * r + 0.59 * g + 0.11 * b
        ];
    }
    static RGB_rgb(color) {
        return color.map(scaleAndClamp);
    }
    static RGB_HTML(color) {
        return `#${color.map(makeColorComp).join("")}`;
    }
    static T_HTML() {
        return "#00000000";
    }
    static T_rgb() {
        return [
            null
        ];
    }
    static CMYK_RGB([c, y, m, k]) {
        return [
            "RGB",
            1 - Math.min(1, c + k),
            1 - Math.min(1, m + k),
            1 - Math.min(1, y + k)
        ];
    }
    static CMYK_rgb([c, y, m, k]) {
        return [
            scaleAndClamp(1 - Math.min(1, c + k)),
            scaleAndClamp(1 - Math.min(1, m + k)),
            scaleAndClamp(1 - Math.min(1, y + k))
        ];
    }
    static CMYK_HTML(components) {
        const rgb = this.CMYK_RGB(components).slice(1);
        return this.RGB_HTML(rgb);
    }
    static RGB_CMYK([r, g, b]) {
        const c = 1 - r;
        const m = 1 - g;
        const y = 1 - b;
        const k = Math.min(c, m, y);
        return [
            "CMYK",
            c,
            m,
            y,
            k
        ];
    }
}
class BaseSVGFactory {
    create(width, height, skipDimensions = false) {
        if (width <= 0 || height <= 0) throw new Error("Invalid SVG dimensions");
        const svg = this._createSVG("svg:svg");
        svg.setAttribute("version", "1.1");
        if (!skipDimensions) {
            svg.setAttribute("width", `${width}px`);
            svg.setAttribute("height", `${height}px`);
        }
        svg.setAttribute("preserveAspectRatio", "none");
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        return svg;
    }
    createElement(type) {
        if (typeof type !== "string") throw new Error("Invalid SVG element type");
        return this._createSVG(type);
    }
    _createSVG(type) {
        unreachable("Abstract method `_createSVG` called.");
    }
}
class DOMSVGFactory extends BaseSVGFactory {
    _createSVG(type) {
        return document.createElementNS(SVG_NS, type);
    }
}
class XfaLayer {
    static setupStorage(html, id, element, storage, intent) {
        const storedData = storage.getValue(id, {
            value: null
        });
        switch(element.name){
            case "textarea":
                if (storedData.value !== null) html.textContent = storedData.value;
                if (intent === "print") break;
                html.addEventListener("input", (event)=>{
                    storage.setValue(id, {
                        value: event.target.value
                    });
                });
                break;
            case "input":
                if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                    if (storedData.value === element.attributes.xfaOn) html.setAttribute("checked", true);
                    else if (storedData.value === element.attributes.xfaOff) html.removeAttribute("checked");
                    if (intent === "print") break;
                    html.addEventListener("change", (event)=>{
                        storage.setValue(id, {
                            value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                        });
                    });
                } else {
                    if (storedData.value !== null) html.setAttribute("value", storedData.value);
                    if (intent === "print") break;
                    html.addEventListener("input", (event)=>{
                        storage.setValue(id, {
                            value: event.target.value
                        });
                    });
                }
                break;
            case "select":
                if (storedData.value !== null) {
                    html.setAttribute("value", storedData.value);
                    for (const option of element.children){
                        if (option.attributes.value === storedData.value) option.attributes.selected = true;
                        else if (option.attributes.hasOwnProperty("selected")) delete option.attributes.selected;
                    }
                }
                html.addEventListener("input", (event)=>{
                    const options = event.target.options;
                    const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                    storage.setValue(id, {
                        value
                    });
                });
                break;
        }
    }
    static setAttributes({ html, element, storage = null, intent, linkService }) {
        const { attributes } = element;
        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
        if (attributes.type === "radio") attributes.name = `${attributes.name}-${intent}`;
        for (const [key, value] of Object.entries(attributes)){
            if (value === null || value === undefined) continue;
            switch(key){
                case "class":
                    if (value.length) html.setAttribute(key, value.join(" "));
                    break;
                case "dataId":
                    break;
                case "id":
                    html.setAttribute("data-element-id", value);
                    break;
                case "style":
                    Object.assign(html.style, value);
                    break;
                case "textContent":
                    html.textContent = value;
                    break;
                default:
                    if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") html.setAttribute(key, value);
            }
        }
        if (isHTMLAnchorElement) linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
        if (storage && attributes.dataId) this.setupStorage(html, attributes.dataId, element, storage);
    }
    static render(parameters) {
        const storage = parameters.annotationStorage;
        const linkService = parameters.linkService;
        const root = parameters.xfaHtml;
        const intent = parameters.intent || "display";
        const rootHtml = document.createElement(root.name);
        if (root.attributes) this.setAttributes({
            html: rootHtml,
            element: root,
            intent,
            linkService
        });
        const isNotForRichText = intent !== "richText";
        const rootDiv = parameters.div;
        rootDiv.append(rootHtml);
        if (parameters.viewport) {
            const transform = `matrix(${parameters.viewport.transform.join(",")})`;
            rootDiv.style.transform = transform;
        }
        if (isNotForRichText) rootDiv.setAttribute("class", "xfaLayer xfaFont");
        const textDivs = [];
        if (root.children.length === 0) {
            if (root.value) {
                const node = document.createTextNode(root.value);
                rootHtml.append(node);
                if (isNotForRichText && XfaText.shouldBuildText(root.name)) textDivs.push(node);
            }
            return {
                textDivs
            };
        }
        const stack = [
            [
                root,
                -1,
                rootHtml
            ]
        ];
        while(stack.length > 0){
            const [parent, i, html] = stack.at(-1);
            if (i + 1 === parent.children.length) {
                stack.pop();
                continue;
            }
            const child = parent.children[++stack.at(-1)[1]];
            if (child === null) continue;
            const { name } = child;
            if (name === "#text") {
                const node = document.createTextNode(child.value);
                textDivs.push(node);
                html.append(node);
                continue;
            }
            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
            html.append(childHtml);
            if (child.attributes) this.setAttributes({
                html: childHtml,
                element: child,
                storage,
                intent,
                linkService
            });
            if (child.children?.length > 0) stack.push([
                child,
                -1,
                childHtml
            ]);
            else if (child.value) {
                const node = document.createTextNode(child.value);
                if (isNotForRichText && XfaText.shouldBuildText(name)) textDivs.push(node);
                childHtml.append(node);
            }
        }
        for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))el.setAttribute("readOnly", true);
        return {
            textDivs
        };
    }
    static update(parameters) {
        const transform = `matrix(${parameters.viewport.transform.join(",")})`;
        parameters.div.style.transform = transform;
        parameters.div.hidden = false;
    }
}
const DEFAULT_TAB_INDEX = 1000;
const annotation_layer_DEFAULT_FONT_SIZE = 9;
const GetElementsByNameSet = new WeakSet();
function getRectDims(rect) {
    return {
        width: rect[2] - rect[0],
        height: rect[3] - rect[1]
    };
}
class AnnotationElementFactory {
    static create(parameters) {
        const subtype = parameters.data.annotationType;
        switch(subtype){
            case AnnotationType.LINK:
                return new LinkAnnotationElement(parameters);
            case AnnotationType.TEXT:
                return new TextAnnotationElement(parameters);
            case AnnotationType.WIDGET:
                const fieldType = parameters.data.fieldType;
                switch(fieldType){
                    case "Tx":
                        return new TextWidgetAnnotationElement(parameters);
                    case "Btn":
                        if (parameters.data.radioButton) return new RadioButtonWidgetAnnotationElement(parameters);
                        else if (parameters.data.checkBox) return new CheckboxWidgetAnnotationElement(parameters);
                        return new PushButtonWidgetAnnotationElement(parameters);
                    case "Ch":
                        return new ChoiceWidgetAnnotationElement(parameters);
                    case "Sig":
                        return new SignatureWidgetAnnotationElement(parameters);
                }
                return new WidgetAnnotationElement(parameters);
            case AnnotationType.POPUP:
                return new PopupAnnotationElement(parameters);
            case AnnotationType.FREETEXT:
                return new FreeTextAnnotationElement(parameters);
            case AnnotationType.LINE:
                return new LineAnnotationElement(parameters);
            case AnnotationType.SQUARE:
                return new SquareAnnotationElement(parameters);
            case AnnotationType.CIRCLE:
                return new CircleAnnotationElement(parameters);
            case AnnotationType.POLYLINE:
                return new PolylineAnnotationElement(parameters);
            case AnnotationType.CARET:
                return new CaretAnnotationElement(parameters);
            case AnnotationType.INK:
                return new InkAnnotationElement(parameters);
            case AnnotationType.POLYGON:
                return new PolygonAnnotationElement(parameters);
            case AnnotationType.HIGHLIGHT:
                return new HighlightAnnotationElement(parameters);
            case AnnotationType.UNDERLINE:
                return new UnderlineAnnotationElement(parameters);
            case AnnotationType.SQUIGGLY:
                return new SquigglyAnnotationElement(parameters);
            case AnnotationType.STRIKEOUT:
                return new StrikeOutAnnotationElement(parameters);
            case AnnotationType.STAMP:
                return new StampAnnotationElement(parameters);
            case AnnotationType.FILEATTACHMENT:
                return new FileAttachmentAnnotationElement(parameters);
            default:
                return new AnnotationElement(parameters);
        }
    }
}
class AnnotationElement {
    #updates = null;
    #hasBorder = false;
    #popupElement = null;
    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){
        this.isRenderable = isRenderable;
        this.data = parameters.data;
        this.layer = parameters.layer;
        this.linkService = parameters.linkService;
        this.downloadManager = parameters.downloadManager;
        this.imageResourcesPath = parameters.imageResourcesPath;
        this.renderForms = parameters.renderForms;
        this.svgFactory = parameters.svgFactory;
        this.annotationStorage = parameters.annotationStorage;
        this.enableScripting = parameters.enableScripting;
        this.hasJSActions = parameters.hasJSActions;
        this._fieldObjects = parameters.fieldObjects;
        this.parent = parameters.parent;
        if (isRenderable) this.container = this._createContainer(ignoreBorder);
        if (createQuadrilaterals) this._createQuadrilaterals();
    }
    static _hasPopupData({ titleObj, contentsObj, richText }) {
        return !!(titleObj?.str || contentsObj?.str || richText?.str);
    }
    get _isEditable() {
        return this.data.isEditable;
    }
    get hasPopupData() {
        return AnnotationElement._hasPopupData(this.data);
    }
    updateEdited(params) {
        if (!this.container) return;
        this.#updates ||= {
            rect: this.data.rect.slice(0)
        };
        const { rect } = params;
        if (rect) this.#setRectEdited(rect);
        this.#popupElement?.popup.updateEdited(params);
    }
    resetEdited() {
        if (!this.#updates) return;
        this.#setRectEdited(this.#updates.rect);
        this.#popupElement?.popup.resetEdited();
        this.#updates = null;
    }
    #setRectEdited(rect) {
        const { container: { style }, data: { rect: currentRect, rotation }, parent: { viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } } = this;
        currentRect?.splice(0, 4, ...rect);
        const { width, height } = getRectDims(rect);
        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
        style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;
        if (rotation === 0) {
            style.width = `${100 * width / pageWidth}%`;
            style.height = `${100 * height / pageHeight}%`;
        } else this.setRotation(rotation);
    }
    _createContainer(ignoreBorder) {
        const { data, parent: { page, viewport } } = this;
        const container = document.createElement("section");
        container.setAttribute("data-annotation-id", data.id);
        if (!(this instanceof WidgetAnnotationElement)) container.tabIndex = DEFAULT_TAB_INDEX;
        const { style } = container;
        style.zIndex = this.parent.zIndex++;
        if (data.alternativeText) container.title = data.alternativeText;
        if (data.noRotate) container.classList.add("norotate");
        if (!data.rect || this instanceof PopupAnnotationElement) {
            const { rotation } = data;
            if (!data.hasOwnCanvas && rotation !== 0) this.setRotation(rotation, container);
            return container;
        }
        const { width, height } = getRectDims(data.rect);
        if (!ignoreBorder && data.borderStyle.width > 0) {
            style.borderWidth = `${data.borderStyle.width}px`;
            const horizontalRadius = data.borderStyle.horizontalCornerRadius;
            const verticalRadius = data.borderStyle.verticalCornerRadius;
            if (horizontalRadius > 0 || verticalRadius > 0) {
                const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
                style.borderRadius = radius;
            } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
                style.borderRadius = radius;
            }
            switch(data.borderStyle.style){
                case AnnotationBorderStyleType.SOLID:
                    style.borderStyle = "solid";
                    break;
                case AnnotationBorderStyleType.DASHED:
                    style.borderStyle = "dashed";
                    break;
                case AnnotationBorderStyleType.BEVELED:
                    warn("Unimplemented border style: beveled");
                    break;
                case AnnotationBorderStyleType.INSET:
                    warn("Unimplemented border style: inset");
                    break;
                case AnnotationBorderStyleType.UNDERLINE:
                    style.borderBottomStyle = "solid";
                    break;
                default:
                    break;
            }
            const borderColor = data.borderColor || null;
            if (borderColor) {
                this.#hasBorder = true;
                style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
            } else style.borderWidth = 0;
        }
        const rect = Util.normalizeRect([
            data.rect[0],
            page.view[3] - data.rect[1] + page.view[1],
            data.rect[2],
            page.view[3] - data.rect[3] + page.view[1]
        ]);
        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;
        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
        style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
        const { rotation } = data;
        if (data.hasOwnCanvas || rotation === 0) {
            style.width = `${100 * width / pageWidth}%`;
            style.height = `${100 * height / pageHeight}%`;
        } else this.setRotation(rotation, container);
        return container;
    }
    setRotation(angle, container = this.container) {
        if (!this.data.rect) return;
        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;
        const { width, height } = getRectDims(this.data.rect);
        let elementWidth, elementHeight;
        if (angle % 180 === 0) {
            elementWidth = 100 * width / pageWidth;
            elementHeight = 100 * height / pageHeight;
        } else {
            elementWidth = 100 * height / pageWidth;
            elementHeight = 100 * width / pageHeight;
        }
        container.style.width = `${elementWidth}%`;
        container.style.height = `${elementHeight}%`;
        container.setAttribute("data-main-rotation", (360 - angle) % 360);
    }
    get _commonActions() {
        const setColor = (jsName, styleName, event)=>{
            const color = event.detail[jsName];
            const colorType = color[0];
            const colorArray = color.slice(1);
            event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);
            this.annotationStorage.setValue(this.data.id, {
                [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)
            });
        };
        return shadow(this, "_commonActions", {
            display: (event)=>{
                const { display } = event.detail;
                const hidden = display % 2 === 1;
                this.container.style.visibility = hidden ? "hidden" : "visible";
                this.annotationStorage.setValue(this.data.id, {
                    noView: hidden,
                    noPrint: display === 1 || display === 2
                });
            },
            print: (event)=>{
                this.annotationStorage.setValue(this.data.id, {
                    noPrint: !event.detail.print
                });
            },
            hidden: (event)=>{
                const { hidden } = event.detail;
                this.container.style.visibility = hidden ? "hidden" : "visible";
                this.annotationStorage.setValue(this.data.id, {
                    noPrint: hidden,
                    noView: hidden
                });
            },
            focus: (event)=>{
                setTimeout(()=>event.target.focus({
                        preventScroll: false
                    }), 0);
            },
            userName: (event)=>{
                event.target.title = event.detail.userName;
            },
            readonly: (event)=>{
                event.target.disabled = event.detail.readonly;
            },
            required: (event)=>{
                this._setRequired(event.target, event.detail.required);
            },
            bgColor: (event)=>{
                setColor("bgColor", "backgroundColor", event);
            },
            fillColor: (event)=>{
                setColor("fillColor", "backgroundColor", event);
            },
            fgColor: (event)=>{
                setColor("fgColor", "color", event);
            },
            textColor: (event)=>{
                setColor("textColor", "color", event);
            },
            borderColor: (event)=>{
                setColor("borderColor", "borderColor", event);
            },
            strokeColor: (event)=>{
                setColor("strokeColor", "borderColor", event);
            },
            rotation: (event)=>{
                const angle = event.detail.rotation;
                this.setRotation(angle);
                this.annotationStorage.setValue(this.data.id, {
                    rotation: angle
                });
            }
        });
    }
    _dispatchEventFromSandbox(actions, jsEvent) {
        const commonActions = this._commonActions;
        for (const name of Object.keys(jsEvent.detail)){
            const action = actions[name] || commonActions[name];
            action?.(jsEvent);
        }
    }
    _setDefaultPropertiesFromJS(element) {
        if (!this.enableScripting) return;
        const storedData = this.annotationStorage.getRawValue(this.data.id);
        if (!storedData) return;
        const commonActions = this._commonActions;
        for (const [actionName, detail] of Object.entries(storedData)){
            const action = commonActions[actionName];
            if (action) {
                const eventProxy = {
                    detail: {
                        [actionName]: detail
                    },
                    target: element
                };
                action(eventProxy);
                delete storedData[actionName];
            }
        }
    }
    _createQuadrilaterals() {
        if (!this.container) return;
        const { quadPoints } = this.data;
        if (!quadPoints) return;
        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x)=>Math.fround(x));
        if (quadPoints.length === 8) {
            const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);
            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) return;
        }
        const { style } = this.container;
        let svgBuffer;
        if (this.#hasBorder) {
            const { borderColor, borderWidth } = style;
            style.borderWidth = 0;
            svgBuffer = [
                "url('data:image/svg+xml;utf8,",
                `<svg xmlns="http://www.w3.org/2000/svg"`,
                ` preserveAspectRatio="none" viewBox="0 0 1 1">`,
                `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`
            ];
            this.container.classList.add("hasBorder");
        }
        const width = rectTrX - rectBlX;
        const height = rectTrY - rectBlY;
        const { svgFactory } = this;
        const svg = svgFactory.createElement("svg");
        svg.classList.add("quadrilateralsContainer");
        svg.setAttribute("width", 0);
        svg.setAttribute("height", 0);
        const defs = svgFactory.createElement("defs");
        svg.append(defs);
        const clipPath = svgFactory.createElement("clipPath");
        const id = `clippath_${this.data.id}`;
        clipPath.setAttribute("id", id);
        clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
        defs.append(clipPath);
        for(let i = 2, ii = quadPoints.length; i < ii; i += 8){
            const trX = quadPoints[i];
            const trY = quadPoints[i + 1];
            const blX = quadPoints[i + 2];
            const blY = quadPoints[i + 3];
            const rect = svgFactory.createElement("rect");
            const x = (blX - rectBlX) / width;
            const y = (rectTrY - trY) / height;
            const rectWidth = (trX - blX) / width;
            const rectHeight = (trY - blY) / height;
            rect.setAttribute("x", x);
            rect.setAttribute("y", y);
            rect.setAttribute("width", rectWidth);
            rect.setAttribute("height", rectHeight);
            clipPath.append(rect);
            svgBuffer?.push(`<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`);
        }
        if (this.#hasBorder) {
            svgBuffer.push(`</g></svg>')`);
            style.backgroundImage = svgBuffer.join("");
        }
        this.container.append(svg);
        this.container.style.clipPath = `url(#${id})`;
    }
    _createPopup() {
        const { data } = this;
        const popup = this.#popupElement = new PopupAnnotationElement({
            data: {
                color: data.color,
                titleObj: data.titleObj,
                modificationDate: data.modificationDate,
                contentsObj: data.contentsObj,
                richText: data.richText,
                parentRect: data.rect,
                borderStyle: 0,
                id: `popup_${data.id}`,
                rotation: data.rotation
            },
            parent: this.parent,
            elements: [
                this
            ]
        });
        this.parent.div.append(popup.render());
    }
    render() {
        unreachable("Abstract method `AnnotationElement.render` called");
    }
    _getElementsByName(name, skipId = null) {
        const fields = [];
        if (this._fieldObjects) {
            const fieldObj = this._fieldObjects[name];
            if (fieldObj) for (const { page, id, exportValues } of fieldObj){
                if (page === -1) continue;
                if (id === skipId) continue;
                const exportValue = typeof exportValues === "string" ? exportValues : null;
                const domElement = document.querySelector(`[data-element-id="${id}"]`);
                if (domElement && !GetElementsByNameSet.has(domElement)) {
                    warn(`_getElementsByName - element not allowed: ${id}`);
                    continue;
                }
                fields.push({
                    id,
                    exportValue,
                    domElement
                });
            }
            return fields;
        }
        for (const domElement of document.getElementsByName(name)){
            const { exportValue } = domElement;
            const id = domElement.getAttribute("data-element-id");
            if (id === skipId) continue;
            if (!GetElementsByNameSet.has(domElement)) continue;
            fields.push({
                id,
                exportValue,
                domElement
            });
        }
        return fields;
    }
    show() {
        if (this.container) this.container.hidden = false;
        this.popup?.maybeShow();
    }
    hide() {
        if (this.container) this.container.hidden = true;
        this.popup?.forceHide();
    }
    getElementsToTriggerPopup() {
        return this.container;
    }
    addHighlightArea() {
        const triggers = this.getElementsToTriggerPopup();
        if (Array.isArray(triggers)) for (const element of triggers)element.classList.add("highlightArea");
        else triggers.classList.add("highlightArea");
    }
    _editOnDoubleClick() {
        if (!this._isEditable) return;
        const { annotationEditorType: mode, data: { id: editId } } = this;
        this.container.addEventListener("dblclick", ()=>{
            this.linkService.eventBus?.dispatch("switchannotationeditormode", {
                source: this,
                mode,
                editId
            });
        });
    }
}
class LinkAnnotationElement extends AnnotationElement {
    constructor(parameters, options = null){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: !!options?.ignoreBorder,
            createQuadrilaterals: true
        });
        this.isTooltipOnly = parameters.data.isTooltipOnly;
    }
    render() {
        const { data, linkService } = this;
        const link = document.createElement("a");
        link.setAttribute("data-element-id", data.id);
        let isBound = false;
        if (data.url) {
            linkService.addLinkAttributes(link, data.url, data.newWindow);
            isBound = true;
        } else if (data.action) {
            this._bindNamedAction(link, data.action);
            isBound = true;
        } else if (data.attachment) {
            this.#bindAttachment(link, data.attachment, data.attachmentDest);
            isBound = true;
        } else if (data.setOCGState) {
            this.#bindSetOCGState(link, data.setOCGState);
            isBound = true;
        } else if (data.dest) {
            this._bindLink(link, data.dest);
            isBound = true;
        } else {
            if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                this._bindJSAction(link, data);
                isBound = true;
            }
            if (data.resetForm) {
                this._bindResetFormAction(link, data.resetForm);
                isBound = true;
            } else if (this.isTooltipOnly && !isBound) {
                this._bindLink(link, "");
                isBound = true;
            }
        }
        this.container.classList.add("linkAnnotation");
        if (isBound) this.container.append(link);
        return this.container;
    }
    #setInternalLink() {
        this.container.setAttribute("data-internal-link", "");
    }
    _bindLink(link, destination) {
        link.href = this.linkService.getDestinationHash(destination);
        link.onclick = ()=>{
            if (destination) this.linkService.goToDestination(destination);
            return false;
        };
        if (destination || destination === "") this.#setInternalLink();
    }
    _bindNamedAction(link, action) {
        link.href = this.linkService.getAnchorUrl("");
        link.onclick = ()=>{
            this.linkService.executeNamedAction(action);
            return false;
        };
        this.#setInternalLink();
    }
    #bindAttachment(link, attachment, dest = null) {
        link.href = this.linkService.getAnchorUrl("");
        if (attachment.description) link.title = attachment.description;
        link.onclick = ()=>{
            this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);
            return false;
        };
        this.#setInternalLink();
    }
    #bindSetOCGState(link, action) {
        link.href = this.linkService.getAnchorUrl("");
        link.onclick = ()=>{
            this.linkService.executeSetOCGState(action);
            return false;
        };
        this.#setInternalLink();
    }
    _bindJSAction(link, data) {
        link.href = this.linkService.getAnchorUrl("");
        const map = new Map([
            [
                "Action",
                "onclick"
            ],
            [
                "Mouse Up",
                "onmouseup"
            ],
            [
                "Mouse Down",
                "onmousedown"
            ]
        ]);
        for (const name of Object.keys(data.actions)){
            const jsName = map.get(name);
            if (!jsName) continue;
            link[jsName] = ()=>{
                this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                        id: data.id,
                        name
                    }
                });
                return false;
            };
        }
        if (!link.onclick) link.onclick = ()=>false;
        this.#setInternalLink();
    }
    _bindResetFormAction(link, resetForm) {
        const otherClickAction = link.onclick;
        if (!otherClickAction) link.href = this.linkService.getAnchorUrl("");
        this.#setInternalLink();
        if (!this._fieldObjects) {
            warn(`_bindResetFormAction - "resetForm" action not supported, ` + "ensure that the `fieldObjects` parameter is provided.");
            if (!otherClickAction) link.onclick = ()=>false;
            return;
        }
        link.onclick = ()=>{
            otherClickAction?.();
            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;
            const allFields = [];
            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                const fieldIds = new Set(resetFormRefs);
                for (const fieldName of resetFormFields){
                    const fields = this._fieldObjects[fieldName] || [];
                    for (const { id } of fields)fieldIds.add(id);
                }
                for (const fields of Object.values(this._fieldObjects)){
                    for (const field of fields)if (fieldIds.has(field.id) === include) allFields.push(field);
                }
            } else for (const fields of Object.values(this._fieldObjects))allFields.push(...fields);
            const storage = this.annotationStorage;
            const allIds = [];
            for (const field of allFields){
                const { id } = field;
                allIds.push(id);
                switch(field.type){
                    case "text":
                        {
                            const value = field.defaultValue || "";
                            storage.setValue(id, {
                                value
                            });
                            break;
                        }
                    case "checkbox":
                    case "radiobutton":
                        {
                            const value = field.defaultValue === field.exportValues;
                            storage.setValue(id, {
                                value
                            });
                            break;
                        }
                    case "combobox":
                    case "listbox":
                        {
                            const value = field.defaultValue || "";
                            storage.setValue(id, {
                                value
                            });
                            break;
                        }
                    default:
                        continue;
                }
                const domElement = document.querySelector(`[data-element-id="${id}"]`);
                if (!domElement) continue;
                else if (!GetElementsByNameSet.has(domElement)) {
                    warn(`_bindResetFormAction - element not allowed: ${id}`);
                    continue;
                }
                domElement.dispatchEvent(new Event("resetform"));
            }
            if (this.enableScripting) this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                    id: "app",
                    ids: allIds,
                    name: "ResetForm"
                }
            });
            return false;
        };
    }
}
class TextAnnotationElement extends AnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: true
        });
    }
    render() {
        this.container.classList.add("textAnnotation");
        const image = document.createElement("img");
        image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
        image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
        image.setAttribute("data-l10n-args", JSON.stringify({
            type: this.data.name
        }));
        if (!this.data.popupRef && this.hasPopupData) this._createPopup();
        this.container.append(image);
        return this.container;
    }
}
class WidgetAnnotationElement extends AnnotationElement {
    render() {
        return this.container;
    }
    showElementAndHideCanvas(element) {
        if (this.data.hasOwnCanvas) {
            if (element.previousSibling?.nodeName === "CANVAS") element.previousSibling.hidden = true;
            element.hidden = false;
        }
    }
    _getKeyModifier(event) {
        return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
    }
    _setEventListener(element, elementData, baseName, eventName, valueGetter) {
        if (baseName.includes("mouse")) element.addEventListener(baseName, (event)=>{
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                    id: this.data.id,
                    name: eventName,
                    value: valueGetter(event),
                    shift: event.shiftKey,
                    modifier: this._getKeyModifier(event)
                }
            });
        });
        else element.addEventListener(baseName, (event)=>{
            if (baseName === "blur") {
                if (!elementData.focused || !event.relatedTarget) return;
                elementData.focused = false;
            } else if (baseName === "focus") {
                if (elementData.focused) return;
                elementData.focused = true;
            }
            if (!valueGetter) return;
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                    id: this.data.id,
                    name: eventName,
                    value: valueGetter(event)
                }
            });
        });
    }
    _setEventListeners(element, elementData, names, getter) {
        for (const [baseName, eventName] of names)if (eventName === "Action" || this.data.actions?.[eventName]) {
            if (eventName === "Focus" || eventName === "Blur") elementData ||= {
                focused: false
            };
            this._setEventListener(element, elementData, baseName, eventName, getter);
            if (eventName === "Focus" && !this.data.actions?.Blur) this._setEventListener(element, elementData, "blur", "Blur", null);
            else if (eventName === "Blur" && !this.data.actions?.Focus) this._setEventListener(element, elementData, "focus", "Focus", null);
        }
    }
    _setBackgroundColor(element) {
        const color = this.data.backgroundColor || null;
        element.style.backgroundColor = color === null ? "transparent" : Util.makeHexColor(color[0], color[1], color[2]);
    }
    _setTextStyle(element) {
        const TEXT_ALIGNMENT = [
            "left",
            "center",
            "right"
        ];
        const { fontColor } = this.data.defaultAppearanceData;
        const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;
        const style = element.style;
        let computedFontSize;
        const BORDER_SIZE = 2;
        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;
        if (this.data.multiLine) {
            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
            const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
            const lineHeight = height / numberOfLines;
            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));
        } else {
            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));
        }
        style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
        style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
        if (this.data.textAlignment !== null) style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
    _setRequired(element, isRequired) {
        if (isRequired) element.setAttribute("required", true);
        else element.removeAttribute("required");
        element.setAttribute("aria-required", isRequired);
    }
}
class TextWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters){
        const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
        super(parameters, {
            isRenderable
        });
    }
    setPropertyOnSiblings(base, key, value, keyInStorage) {
        const storage = this.annotationStorage;
        for (const element of this._getElementsByName(base.name, base.id)){
            if (element.domElement) element.domElement[key] = value;
            storage.setValue(element.id, {
                [keyInStorage]: value
            });
        }
    }
    render() {
        const storage = this.annotationStorage;
        const id = this.data.id;
        this.container.classList.add("textWidgetAnnotation");
        let element = null;
        if (this.renderForms) {
            const storedData = storage.getValue(id, {
                value: this.data.fieldValue
            });
            let textContent = storedData.value || "";
            const maxLen = storage.getValue(id, {
                charLimit: this.data.maxLen
            }).charLimit;
            if (maxLen && textContent.length > maxLen) textContent = textContent.slice(0, maxLen);
            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join("\n") || null;
            if (fieldFormattedValues && this.data.comb) fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
            const elementData = {
                userValue: textContent,
                formattedValue: fieldFormattedValues,
                lastCommittedValue: null,
                commitKey: 1,
                focused: false
            };
            if (this.data.multiLine) {
                element = document.createElement("textarea");
                element.textContent = fieldFormattedValues ?? textContent;
                if (this.data.doNotScroll) element.style.overflowY = "hidden";
            } else {
                element = document.createElement("input");
                element.type = "text";
                element.setAttribute("value", fieldFormattedValues ?? textContent);
                if (this.data.doNotScroll) element.style.overflowX = "hidden";
            }
            if (this.data.hasOwnCanvas) element.hidden = true;
            GetElementsByNameSet.add(element);
            element.setAttribute("data-element-id", id);
            element.disabled = this.data.readOnly;
            element.name = this.data.fieldName;
            element.tabIndex = DEFAULT_TAB_INDEX;
            this._setRequired(element, this.data.required);
            if (maxLen) element.maxLength = maxLen;
            element.addEventListener("input", (event)=>{
                storage.setValue(id, {
                    value: event.target.value
                });
                this.setPropertyOnSiblings(element, "value", event.target.value, "value");
                elementData.formattedValue = null;
            });
            element.addEventListener("resetform", (event)=>{
                const defaultValue = this.data.defaultFieldValue ?? "";
                element.value = elementData.userValue = defaultValue;
                elementData.formattedValue = null;
            });
            let blurListener = (event)=>{
                const { formattedValue } = elementData;
                if (formattedValue !== null && formattedValue !== undefined) event.target.value = formattedValue;
                event.target.scrollLeft = 0;
            };
            if (this.enableScripting && this.hasJSActions) {
                element.addEventListener("focus", (event)=>{
                    if (elementData.focused) return;
                    const { target } = event;
                    if (elementData.userValue) target.value = elementData.userValue;
                    elementData.lastCommittedValue = target.value;
                    elementData.commitKey = 1;
                    if (!this.data.actions?.Focus) elementData.focused = true;
                });
                element.addEventListener("updatefromsandbox", (jsEvent)=>{
                    this.showElementAndHideCanvas(jsEvent.target);
                    const actions = {
                        value (event) {
                            elementData.userValue = event.detail.value ?? "";
                            storage.setValue(id, {
                                value: elementData.userValue.toString()
                            });
                            event.target.value = elementData.userValue;
                        },
                        formattedValue (event) {
                            const { formattedValue } = event.detail;
                            elementData.formattedValue = formattedValue;
                            if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) event.target.value = formattedValue;
                            storage.setValue(id, {
                                formattedValue
                            });
                        },
                        selRange (event) {
                            event.target.setSelectionRange(...event.detail.selRange);
                        },
                        charLimit: (event)=>{
                            const { charLimit } = event.detail;
                            const { target } = event;
                            if (charLimit === 0) {
                                target.removeAttribute("maxLength");
                                return;
                            }
                            target.setAttribute("maxLength", charLimit);
                            let value = elementData.userValue;
                            if (!value || value.length <= charLimit) return;
                            value = value.slice(0, charLimit);
                            target.value = elementData.userValue = value;
                            storage.setValue(id, {
                                value
                            });
                            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                                source: this,
                                detail: {
                                    id,
                                    name: "Keystroke",
                                    value,
                                    willCommit: true,
                                    commitKey: 1,
                                    selStart: target.selectionStart,
                                    selEnd: target.selectionEnd
                                }
                            });
                        }
                    };
                    this._dispatchEventFromSandbox(actions, jsEvent);
                });
                element.addEventListener("keydown", (event)=>{
                    elementData.commitKey = 1;
                    let commitKey = -1;
                    if (event.key === "Escape") commitKey = 0;
                    else if (event.key === "Enter" && !this.data.multiLine) commitKey = 2;
                    else if (event.key === "Tab") elementData.commitKey = 3;
                    if (commitKey === -1) return;
                    const { value } = event.target;
                    if (elementData.lastCommittedValue === value) return;
                    elementData.lastCommittedValue = value;
                    elementData.userValue = value;
                    this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                            id,
                            name: "Keystroke",
                            value,
                            willCommit: true,
                            commitKey,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                        }
                    });
                });
                const _blurListener = blurListener;
                blurListener = null;
                element.addEventListener("blur", (event)=>{
                    if (!elementData.focused || !event.relatedTarget) return;
                    if (!this.data.actions?.Blur) elementData.focused = false;
                    const { value } = event.target;
                    elementData.userValue = value;
                    if (elementData.lastCommittedValue !== value) this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                            id,
                            name: "Keystroke",
                            value,
                            willCommit: true,
                            commitKey: elementData.commitKey,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                        }
                    });
                    _blurListener(event);
                });
                if (this.data.actions?.Keystroke) element.addEventListener("beforeinput", (event)=>{
                    elementData.lastCommittedValue = null;
                    const { data, target } = event;
                    const { value, selectionStart, selectionEnd } = target;
                    let selStart = selectionStart, selEnd = selectionEnd;
                    switch(event.inputType){
                        case "deleteWordBackward":
                            {
                                const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                                if (match) selStart -= match[0].length;
                                break;
                            }
                        case "deleteWordForward":
                            {
                                const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                                if (match) selEnd += match[0].length;
                                break;
                            }
                        case "deleteContentBackward":
                            if (selectionStart === selectionEnd) selStart -= 1;
                            break;
                        case "deleteContentForward":
                            if (selectionStart === selectionEnd) selEnd += 1;
                            break;
                    }
                    event.preventDefault();
                    this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                            id,
                            name: "Keystroke",
                            value,
                            change: data || "",
                            willCommit: false,
                            selStart,
                            selEnd
                        }
                    });
                });
                this._setEventListeners(element, elementData, [
                    [
                        "focus",
                        "Focus"
                    ],
                    [
                        "blur",
                        "Blur"
                    ],
                    [
                        "mousedown",
                        "Mouse Down"
                    ],
                    [
                        "mouseenter",
                        "Mouse Enter"
                    ],
                    [
                        "mouseleave",
                        "Mouse Exit"
                    ],
                    [
                        "mouseup",
                        "Mouse Up"
                    ]
                ], (event)=>event.target.value);
            }
            if (blurListener) element.addEventListener("blur", blurListener);
            if (this.data.comb) {
                const fieldWidth = this.data.rect[2] - this.data.rect[0];
                const combWidth = fieldWidth / maxLen;
                element.classList.add("comb");
                element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
            }
        } else {
            element = document.createElement("div");
            element.textContent = this.data.fieldValue;
            element.style.verticalAlign = "middle";
            element.style.display = "table-cell";
            if (this.data.hasOwnCanvas) element.hidden = true;
        }
        this._setTextStyle(element);
        this._setBackgroundColor(element);
        this._setDefaultPropertiesFromJS(element);
        this.container.append(element);
        return this.container;
    }
}
class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: !!parameters.data.hasOwnCanvas
        });
    }
}
class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: parameters.renderForms
        });
    }
    render() {
        const storage = this.annotationStorage;
        const data = this.data;
        const id = data.id;
        let value = storage.getValue(id, {
            value: data.exportValue === data.fieldValue
        }).value;
        if (typeof value === "string") {
            value = value !== "Off";
            storage.setValue(id, {
                value
            });
        }
        this.container.classList.add("buttonWidgetAnnotation", "checkBox");
        const element = document.createElement("input");
        GetElementsByNameSet.add(element);
        element.setAttribute("data-element-id", id);
        element.disabled = data.readOnly;
        this._setRequired(element, this.data.required);
        element.type = "checkbox";
        element.name = data.fieldName;
        if (value) element.setAttribute("checked", true);
        element.setAttribute("exportValue", data.exportValue);
        element.tabIndex = DEFAULT_TAB_INDEX;
        element.addEventListener("change", (event)=>{
            const { name, checked } = event.target;
            for (const checkbox of this._getElementsByName(name, id)){
                const curChecked = checked && checkbox.exportValue === data.exportValue;
                if (checkbox.domElement) checkbox.domElement.checked = curChecked;
                storage.setValue(checkbox.id, {
                    value: curChecked
                });
            }
            storage.setValue(id, {
                value: checked
            });
        });
        element.addEventListener("resetform", (event)=>{
            const defaultValue = data.defaultFieldValue || "Off";
            event.target.checked = defaultValue === data.exportValue;
        });
        if (this.enableScripting && this.hasJSActions) {
            element.addEventListener("updatefromsandbox", (jsEvent)=>{
                const actions = {
                    value (event) {
                        event.target.checked = event.detail.value !== "Off";
                        storage.setValue(id, {
                            value: event.target.checked
                        });
                    }
                };
                this._dispatchEventFromSandbox(actions, jsEvent);
            });
            this._setEventListeners(element, null, [
                [
                    "change",
                    "Validate"
                ],
                [
                    "change",
                    "Action"
                ],
                [
                    "focus",
                    "Focus"
                ],
                [
                    "blur",
                    "Blur"
                ],
                [
                    "mousedown",
                    "Mouse Down"
                ],
                [
                    "mouseenter",
                    "Mouse Enter"
                ],
                [
                    "mouseleave",
                    "Mouse Exit"
                ],
                [
                    "mouseup",
                    "Mouse Up"
                ]
            ], (event)=>event.target.checked);
        }
        this._setBackgroundColor(element);
        this._setDefaultPropertiesFromJS(element);
        this.container.append(element);
        return this.container;
    }
}
class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: parameters.renderForms
        });
    }
    render() {
        this.container.classList.add("buttonWidgetAnnotation", "radioButton");
        const storage = this.annotationStorage;
        const data = this.data;
        const id = data.id;
        let value = storage.getValue(id, {
            value: data.fieldValue === data.buttonValue
        }).value;
        if (typeof value === "string") {
            value = value !== data.buttonValue;
            storage.setValue(id, {
                value
            });
        }
        if (value) for (const radio of this._getElementsByName(data.fieldName, id))storage.setValue(radio.id, {
            value: false
        });
        const element = document.createElement("input");
        GetElementsByNameSet.add(element);
        element.setAttribute("data-element-id", id);
        element.disabled = data.readOnly;
        this._setRequired(element, this.data.required);
        element.type = "radio";
        element.name = data.fieldName;
        if (value) element.setAttribute("checked", true);
        element.tabIndex = DEFAULT_TAB_INDEX;
        element.addEventListener("change", (event)=>{
            const { name, checked } = event.target;
            for (const radio of this._getElementsByName(name, id))storage.setValue(radio.id, {
                value: false
            });
            storage.setValue(id, {
                value: checked
            });
        });
        element.addEventListener("resetform", (event)=>{
            const defaultValue = data.defaultFieldValue;
            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
        });
        if (this.enableScripting && this.hasJSActions) {
            const pdfButtonValue = data.buttonValue;
            element.addEventListener("updatefromsandbox", (jsEvent)=>{
                const actions = {
                    value: (event)=>{
                        const checked = pdfButtonValue === event.detail.value;
                        for (const radio of this._getElementsByName(event.target.name)){
                            const curChecked = checked && radio.id === id;
                            if (radio.domElement) radio.domElement.checked = curChecked;
                            storage.setValue(radio.id, {
                                value: curChecked
                            });
                        }
                    }
                };
                this._dispatchEventFromSandbox(actions, jsEvent);
            });
            this._setEventListeners(element, null, [
                [
                    "change",
                    "Validate"
                ],
                [
                    "change",
                    "Action"
                ],
                [
                    "focus",
                    "Focus"
                ],
                [
                    "blur",
                    "Blur"
                ],
                [
                    "mousedown",
                    "Mouse Down"
                ],
                [
                    "mouseenter",
                    "Mouse Enter"
                ],
                [
                    "mouseleave",
                    "Mouse Exit"
                ],
                [
                    "mouseup",
                    "Mouse Up"
                ]
            ], (event)=>event.target.checked);
        }
        this._setBackgroundColor(element);
        this._setDefaultPropertiesFromJS(element);
        this.container.append(element);
        return this.container;
    }
}
class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
    constructor(parameters){
        super(parameters, {
            ignoreBorder: parameters.data.hasAppearance
        });
    }
    render() {
        const container = super.render();
        container.classList.add("buttonWidgetAnnotation", "pushButton");
        const linkElement = container.lastChild;
        if (this.enableScripting && this.hasJSActions && linkElement) {
            this._setDefaultPropertiesFromJS(linkElement);
            linkElement.addEventListener("updatefromsandbox", (jsEvent)=>{
                this._dispatchEventFromSandbox({}, jsEvent);
            });
        }
        return container;
    }
}
class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: parameters.renderForms
        });
    }
    render() {
        this.container.classList.add("choiceWidgetAnnotation");
        const storage = this.annotationStorage;
        const id = this.data.id;
        const storedData = storage.getValue(id, {
            value: this.data.fieldValue
        });
        const selectElement = document.createElement("select");
        GetElementsByNameSet.add(selectElement);
        selectElement.setAttribute("data-element-id", id);
        selectElement.disabled = this.data.readOnly;
        this._setRequired(selectElement, this.data.required);
        selectElement.name = this.data.fieldName;
        selectElement.tabIndex = DEFAULT_TAB_INDEX;
        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
        if (!this.data.combo) {
            selectElement.size = this.data.options.length;
            if (this.data.multiSelect) selectElement.multiple = true;
        }
        selectElement.addEventListener("resetform", (event)=>{
            const defaultValue = this.data.defaultFieldValue;
            for (const option of selectElement.options)option.selected = option.value === defaultValue;
        });
        for (const option of this.data.options){
            const optionElement = document.createElement("option");
            optionElement.textContent = option.displayValue;
            optionElement.value = option.exportValue;
            if (storedData.value.includes(option.exportValue)) {
                optionElement.setAttribute("selected", true);
                addAnEmptyEntry = false;
            }
            selectElement.append(optionElement);
        }
        let removeEmptyEntry = null;
        if (addAnEmptyEntry) {
            const noneOptionElement = document.createElement("option");
            noneOptionElement.value = " ";
            noneOptionElement.setAttribute("hidden", true);
            noneOptionElement.setAttribute("selected", true);
            selectElement.prepend(noneOptionElement);
            removeEmptyEntry = ()=>{
                noneOptionElement.remove();
                selectElement.removeEventListener("input", removeEmptyEntry);
                removeEmptyEntry = null;
            };
            selectElement.addEventListener("input", removeEmptyEntry);
        }
        const getValue = (isExport)=>{
            const name = isExport ? "value" : "textContent";
            const { options, multiple } = selectElement;
            if (!multiple) return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);
        };
        let selectedValues = getValue(false);
        const getItems = (event)=>{
            const options = event.target.options;
            return Array.prototype.map.call(options, (option)=>({
                    displayValue: option.textContent,
                    exportValue: option.value
                }));
        };
        if (this.enableScripting && this.hasJSActions) {
            selectElement.addEventListener("updatefromsandbox", (jsEvent)=>{
                const actions = {
                    value (event) {
                        removeEmptyEntry?.();
                        const value = event.detail.value;
                        const values = new Set(Array.isArray(value) ? value : [
                            value
                        ]);
                        for (const option of selectElement.options)option.selected = values.has(option.value);
                        storage.setValue(id, {
                            value: getValue(true)
                        });
                        selectedValues = getValue(false);
                    },
                    multipleSelection (event) {
                        selectElement.multiple = true;
                    },
                    remove (event) {
                        const options = selectElement.options;
                        const index = event.detail.remove;
                        options[index].selected = false;
                        selectElement.remove(index);
                        if (options.length > 0) {
                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);
                            if (i === -1) options[0].selected = true;
                        }
                        storage.setValue(id, {
                            value: getValue(true),
                            items: getItems(event)
                        });
                        selectedValues = getValue(false);
                    },
                    clear (event) {
                        while(selectElement.length !== 0)selectElement.remove(0);
                        storage.setValue(id, {
                            value: null,
                            items: []
                        });
                        selectedValues = getValue(false);
                    },
                    insert (event) {
                        const { index, displayValue, exportValue } = event.detail.insert;
                        const selectChild = selectElement.children[index];
                        const optionElement = document.createElement("option");
                        optionElement.textContent = displayValue;
                        optionElement.value = exportValue;
                        if (selectChild) selectChild.before(optionElement);
                        else selectElement.append(optionElement);
                        storage.setValue(id, {
                            value: getValue(true),
                            items: getItems(event)
                        });
                        selectedValues = getValue(false);
                    },
                    items (event) {
                        const { items } = event.detail;
                        while(selectElement.length !== 0)selectElement.remove(0);
                        for (const item of items){
                            const { displayValue, exportValue } = item;
                            const optionElement = document.createElement("option");
                            optionElement.textContent = displayValue;
                            optionElement.value = exportValue;
                            selectElement.append(optionElement);
                        }
                        if (selectElement.options.length > 0) selectElement.options[0].selected = true;
                        storage.setValue(id, {
                            value: getValue(true),
                            items: getItems(event)
                        });
                        selectedValues = getValue(false);
                    },
                    indices (event) {
                        const indices = new Set(event.detail.indices);
                        for (const option of event.target.options)option.selected = indices.has(option.index);
                        storage.setValue(id, {
                            value: getValue(true)
                        });
                        selectedValues = getValue(false);
                    },
                    editable (event) {
                        event.target.disabled = !event.detail.editable;
                    }
                };
                this._dispatchEventFromSandbox(actions, jsEvent);
            });
            selectElement.addEventListener("input", (event)=>{
                const exportValue = getValue(true);
                const change = getValue(false);
                storage.setValue(id, {
                    value: exportValue
                });
                event.preventDefault();
                this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                        id,
                        name: "Keystroke",
                        value: selectedValues,
                        change,
                        changeEx: exportValue,
                        willCommit: false,
                        commitKey: 1,
                        keyDown: false
                    }
                });
            });
            this._setEventListeners(selectElement, null, [
                [
                    "focus",
                    "Focus"
                ],
                [
                    "blur",
                    "Blur"
                ],
                [
                    "mousedown",
                    "Mouse Down"
                ],
                [
                    "mouseenter",
                    "Mouse Enter"
                ],
                [
                    "mouseleave",
                    "Mouse Exit"
                ],
                [
                    "mouseup",
                    "Mouse Up"
                ],
                [
                    "input",
                    "Action"
                ],
                [
                    "input",
                    "Validate"
                ]
            ], (event)=>event.target.value);
        } else selectElement.addEventListener("input", function(event) {
            storage.setValue(id, {
                value: getValue(true)
            });
        });
        if (this.data.combo) this._setTextStyle(selectElement);
        this._setBackgroundColor(selectElement);
        this._setDefaultPropertiesFromJS(selectElement);
        this.container.append(selectElement);
        return this.container;
    }
}
class PopupAnnotationElement extends AnnotationElement {
    constructor(parameters){
        const { data, elements } = parameters;
        super(parameters, {
            isRenderable: AnnotationElement._hasPopupData(data)
        });
        this.elements = elements;
        this.popup = null;
    }
    render() {
        this.container.classList.add("popupAnnotation");
        const popup = this.popup = new PopupElement({
            container: this.container,
            color: this.data.color,
            titleObj: this.data.titleObj,
            modificationDate: this.data.modificationDate,
            contentsObj: this.data.contentsObj,
            richText: this.data.richText,
            rect: this.data.rect,
            parentRect: this.data.parentRect || null,
            parent: this.parent,
            elements: this.elements,
            open: this.data.open
        });
        const elementIds = [];
        for (const element of this.elements){
            element.popup = popup;
            element.container.ariaHasPopup = "dialog";
            elementIds.push(element.data.id);
            element.addHighlightArea();
        }
        this.container.setAttribute("aria-controls", elementIds.map((id)=>`${AnnotationPrefix}${id}`).join(","));
        return this.container;
    }
}
class PopupElement {
    #boundKeyDown = this.#keyDown.bind(this);
    #boundHide = this.#hide.bind(this);
    #boundShow = this.#show.bind(this);
    #boundToggle = this.#toggle.bind(this);
    #color = null;
    #container = null;
    #contentsObj = null;
    #dateObj = null;
    #elements = null;
    #parent = null;
    #parentRect = null;
    #pinned = false;
    #popup = null;
    #position = null;
    #rect = null;
    #richText = null;
    #titleObj = null;
    #updates = null;
    #wasVisible = false;
    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open }){
        this.#container = container;
        this.#titleObj = titleObj;
        this.#contentsObj = contentsObj;
        this.#richText = richText;
        this.#parent = parent;
        this.#color = color;
        this.#rect = rect;
        this.#parentRect = parentRect;
        this.#elements = elements;
        this.#dateObj = PDFDateString.toDateObject(modificationDate);
        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());
        for (const element of this.trigger){
            element.addEventListener("click", this.#boundToggle);
            element.addEventListener("mouseenter", this.#boundShow);
            element.addEventListener("mouseleave", this.#boundHide);
            element.classList.add("popupTriggerArea");
        }
        for (const element of elements)element.container?.addEventListener("keydown", this.#boundKeyDown);
        this.#container.hidden = true;
        if (open) this.#toggle();
    }
    render() {
        if (this.#popup) return;
        const popup = this.#popup = document.createElement("div");
        popup.className = "popup";
        if (this.#color) {
            const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);
            if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
            else {
                const BACKGROUND_ENLIGHT = 0.7;
                popup.style.backgroundColor = Util.makeHexColor(...this.#color.map((c)=>Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));
            }
        }
        const header = document.createElement("span");
        header.className = "header";
        const title = document.createElement("h1");
        header.append(title);
        ({ dir: title.dir, str: title.textContent } = this.#titleObj);
        popup.append(header);
        if (this.#dateObj) {
            const modificationDate = document.createElement("span");
            modificationDate.classList.add("popupDate");
            modificationDate.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string");
            modificationDate.setAttribute("data-l10n-args", JSON.stringify({
                dateObj: this.#dateObj.valueOf()
            }));
            header.append(modificationDate);
        }
        const html = this.#html;
        if (html) {
            XfaLayer.render({
                xfaHtml: html,
                intent: "richText",
                div: popup
            });
            popup.lastChild.classList.add("richText", "popupContent");
        } else {
            const contents = this._formatContents(this.#contentsObj);
            popup.append(contents);
        }
        this.#container.append(popup);
    }
    get #html() {
        const richText = this.#richText;
        const contentsObj = this.#contentsObj;
        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) return this.#richText.html || null;
        return null;
    }
    get #fontSize() {
        return this.#html?.attributes?.style?.fontSize || 0;
    }
    get #fontColor() {
        return this.#html?.attributes?.style?.color || null;
    }
    #makePopupContent(text) {
        const popupLines = [];
        const popupContent = {
            str: text,
            html: {
                name: "div",
                attributes: {
                    dir: "auto"
                },
                children: [
                    {
                        name: "p",
                        children: popupLines
                    }
                ]
            }
        };
        const lineAttributes = {
            style: {
                color: this.#fontColor,
                fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--scale-factor))` : ""
            }
        };
        for (const line of text.split("\n"))popupLines.push({
            name: "span",
            value: line,
            attributes: lineAttributes
        });
        return popupContent;
    }
    _formatContents({ str, dir }) {
        const p = document.createElement("p");
        p.classList.add("popupContent");
        p.dir = dir;
        const lines = str.split(/(?:\r\n?|\n)/);
        for(let i = 0, ii = lines.length; i < ii; ++i){
            const line = lines[i];
            p.append(document.createTextNode(line));
            if (i < ii - 1) p.append(document.createElement("br"));
        }
        return p;
    }
    #keyDown(event) {
        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) return;
        if (event.key === "Enter" || event.key === "Escape" && this.#pinned) this.#toggle();
    }
    updateEdited({ rect, popupContent }) {
        this.#updates ||= {
            contentsObj: this.#contentsObj,
            richText: this.#richText
        };
        if (rect) this.#position = null;
        if (popupContent) {
            this.#richText = this.#makePopupContent(popupContent);
            this.#contentsObj = null;
        }
        this.#popup?.remove();
        this.#popup = null;
    }
    resetEdited() {
        if (!this.#updates) return;
        ({ contentsObj: this.#contentsObj, richText: this.#richText } = this.#updates);
        this.#updates = null;
        this.#popup?.remove();
        this.#popup = null;
        this.#position = null;
    }
    #setPosition() {
        if (this.#position !== null) return;
        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;
        let useParentRect = !!this.#parentRect;
        let rect = useParentRect ? this.#parentRect : this.#rect;
        for (const element of this.#elements)if (!rect || Util.intersect(element.data.rect, rect) !== null) {
            rect = element.data.rect;
            useParentRect = true;
            break;
        }
        const normalizedRect = Util.normalizeRect([
            rect[0],
            view[3] - rect[1] + view[1],
            rect[2],
            view[3] - rect[3] + view[1]
        ]);
        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
        const popupLeft = normalizedRect[0] + parentWidth;
        const popupTop = normalizedRect[1];
        this.#position = [
            100 * (popupLeft - pageX) / pageWidth,
            100 * (popupTop - pageY) / pageHeight
        ];
        const { style } = this.#container;
        style.left = `${this.#position[0]}%`;
        style.top = `${this.#position[1]}%`;
    }
    #toggle() {
        this.#pinned = !this.#pinned;
        if (this.#pinned) {
            this.#show();
            this.#container.addEventListener("click", this.#boundToggle);
            this.#container.addEventListener("keydown", this.#boundKeyDown);
        } else {
            this.#hide();
            this.#container.removeEventListener("click", this.#boundToggle);
            this.#container.removeEventListener("keydown", this.#boundKeyDown);
        }
    }
    #show() {
        if (!this.#popup) this.render();
        if (!this.isVisible) {
            this.#setPosition();
            this.#container.hidden = false;
            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;
        } else if (this.#pinned) this.#container.classList.add("focused");
    }
    #hide() {
        this.#container.classList.remove("focused");
        if (this.#pinned || !this.isVisible) return;
        this.#container.hidden = true;
        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;
    }
    forceHide() {
        this.#wasVisible = this.isVisible;
        if (!this.#wasVisible) return;
        this.#container.hidden = true;
    }
    maybeShow() {
        if (!this.#wasVisible) return;
        if (!this.#popup) this.#show();
        this.#wasVisible = false;
        this.#container.hidden = false;
    }
    get isVisible() {
        return this.#container.hidden === false;
    }
}
class FreeTextAnnotationElement extends AnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true
        });
        this.textContent = parameters.data.textContent;
        this.textPosition = parameters.data.textPosition;
        this.annotationEditorType = AnnotationEditorType.FREETEXT;
    }
    render() {
        this.container.classList.add("freeTextAnnotation");
        if (this.textContent) {
            const content = document.createElement("div");
            content.classList.add("annotationTextContent");
            content.setAttribute("role", "comment");
            for (const line of this.textContent){
                const lineSpan = document.createElement("span");
                lineSpan.textContent = line;
                content.append(lineSpan);
            }
            this.container.append(content);
        }
        if (!this.data.popupRef && this.hasPopupData) this._createPopup();
        this._editOnDoubleClick();
        return this.container;
    }
}
class LineAnnotationElement extends AnnotationElement {
    #line = null;
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true
        });
    }
    render() {
        this.container.classList.add("lineAnnotation");
        const data = this.data;
        const { width, height } = getRectDims(data.rect);
        const svg = this.svgFactory.create(width, height, true);
        const line = this.#line = this.svgFactory.createElement("svg:line");
        line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
        line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
        line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
        line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
        line.setAttribute("stroke-width", data.borderStyle.width || 1);
        line.setAttribute("stroke", "transparent");
        line.setAttribute("fill", "transparent");
        svg.append(line);
        this.container.append(svg);
        if (!data.popupRef && this.hasPopupData) this._createPopup();
        return this.container;
    }
    getElementsToTriggerPopup() {
        return this.#line;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
}
class SquareAnnotationElement extends AnnotationElement {
    #square = null;
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true
        });
    }
    render() {
        this.container.classList.add("squareAnnotation");
        const data = this.data;
        const { width, height } = getRectDims(data.rect);
        const svg = this.svgFactory.create(width, height, true);
        const borderWidth = data.borderStyle.width;
        const square = this.#square = this.svgFactory.createElement("svg:rect");
        square.setAttribute("x", borderWidth / 2);
        square.setAttribute("y", borderWidth / 2);
        square.setAttribute("width", width - borderWidth);
        square.setAttribute("height", height - borderWidth);
        square.setAttribute("stroke-width", borderWidth || 1);
        square.setAttribute("stroke", "transparent");
        square.setAttribute("fill", "transparent");
        svg.append(square);
        this.container.append(svg);
        if (!data.popupRef && this.hasPopupData) this._createPopup();
        return this.container;
    }
    getElementsToTriggerPopup() {
        return this.#square;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
}
class CircleAnnotationElement extends AnnotationElement {
    #circle = null;
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true
        });
    }
    render() {
        this.container.classList.add("circleAnnotation");
        const data = this.data;
        const { width, height } = getRectDims(data.rect);
        const svg = this.svgFactory.create(width, height, true);
        const borderWidth = data.borderStyle.width;
        const circle = this.#circle = this.svgFactory.createElement("svg:ellipse");
        circle.setAttribute("cx", width / 2);
        circle.setAttribute("cy", height / 2);
        circle.setAttribute("rx", width / 2 - borderWidth / 2);
        circle.setAttribute("ry", height / 2 - borderWidth / 2);
        circle.setAttribute("stroke-width", borderWidth || 1);
        circle.setAttribute("stroke", "transparent");
        circle.setAttribute("fill", "transparent");
        svg.append(circle);
        this.container.append(svg);
        if (!data.popupRef && this.hasPopupData) this._createPopup();
        return this.container;
    }
    getElementsToTriggerPopup() {
        return this.#circle;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
}
class PolylineAnnotationElement extends AnnotationElement {
    #polyline = null;
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true
        });
        this.containerClassName = "polylineAnnotation";
        this.svgElementName = "svg:polyline";
    }
    render() {
        this.container.classList.add(this.containerClassName);
        const { data: { rect, vertices, borderStyle, popupRef } } = this;
        if (!vertices) return this.container;
        const { width, height } = getRectDims(rect);
        const svg = this.svgFactory.create(width, height, true);
        let points = [];
        for(let i = 0, ii = vertices.length; i < ii; i += 2){
            const x = vertices[i] - rect[0];
            const y = rect[3] - vertices[i + 1];
            points.push(`${x},${y}`);
        }
        points = points.join(" ");
        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);
        polyline.setAttribute("points", points);
        polyline.setAttribute("stroke-width", borderStyle.width || 1);
        polyline.setAttribute("stroke", "transparent");
        polyline.setAttribute("fill", "transparent");
        svg.append(polyline);
        this.container.append(svg);
        if (!popupRef && this.hasPopupData) this._createPopup();
        return this.container;
    }
    getElementsToTriggerPopup() {
        return this.#polyline;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
}
class PolygonAnnotationElement extends PolylineAnnotationElement {
    constructor(parameters){
        super(parameters);
        this.containerClassName = "polygonAnnotation";
        this.svgElementName = "svg:polygon";
    }
}
class CaretAnnotationElement extends AnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true
        });
    }
    render() {
        this.container.classList.add("caretAnnotation");
        if (!this.data.popupRef && this.hasPopupData) this._createPopup();
        return this.container;
    }
}
class InkAnnotationElement extends AnnotationElement {
    #polylinesGroupElement = null;
    #polylines = [];
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true
        });
        this.containerClassName = "inkAnnotation";
        this.svgElementName = "svg:polyline";
        this.annotationEditorType = this.data.it === "InkHighlight" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;
    }
    #getTransform(rotation, rect) {
        switch(rotation){
            case 90:
                return {
                    transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,
                    width: rect[3] - rect[1],
                    height: rect[2] - rect[0]
                };
            case 180:
                return {
                    transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,
                    width: rect[2] - rect[0],
                    height: rect[3] - rect[1]
                };
            case 270:
                return {
                    transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,
                    width: rect[3] - rect[1],
                    height: rect[2] - rect[0]
                };
            default:
                return {
                    transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,
                    width: rect[2] - rect[0],
                    height: rect[3] - rect[1]
                };
        }
    }
    render() {
        this.container.classList.add(this.containerClassName);
        const { data: { rect, rotation, inkLists, borderStyle, popupRef } } = this;
        const { transform, width, height } = this.#getTransform(rotation, rect);
        const svg = this.svgFactory.create(width, height, true);
        const g = this.#polylinesGroupElement = this.svgFactory.createElement("svg:g");
        svg.append(g);
        g.setAttribute("stroke-width", borderStyle.width || 1);
        g.setAttribute("stroke-linecap", "round");
        g.setAttribute("stroke-linejoin", "round");
        g.setAttribute("stroke-miterlimit", 10);
        g.setAttribute("stroke", "transparent");
        g.setAttribute("fill", "transparent");
        g.setAttribute("transform", transform);
        for(let i = 0, ii = inkLists.length; i < ii; i++){
            const polyline = this.svgFactory.createElement(this.svgElementName);
            this.#polylines.push(polyline);
            polyline.setAttribute("points", inkLists[i].join(","));
            g.append(polyline);
        }
        if (!popupRef && this.hasPopupData) this._createPopup();
        this.container.append(svg);
        this._editOnDoubleClick();
        return this.container;
    }
    updateEdited(params) {
        super.updateEdited(params);
        const { thickness, points, rect } = params;
        const g = this.#polylinesGroupElement;
        if (thickness >= 0) g.setAttribute("stroke-width", thickness || 1);
        if (points) for(let i = 0, ii = this.#polylines.length; i < ii; i++)this.#polylines[i].setAttribute("points", points[i].join(","));
        if (rect) {
            const { transform, width, height } = this.#getTransform(this.data.rotation, rect);
            const root = g.parentElement;
            root.setAttribute("viewBox", `0 0 ${width} ${height}`);
            g.setAttribute("transform", transform);
        }
    }
    getElementsToTriggerPopup() {
        return this.#polylines;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
}
class HighlightAnnotationElement extends AnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true,
            createQuadrilaterals: true
        });
        this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;
    }
    render() {
        if (!this.data.popupRef && this.hasPopupData) this._createPopup();
        this.container.classList.add("highlightAnnotation");
        this._editOnDoubleClick();
        return this.container;
    }
}
class UnderlineAnnotationElement extends AnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true,
            createQuadrilaterals: true
        });
    }
    render() {
        if (!this.data.popupRef && this.hasPopupData) this._createPopup();
        this.container.classList.add("underlineAnnotation");
        return this.container;
    }
}
class SquigglyAnnotationElement extends AnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true,
            createQuadrilaterals: true
        });
    }
    render() {
        if (!this.data.popupRef && this.hasPopupData) this._createPopup();
        this.container.classList.add("squigglyAnnotation");
        return this.container;
    }
}
class StrikeOutAnnotationElement extends AnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true,
            createQuadrilaterals: true
        });
    }
    render() {
        if (!this.data.popupRef && this.hasPopupData) this._createPopup();
        this.container.classList.add("strikeoutAnnotation");
        return this.container;
    }
}
class StampAnnotationElement extends AnnotationElement {
    constructor(parameters){
        super(parameters, {
            isRenderable: true,
            ignoreBorder: true
        });
        this.annotationEditorType = AnnotationEditorType.STAMP;
    }
    render() {
        this.container.classList.add("stampAnnotation");
        this.container.setAttribute("role", "img");
        if (!this.data.popupRef && this.hasPopupData) this._createPopup();
        this._editOnDoubleClick();
        return this.container;
    }
}
class FileAttachmentAnnotationElement extends AnnotationElement {
    #trigger = null;
    constructor(parameters){
        super(parameters, {
            isRenderable: true
        });
        const { file } = this.data;
        this.filename = file.filename;
        this.content = file.content;
        this.linkService.eventBus?.dispatch("fileattachmentannotation", {
            source: this,
            ...file
        });
    }
    render() {
        this.container.classList.add("fileAttachmentAnnotation");
        const { container, data } = this;
        let trigger;
        if (data.hasAppearance || data.fillAlpha === 0) trigger = document.createElement("div");
        else {
            trigger = document.createElement("img");
            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
            if (data.fillAlpha && data.fillAlpha < 1) trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
        }
        trigger.addEventListener("dblclick", this.#download.bind(this));
        this.#trigger = trigger;
        const { isMac } = util_FeatureTest.platform;
        container.addEventListener("keydown", (evt)=>{
            if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) this.#download();
        });
        if (!data.popupRef && this.hasPopupData) this._createPopup();
        else trigger.classList.add("popupTriggerArea");
        container.append(trigger);
        return container;
    }
    getElementsToTriggerPopup() {
        return this.#trigger;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
    #download() {
        this.downloadManager?.openOrDownloadData(this.content, this.filename);
    }
}
class AnnotationLayer {
    #accessibilityManager = null;
    #annotationCanvasMap = null;
    #editableAnnotations = new Map();
    #structTreeLayer = null;
    constructor({ div, accessibilityManager, annotationCanvasMap, annotationEditorUIManager, page, viewport, structTreeLayer }){
        this.div = div;
        this.#accessibilityManager = accessibilityManager;
        this.#annotationCanvasMap = annotationCanvasMap;
        this.#structTreeLayer = structTreeLayer || null;
        this.page = page;
        this.viewport = viewport;
        this.zIndex = 0;
        this._annotationEditorUIManager = annotationEditorUIManager;
    }
    hasEditableAnnotations() {
        return this.#editableAnnotations.size > 0;
    }
    async #appendElement(element, id) {
        const contentElement = element.firstChild || element;
        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;
        const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);
        if (ariaAttributes) for (const [key, value] of ariaAttributes)contentElement.setAttribute(key, value);
        this.div.append(element);
        this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);
    }
    async render(params) {
        const { annotations } = params;
        const layer = this.div;
        setLayerDimensions(layer, this.viewport);
        const popupToElements = new Map();
        const elementParams = {
            data: null,
            layer,
            linkService: params.linkService,
            downloadManager: params.downloadManager,
            imageResourcesPath: params.imageResourcesPath || "",
            renderForms: params.renderForms !== false,
            svgFactory: new DOMSVGFactory(),
            annotationStorage: params.annotationStorage || new AnnotationStorage(),
            enableScripting: params.enableScripting === true,
            hasJSActions: params.hasJSActions,
            fieldObjects: params.fieldObjects,
            parent: this,
            elements: null
        };
        for (const data of annotations){
            if (data.noHTML) continue;
            const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
            if (!isPopupAnnotation) {
                const { width, height } = getRectDims(data.rect);
                if (width <= 0 || height <= 0) continue;
            } else {
                const elements = popupToElements.get(data.id);
                if (!elements) continue;
                elementParams.elements = elements;
            }
            elementParams.data = data;
            const element = AnnotationElementFactory.create(elementParams);
            if (!element.isRenderable) continue;
            if (!isPopupAnnotation && data.popupRef) {
                const elements = popupToElements.get(data.popupRef);
                if (!elements) popupToElements.set(data.popupRef, [
                    element
                ]);
                else elements.push(element);
            }
            const rendered = element.render();
            if (data.hidden) rendered.style.visibility = "hidden";
            await this.#appendElement(rendered, data.id);
            if (element._isEditable) {
                this.#editableAnnotations.set(element.data.id, element);
                this._annotationEditorUIManager?.renderAnnotationElement(element);
            }
        }
        this.#setAnnotationCanvasMap();
    }
    update({ viewport }) {
        const layer = this.div;
        this.viewport = viewport;
        setLayerDimensions(layer, {
            rotation: viewport.rotation
        });
        this.#setAnnotationCanvasMap();
        layer.hidden = false;
    }
    #setAnnotationCanvasMap() {
        if (!this.#annotationCanvasMap) return;
        const layer = this.div;
        for (const [id, canvas] of this.#annotationCanvasMap){
            const element = layer.querySelector(`[data-annotation-id="${id}"]`);
            if (!element) continue;
            canvas.className = "annotationContent";
            const { firstChild } = element;
            if (!firstChild) element.append(canvas);
            else if (firstChild.nodeName === "CANVAS") firstChild.replaceWith(canvas);
            else if (!firstChild.classList.contains("annotationContent")) firstChild.before(canvas);
            else firstChild.after(canvas);
        }
        this.#annotationCanvasMap.clear();
    }
    getEditableAnnotations() {
        return Array.from(this.#editableAnnotations.values());
    }
    getEditableAnnotation(id) {
        return this.#editableAnnotations.get(id);
    }
}
const EOL_PATTERN = /\r\n?|\n/g;
class FreeTextEditor extends AnnotationEditor {
    #color;
    #content = "";
    #editorDivId = `${this.id}-editor`;
    #editModeAC = null;
    #fontSize;
    static _freeTextDefaultContent = "";
    static _internalPadding = 0;
    static _defaultColor = null;
    static _defaultFontSize = 10;
    static get _keyboardManager() {
        const proto = FreeTextEditor.prototype;
        const arrowChecker = (self)=>self.isEmpty();
        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
        const big = AnnotationEditorUIManager.TRANSLATE_BIG;
        return shadow(this, "_keyboardManager", new KeyboardManager([
            [
                [
                    "ctrl+s",
                    "mac+meta+s",
                    "ctrl+p",
                    "mac+meta+p"
                ],
                proto.commitOrRemove,
                {
                    bubbles: true
                }
            ],
            [
                [
                    "ctrl+Enter",
                    "mac+meta+Enter",
                    "Escape",
                    "mac+Escape"
                ],
                proto.commitOrRemove
            ],
            [
                [
                    "ArrowLeft",
                    "mac+ArrowLeft"
                ],
                proto._translateEmpty,
                {
                    args: [
                        -small,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowLeft",
                    "mac+shift+ArrowLeft"
                ],
                proto._translateEmpty,
                {
                    args: [
                        -big,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowRight",
                    "mac+ArrowRight"
                ],
                proto._translateEmpty,
                {
                    args: [
                        small,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowRight",
                    "mac+shift+ArrowRight"
                ],
                proto._translateEmpty,
                {
                    args: [
                        big,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowUp",
                    "mac+ArrowUp"
                ],
                proto._translateEmpty,
                {
                    args: [
                        0,
                        -small
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowUp",
                    "mac+shift+ArrowUp"
                ],
                proto._translateEmpty,
                {
                    args: [
                        0,
                        -big
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowDown",
                    "mac+ArrowDown"
                ],
                proto._translateEmpty,
                {
                    args: [
                        0,
                        small
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowDown",
                    "mac+shift+ArrowDown"
                ],
                proto._translateEmpty,
                {
                    args: [
                        0,
                        big
                    ],
                    checker: arrowChecker
                }
            ]
        ]));
    }
    static _type = "freetext";
    static _editorType = AnnotationEditorType.FREETEXT;
    constructor(params){
        super({
            ...params,
            name: "freeTextEditor"
        });
        this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;
        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;
    }
    static initialize(l10n, uiManager) {
        AnnotationEditor.initialize(l10n, uiManager);
        const style = getComputedStyle(document.documentElement);
        this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
    }
    static updateDefaultParams(type, value) {
        switch(type){
            case AnnotationEditorParamsType.FREETEXT_SIZE:
                FreeTextEditor._defaultFontSize = value;
                break;
            case AnnotationEditorParamsType.FREETEXT_COLOR:
                FreeTextEditor._defaultColor = value;
                break;
        }
    }
    updateParams(type, value) {
        switch(type){
            case AnnotationEditorParamsType.FREETEXT_SIZE:
                this.#updateFontSize(value);
                break;
            case AnnotationEditorParamsType.FREETEXT_COLOR:
                this.#updateColor(value);
                break;
        }
    }
    static get defaultPropertiesToUpdate() {
        return [
            [
                AnnotationEditorParamsType.FREETEXT_SIZE,
                FreeTextEditor._defaultFontSize
            ],
            [
                AnnotationEditorParamsType.FREETEXT_COLOR,
                FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor
            ]
        ];
    }
    get propertiesToUpdate() {
        return [
            [
                AnnotationEditorParamsType.FREETEXT_SIZE,
                this.#fontSize
            ],
            [
                AnnotationEditorParamsType.FREETEXT_COLOR,
                this.#color
            ]
        ];
    }
    #updateFontSize(fontSize) {
        const setFontsize = (size)=>{
            this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
            this.translate(0, -(size - this.#fontSize) * this.parentScale);
            this.#fontSize = size;
            this.#setEditorDimensions();
        };
        const savedFontsize = this.#fontSize;
        this.addCommands({
            cmd: setFontsize.bind(this, fontSize),
            undo: setFontsize.bind(this, savedFontsize),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: true,
            type: AnnotationEditorParamsType.FREETEXT_SIZE,
            overwriteIfSameType: true,
            keepUndo: true
        });
    }
    #updateColor(color) {
        const setColor = (col)=>{
            this.#color = this.editorDiv.style.color = col;
        };
        const savedColor = this.#color;
        this.addCommands({
            cmd: setColor.bind(this, color),
            undo: setColor.bind(this, savedColor),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: true,
            type: AnnotationEditorParamsType.FREETEXT_COLOR,
            overwriteIfSameType: true,
            keepUndo: true
        });
    }
    _translateEmpty(x, y) {
        this._uiManager.translateSelectedEditors(x, y, true);
    }
    getInitialTranslation() {
        const scale = this.parentScale;
        return [
            -FreeTextEditor._internalPadding * scale,
            -(FreeTextEditor._internalPadding + this.#fontSize) * scale
        ];
    }
    rebuild() {
        if (!this.parent) return;
        super.rebuild();
        if (this.div === null) return;
        if (!this.isAttachedToDOM) this.parent.add(this);
    }
    enableEditMode() {
        if (this.isInEditMode()) return;
        this.parent.setEditingState(false);
        this.parent.updateToolbar(AnnotationEditorType.FREETEXT);
        super.enableEditMode();
        this.overlayDiv.classList.remove("enabled");
        this.editorDiv.contentEditable = true;
        this._isDraggable = false;
        this.div.removeAttribute("aria-activedescendant");
        this.#editModeAC = new AbortController();
        const signal = this._uiManager.combinedSignal(this.#editModeAC);
        this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
            signal
        });
        this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
            signal
        });
        this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
            signal
        });
        this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
            signal
        });
        this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
            signal
        });
    }
    disableEditMode() {
        if (!this.isInEditMode()) return;
        this.parent.setEditingState(true);
        super.disableEditMode();
        this.overlayDiv.classList.add("enabled");
        this.editorDiv.contentEditable = false;
        this.div.setAttribute("aria-activedescendant", this.#editorDivId);
        this._isDraggable = true;
        this.#editModeAC?.abort();
        this.#editModeAC = null;
        this.div.focus({
            preventScroll: true
        });
        this.isEditing = false;
        this.parent.div.classList.add("freetextEditing");
    }
    focusin(event) {
        if (!this._focusEventsAllowed) return;
        super.focusin(event);
        if (event.target !== this.editorDiv) this.editorDiv.focus();
    }
    onceAdded(focus) {
        if (this.width) return;
        this.enableEditMode();
        if (focus) this.editorDiv.focus();
        if (this._initialOptions?.isCentered) this.center();
        this._initialOptions = null;
    }
    isEmpty() {
        return !this.editorDiv || this.editorDiv.innerText.trim() === "";
    }
    remove() {
        this.isEditing = false;
        if (this.parent) {
            this.parent.setEditingState(true);
            this.parent.div.classList.add("freetextEditing");
        }
        super.remove();
    }
    #extractText() {
        const buffer = [];
        this.editorDiv.normalize();
        let prevChild = null;
        for (const child of this.editorDiv.childNodes){
            if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === "BR") continue;
            buffer.push(FreeTextEditor.#getNodeContent(child));
            prevChild = child;
        }
        return buffer.join("\n");
    }
    #setEditorDimensions() {
        const [parentWidth, parentHeight] = this.parentDimensions;
        let rect;
        if (this.isAttachedToDOM) rect = this.div.getBoundingClientRect();
        else {
            const { currentLayer, div } = this;
            const savedDisplay = div.style.display;
            const savedVisibility = div.classList.contains("hidden");
            div.classList.remove("hidden");
            div.style.display = "hidden";
            currentLayer.div.append(this.div);
            rect = div.getBoundingClientRect();
            div.remove();
            div.style.display = savedDisplay;
            div.classList.toggle("hidden", savedVisibility);
        }
        if (this.rotation % 180 === this.parentRotation % 180) {
            this.width = rect.width / parentWidth;
            this.height = rect.height / parentHeight;
        } else {
            this.width = rect.height / parentWidth;
            this.height = rect.width / parentHeight;
        }
        this.fixAndSetPosition();
    }
    commit() {
        if (!this.isInEditMode()) return;
        super.commit();
        this.disableEditMode();
        const savedText = this.#content;
        const newText = this.#content = this.#extractText().trimEnd();
        if (savedText === newText) return;
        const setText = (text)=>{
            this.#content = text;
            if (!text) {
                this.remove();
                return;
            }
            this.#setContent();
            this._uiManager.rebuild(this);
            this.#setEditorDimensions();
        };
        this.addCommands({
            cmd: ()=>{
                setText(newText);
            },
            undo: ()=>{
                setText(savedText);
            },
            mustExec: false
        });
        this.#setEditorDimensions();
    }
    shouldGetKeyboardEvents() {
        return this.isInEditMode();
    }
    enterInEditMode() {
        this.enableEditMode();
        this.editorDiv.focus();
    }
    dblclick(event) {
        this.enterInEditMode();
    }
    keydown(event) {
        if (event.target === this.div && event.key === "Enter") {
            this.enterInEditMode();
            event.preventDefault();
        }
    }
    editorDivKeydown(event) {
        FreeTextEditor._keyboardManager.exec(this, event);
    }
    editorDivFocus(event) {
        this.isEditing = true;
    }
    editorDivBlur(event) {
        this.isEditing = false;
    }
    editorDivInput(event) {
        this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
    }
    disableEditing() {
        this.editorDiv.setAttribute("role", "comment");
        this.editorDiv.removeAttribute("aria-multiline");
    }
    enableEditing() {
        this.editorDiv.setAttribute("role", "textbox");
        this.editorDiv.setAttribute("aria-multiline", true);
    }
    render() {
        if (this.div) return this.div;
        let baseX, baseY;
        if (this.width) {
            baseX = this.x;
            baseY = this.y;
        }
        super.render();
        this.editorDiv = document.createElement("div");
        this.editorDiv.className = "internal";
        this.editorDiv.setAttribute("id", this.#editorDivId);
        this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2");
        this.editorDiv.setAttribute("data-l10n-attrs", "default-content");
        this.enableEditing();
        this.editorDiv.contentEditable = true;
        const { style } = this.editorDiv;
        style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;
        style.color = this.#color;
        this.div.append(this.editorDiv);
        this.overlayDiv = document.createElement("div");
        this.overlayDiv.classList.add("overlay", "enabled");
        this.div.append(this.overlayDiv);
        bindEvents(this, this.div, [
            "dblclick",
            "keydown"
        ]);
        if (this.width) {
            const [parentWidth, parentHeight] = this.parentDimensions;
            if (this.annotationElementId) {
                const { position } = this._initialData;
                let [tx, ty] = this.getInitialTranslation();
                [tx, ty] = this.pageTranslationToScreen(tx, ty);
                const [pageWidth, pageHeight] = this.pageDimensions;
                const [pageX, pageY] = this.pageTranslation;
                let posX, posY;
                switch(this.rotation){
                    case 0:
                        posX = baseX + (position[0] - pageX) / pageWidth;
                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;
                        break;
                    case 90:
                        posX = baseX + (position[0] - pageX) / pageWidth;
                        posY = baseY - (position[1] - pageY) / pageHeight;
                        [tx, ty] = [
                            ty,
                            -tx
                        ];
                        break;
                    case 180:
                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;
                        posY = baseY - (position[1] - pageY) / pageHeight;
                        [tx, ty] = [
                            -tx,
                            -ty
                        ];
                        break;
                    case 270:
                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
                        [tx, ty] = [
                            -ty,
                            tx
                        ];
                        break;
                }
                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
            } else this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
            this.#setContent();
            this._isDraggable = true;
            this.editorDiv.contentEditable = false;
        } else {
            this._isDraggable = false;
            this.editorDiv.contentEditable = true;
        }
        return this.div;
    }
    static #getNodeContent(node) {
        return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, "");
    }
    editorDivPaste(event) {
        const clipboardData = event.clipboardData || window.clipboardData;
        const { types } = clipboardData;
        if (types.length === 1 && types[0] === "text/plain") return;
        event.preventDefault();
        const paste = FreeTextEditor.#deserializeContent(clipboardData.getData("text") || "").replaceAll(EOL_PATTERN, "\n");
        if (!paste) return;
        const selection = window.getSelection();
        if (!selection.rangeCount) return;
        this.editorDiv.normalize();
        selection.deleteFromDocument();
        const range = selection.getRangeAt(0);
        if (!paste.includes("\n")) {
            range.insertNode(document.createTextNode(paste));
            this.editorDiv.normalize();
            selection.collapseToStart();
            return;
        }
        const { startContainer, startOffset } = range;
        const bufferBefore = [];
        const bufferAfter = [];
        if (startContainer.nodeType === Node.TEXT_NODE) {
            const parent = startContainer.parentElement;
            bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, ""));
            if (parent !== this.editorDiv) {
                let buffer = bufferBefore;
                for (const child of this.editorDiv.childNodes){
                    if (child === parent) {
                        buffer = bufferAfter;
                        continue;
                    }
                    buffer.push(FreeTextEditor.#getNodeContent(child));
                }
            }
            bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, ""));
        } else if (startContainer === this.editorDiv) {
            let buffer = bufferBefore;
            let i = 0;
            for (const child of this.editorDiv.childNodes){
                if (i++ === startOffset) buffer = bufferAfter;
                buffer.push(FreeTextEditor.#getNodeContent(child));
            }
        }
        this.#content = `${bufferBefore.join("\n")}${paste}${bufferAfter.join("\n")}`;
        this.#setContent();
        const newRange = new Range();
        let beforeLength = bufferBefore.reduce((acc, line)=>acc + line.length, 0);
        for (const { firstChild } of this.editorDiv.childNodes)if (firstChild.nodeType === Node.TEXT_NODE) {
            const length = firstChild.nodeValue.length;
            if (beforeLength <= length) {
                newRange.setStart(firstChild, beforeLength);
                newRange.setEnd(firstChild, beforeLength);
                break;
            }
            beforeLength -= length;
        }
        selection.removeAllRanges();
        selection.addRange(newRange);
    }
    #setContent() {
        this.editorDiv.replaceChildren();
        if (!this.#content) return;
        for (const line of this.#content.split("\n")){
            const div = document.createElement("div");
            div.append(line ? document.createTextNode(line) : document.createElement("br"));
            this.editorDiv.append(div);
        }
    }
    #serializeContent() {
        return this.#content.replaceAll("\xa0", " ");
    }
    static #deserializeContent(content) {
        return content.replaceAll(" ", "\xa0");
    }
    get contentDiv() {
        return this.editorDiv;
    }
    static async deserialize(data, parent, uiManager) {
        let initialData = null;
        if (data instanceof FreeTextAnnotationElement) {
            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id, popupRef }, textContent, textPosition, parent: { page: { pageNumber } } } = data;
            if (!textContent || textContent.length === 0) return null;
            initialData = data = {
                annotationType: AnnotationEditorType.FREETEXT,
                color: Array.from(fontColor),
                fontSize,
                value: textContent.join("\n"),
                position: textPosition,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                id,
                deleted: false,
                popupRef
            };
        }
        const editor = await super.deserialize(data, parent, uiManager);
        editor.#fontSize = data.fontSize;
        editor.#color = Util.makeHexColor(...data.color);
        editor.#content = FreeTextEditor.#deserializeContent(data.value);
        editor.annotationElementId = data.id || null;
        editor._initialData = initialData;
        return editor;
    }
    serialize(isForCopying = false) {
        if (this.isEmpty()) return null;
        if (this.deleted) return this.serializeDeleted();
        const padding = FreeTextEditor._internalPadding * this.parentScale;
        const rect = this.getRect(padding, padding);
        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);
        const serialized = {
            annotationType: AnnotationEditorType.FREETEXT,
            color,
            fontSize: this.#fontSize,
            value: this.#serializeContent(),
            pageIndex: this.pageIndex,
            rect,
            rotation: this.rotation,
            structTreeParentId: this._structTreeParentId
        };
        if (isForCopying) return serialized;
        if (this.annotationElementId && !this.#hasElementChanged(serialized)) return null;
        serialized.id = this.annotationElementId;
        return serialized;
    }
    #hasElementChanged(serialized) {
        const { value, fontSize, color, pageIndex } = this._initialData;
        return this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;
    }
    renderAnnotationElement(annotation) {
        const content = super.renderAnnotationElement(annotation);
        if (this.deleted) return content;
        const { style } = content;
        style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;
        style.color = this.#color;
        content.replaceChildren();
        for (const line of this.#content.split("\n")){
            const div = document.createElement("div");
            div.append(line ? document.createTextNode(line) : document.createElement("br"));
            content.append(div);
        }
        const padding = FreeTextEditor._internalPadding * this.parentScale;
        annotation.updateEdited({
            rect: this.getRect(padding, padding),
            popupContent: this.#content
        });
        return content;
    }
    resetAnnotationElement(annotation) {
        super.resetAnnotationElement(annotation);
        annotation.resetEdited();
    }
}
class Outline {
    static PRECISION = 1e-4;
    toSVGPath() {
        unreachable("Abstract method `toSVGPath` must be implemented.");
    }
    get box() {
        unreachable("Abstract getter `box` must be implemented.");
    }
    serialize(_bbox, _rotation) {
        unreachable("Abstract method `serialize` must be implemented.");
    }
    static _rescale(src, tx, ty, sx, sy, dest) {
        dest ||= new Float32Array(src.length);
        for(let i = 0, ii = src.length; i < ii; i += 2){
            dest[i] = tx + src[i] * sx;
            dest[i + 1] = ty + src[i + 1] * sy;
        }
        return dest;
    }
    static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {
        dest ||= new Float32Array(src.length);
        for(let i = 0, ii = src.length; i < ii; i += 2){
            dest[i] = tx + src[i + 1] * sx;
            dest[i + 1] = ty + src[i] * sy;
        }
        return dest;
    }
    static _translate(src, tx, ty, dest) {
        dest ||= new Float32Array(src.length);
        for(let i = 0, ii = src.length; i < ii; i += 2){
            dest[i] = tx + src[i];
            dest[i + 1] = ty + src[i + 1];
        }
        return dest;
    }
    static svgRound(x) {
        return Math.round(x * 10000);
    }
    static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {
        switch(rotation){
            case 90:
                return [
                    1 - y / parentWidth,
                    x / parentHeight
                ];
            case 180:
                return [
                    1 - x / parentWidth,
                    1 - y / parentHeight
                ];
            case 270:
                return [
                    y / parentWidth,
                    1 - x / parentHeight
                ];
            default:
                return [
                    x / parentWidth,
                    y / parentHeight
                ];
        }
    }
    static _normalizePagePoint(x, y, rotation) {
        switch(rotation){
            case 90:
                return [
                    1 - y,
                    x
                ];
            case 180:
                return [
                    1 - x,
                    1 - y
                ];
            case 270:
                return [
                    y,
                    1 - x
                ];
            default:
                return [
                    x,
                    y
                ];
        }
    }
    static createBezierPoints(x1, y1, x2, y2, x3, y3) {
        return [
            (x1 + 5 * x2) / 6,
            (y1 + 5 * y2) / 6,
            (5 * x2 + x3) / 6,
            (5 * y2 + y3) / 6,
            (x2 + x3) / 2,
            (y2 + y3) / 2
        ];
    }
}
class FreeDrawOutliner {
    #box;
    #bottom = [];
    #innerMargin;
    #isLTR;
    #top = [];
    #last = new Float32Array(18);
    #lastX;
    #lastY;
    #min;
    #min_dist;
    #scaleFactor;
    #thickness;
    #points = [];
    static #MIN_DIST = 8;
    static #MIN_DIFF = 2;
    static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;
    constructor({ x, y }, box, scaleFactor, thickness, isLTR, innerMargin = 0){
        this.#box = box;
        this.#thickness = thickness * scaleFactor;
        this.#isLTR = isLTR;
        this.#last.set([
            NaN,
            NaN,
            NaN,
            NaN,
            x,
            y
        ], 6);
        this.#innerMargin = innerMargin;
        this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;
        this.#min = FreeDrawOutliner.#MIN * scaleFactor;
        this.#scaleFactor = scaleFactor;
        this.#points.push(x, y);
    }
    isEmpty() {
        return isNaN(this.#last[8]);
    }
    #getLastCoords() {
        const lastTop = this.#last.subarray(4, 6);
        const lastBottom = this.#last.subarray(16, 18);
        const [x, y, width, height] = this.#box;
        return [
            (this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width,
            (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height,
            (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width,
            (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height
        ];
    }
    add({ x, y }) {
        this.#lastX = x;
        this.#lastY = y;
        const [layerX, layerY, layerWidth, layerHeight] = this.#box;
        let [x1, y1, x2, y2] = this.#last.subarray(8, 12);
        const diffX = x - x2;
        const diffY = y - y2;
        const d = Math.hypot(diffX, diffY);
        if (d < this.#min) return false;
        const diffD = d - this.#min_dist;
        const K = diffD / d;
        const shiftX = K * diffX;
        const shiftY = K * diffY;
        let x0 = x1;
        let y0 = y1;
        x1 = x2;
        y1 = y2;
        x2 += shiftX;
        y2 += shiftY;
        this.#points?.push(x, y);
        const nX = -shiftY / diffD;
        const nY = shiftX / diffD;
        const thX = nX * this.#thickness;
        const thY = nY * this.#thickness;
        this.#last.set(this.#last.subarray(2, 8), 0);
        this.#last.set([
            x2 + thX,
            y2 + thY
        ], 4);
        this.#last.set(this.#last.subarray(14, 18), 12);
        this.#last.set([
            x2 - thX,
            y2 - thY
        ], 16);
        if (isNaN(this.#last[6])) {
            if (this.#top.length === 0) {
                this.#last.set([
                    x1 + thX,
                    y1 + thY
                ], 2);
                this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);
                this.#last.set([
                    x1 - thX,
                    y1 - thY
                ], 14);
                this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);
            }
            this.#last.set([
                x0,
                y0,
                x1,
                y1,
                x2,
                y2
            ], 6);
            return !this.isEmpty();
        }
        this.#last.set([
            x0,
            y0,
            x1,
            y1,
            x2,
            y2
        ], 6);
        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));
        if (angle < Math.PI / 2) {
            [x1, y1, x2, y2] = this.#last.subarray(2, 6);
            this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
            [x1, y1, x0, y0] = this.#last.subarray(14, 18);
            this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);
            return true;
        }
        [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);
        this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
        [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);
        this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
        return true;
    }
    toSVGPath() {
        if (this.isEmpty()) return "";
        const top = this.#top;
        const bottom = this.#bottom;
        if (isNaN(this.#last[6]) && !this.isEmpty()) return this.#toSVGPathTwoPoints();
        const buffer = [];
        buffer.push(`M${top[4]} ${top[5]}`);
        for(let i = 6; i < top.length; i += 6)if (isNaN(top[i])) buffer.push(`L${top[i + 4]} ${top[i + 5]}`);
        else buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);
        this.#toSVGPathEnd(buffer);
        for(let i = bottom.length - 6; i >= 6; i -= 6)if (isNaN(bottom[i])) buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);
        else buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);
        this.#toSVGPathStart(buffer);
        return buffer.join(" ");
    }
    #toSVGPathTwoPoints() {
        const [x, y, width, height] = this.#box;
        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
        return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;
    }
    #toSVGPathStart(buffer) {
        const bottom = this.#bottom;
        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);
    }
    #toSVGPathEnd(buffer) {
        const [x, y, width, height] = this.#box;
        const lastTop = this.#last.subarray(4, 6);
        const lastBottom = this.#last.subarray(16, 18);
        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);
    }
    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
        return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
    }
    getOutlines() {
        const top = this.#top;
        const bottom = this.#bottom;
        const last = this.#last;
        const [layerX, layerY, layerWidth, layerHeight] = this.#box;
        const points = new Float32Array((this.#points?.length ?? 0) + 2);
        for(let i = 0, ii = points.length - 2; i < ii; i += 2){
            points[i] = (this.#points[i] - layerX) / layerWidth;
            points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;
        }
        points[points.length - 2] = (this.#lastX - layerX) / layerWidth;
        points[points.length - 1] = (this.#lastY - layerY) / layerHeight;
        if (isNaN(last[6]) && !this.isEmpty()) return this.#getOutlineTwoPoints(points);
        const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);
        let N = top.length;
        for(let i = 0; i < N; i += 2){
            if (isNaN(top[i])) {
                outline[i] = outline[i + 1] = NaN;
                continue;
            }
            outline[i] = top[i];
            outline[i + 1] = top[i + 1];
        }
        N = this.#getOutlineEnd(outline, N);
        for(let i = bottom.length - 6; i >= 6; i -= 6)for(let j = 0; j < 6; j += 2){
            if (isNaN(bottom[i + j])) {
                outline[N] = outline[N + 1] = NaN;
                N += 2;
                continue;
            }
            outline[N] = bottom[i + j];
            outline[N + 1] = bottom[i + j + 1];
            N += 2;
        }
        this.#getOutlineStart(outline, N);
        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
    }
    #getOutlineTwoPoints(points) {
        const last = this.#last;
        const [layerX, layerY, layerWidth, layerHeight] = this.#box;
        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
        const outline = new Float32Array(36);
        outline.set([
            NaN,
            NaN,
            NaN,
            NaN,
            (last[2] - layerX) / layerWidth,
            (last[3] - layerY) / layerHeight,
            NaN,
            NaN,
            NaN,
            NaN,
            (last[4] - layerX) / layerWidth,
            (last[5] - layerY) / layerHeight,
            NaN,
            NaN,
            NaN,
            NaN,
            lastTopX,
            lastTopY,
            NaN,
            NaN,
            NaN,
            NaN,
            lastBottomX,
            lastBottomY,
            NaN,
            NaN,
            NaN,
            NaN,
            (last[16] - layerX) / layerWidth,
            (last[17] - layerY) / layerHeight,
            NaN,
            NaN,
            NaN,
            NaN,
            (last[14] - layerX) / layerWidth,
            (last[15] - layerY) / layerHeight
        ], 0);
        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
    }
    #getOutlineStart(outline, pos) {
        const bottom = this.#bottom;
        outline.set([
            NaN,
            NaN,
            NaN,
            NaN,
            bottom[4],
            bottom[5]
        ], pos);
        return pos += 6;
    }
    #getOutlineEnd(outline, pos) {
        const lastTop = this.#last.subarray(4, 6);
        const lastBottom = this.#last.subarray(16, 18);
        const [layerX, layerY, layerWidth, layerHeight] = this.#box;
        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
        outline.set([
            NaN,
            NaN,
            NaN,
            NaN,
            (lastTop[0] - layerX) / layerWidth,
            (lastTop[1] - layerY) / layerHeight,
            NaN,
            NaN,
            NaN,
            NaN,
            lastTopX,
            lastTopY,
            NaN,
            NaN,
            NaN,
            NaN,
            lastBottomX,
            lastBottomY,
            NaN,
            NaN,
            NaN,
            NaN,
            (lastBottom[0] - layerX) / layerWidth,
            (lastBottom[1] - layerY) / layerHeight
        ], pos);
        return pos += 24;
    }
}
class FreeDrawOutline extends Outline {
    #box;
    #bbox = new Float32Array(4);
    #innerMargin;
    #isLTR;
    #points;
    #scaleFactor;
    #outline;
    constructor(outline, points, box, scaleFactor, innerMargin, isLTR){
        super();
        this.#outline = outline;
        this.#points = points;
        this.#box = box;
        this.#scaleFactor = scaleFactor;
        this.#innerMargin = innerMargin;
        this.#isLTR = isLTR;
        this.lastPoint = [
            NaN,
            NaN
        ];
        this.#computeMinMax(isLTR);
        const [x, y, width, height] = this.#bbox;
        for(let i = 0, ii = outline.length; i < ii; i += 2){
            outline[i] = (outline[i] - x) / width;
            outline[i + 1] = (outline[i + 1] - y) / height;
        }
        for(let i = 0, ii = points.length; i < ii; i += 2){
            points[i] = (points[i] - x) / width;
            points[i + 1] = (points[i + 1] - y) / height;
        }
    }
    toSVGPath() {
        const buffer = [
            `M${this.#outline[4]} ${this.#outline[5]}`
        ];
        for(let i = 6, ii = this.#outline.length; i < ii; i += 6){
            if (isNaN(this.#outline[i])) {
                buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);
                continue;
            }
            buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);
        }
        buffer.push("Z");
        return buffer.join(" ");
    }
    serialize([blX, blY, trX, trY], rotation) {
        const width = trX - blX;
        const height = trY - blY;
        let outline;
        let points;
        switch(rotation){
            case 0:
                outline = Outline._rescale(this.#outline, blX, trY, width, -height);
                points = Outline._rescale(this.#points, blX, trY, width, -height);
                break;
            case 90:
                outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);
                points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);
                break;
            case 180:
                outline = Outline._rescale(this.#outline, trX, blY, -width, height);
                points = Outline._rescale(this.#points, trX, blY, -width, height);
                break;
            case 270:
                outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);
                points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);
                break;
        }
        return {
            outline: Array.from(outline),
            points: [
                Array.from(points)
            ]
        };
    }
    #computeMinMax(isLTR) {
        const outline = this.#outline;
        let lastX = outline[4];
        let lastY = outline[5];
        let minX = lastX;
        let minY = lastY;
        let maxX = lastX;
        let maxY = lastY;
        let lastPointX = lastX;
        let lastPointY = lastY;
        const ltrCallback = isLTR ? Math.max : Math.min;
        for(let i = 6, ii = outline.length; i < ii; i += 6){
            if (isNaN(outline[i])) {
                minX = Math.min(minX, outline[i + 4]);
                minY = Math.min(minY, outline[i + 5]);
                maxX = Math.max(maxX, outline[i + 4]);
                maxY = Math.max(maxY, outline[i + 5]);
                if (lastPointY < outline[i + 5]) {
                    lastPointX = outline[i + 4];
                    lastPointY = outline[i + 5];
                } else if (lastPointY === outline[i + 5]) lastPointX = ltrCallback(lastPointX, outline[i + 4]);
            } else {
                const bbox = Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6));
                minX = Math.min(minX, bbox[0]);
                minY = Math.min(minY, bbox[1]);
                maxX = Math.max(maxX, bbox[2]);
                maxY = Math.max(maxY, bbox[3]);
                if (lastPointY < bbox[3]) {
                    lastPointX = bbox[2];
                    lastPointY = bbox[3];
                } else if (lastPointY === bbox[3]) lastPointX = ltrCallback(lastPointX, bbox[2]);
            }
            lastX = outline[i + 4];
            lastY = outline[i + 5];
        }
        const bbox = this.#bbox;
        bbox[0] = minX - this.#innerMargin;
        bbox[1] = minY - this.#innerMargin;
        bbox[2] = maxX - minX + 2 * this.#innerMargin;
        bbox[3] = maxY - minY + 2 * this.#innerMargin;
        this.lastPoint = [
            lastPointX,
            lastPointY
        ];
    }
    get box() {
        return this.#bbox;
    }
    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
        return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
    }
    getNewOutline(thickness, innerMargin) {
        const [x, y, width, height] = this.#bbox;
        const [layerX, layerY, layerWidth, layerHeight] = this.#box;
        const sx = width * layerWidth;
        const sy = height * layerHeight;
        const tx = x * layerWidth + layerX;
        const ty = y * layerHeight + layerY;
        const outliner = this.newOutliner({
            x: this.#points[0] * sx + tx,
            y: this.#points[1] * sy + ty
        }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);
        for(let i = 2; i < this.#points.length; i += 2)outliner.add({
            x: this.#points[i] * sx + tx,
            y: this.#points[i + 1] * sy + ty
        });
        return outliner.getOutlines();
    }
}
class HighlightOutliner {
    #box;
    #lastPoint;
    #verticalEdges = [];
    #intervals = [];
    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true){
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        const NUMBER_OF_DIGITS = 4;
        const EPSILON = 10 ** -NUMBER_OF_DIGITS;
        for (const { x, y, width, height } of boxes){
            const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;
            const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;
            const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;
            const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;
            const left = [
                x1,
                y1,
                y2,
                true
            ];
            const right = [
                x2,
                y1,
                y2,
                false
            ];
            this.#verticalEdges.push(left, right);
            minX = Math.min(minX, x1);
            maxX = Math.max(maxX, x2);
            minY = Math.min(minY, y1);
            maxY = Math.max(maxY, y2);
        }
        const bboxWidth = maxX - minX + 2 * innerMargin;
        const bboxHeight = maxY - minY + 2 * innerMargin;
        const shiftedMinX = minX - innerMargin;
        const shiftedMinY = minY - innerMargin;
        const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);
        const lastPoint = [
            lastEdge[0],
            lastEdge[2]
        ];
        for (const edge of this.#verticalEdges){
            const [x, y1, y2] = edge;
            edge[0] = (x - shiftedMinX) / bboxWidth;
            edge[1] = (y1 - shiftedMinY) / bboxHeight;
            edge[2] = (y2 - shiftedMinY) / bboxHeight;
        }
        this.#box = new Float32Array([
            shiftedMinX,
            shiftedMinY,
            bboxWidth,
            bboxHeight
        ]);
        this.#lastPoint = lastPoint;
    }
    getOutlines() {
        this.#verticalEdges.sort((a, b)=>a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);
        const outlineVerticalEdges = [];
        for (const edge of this.#verticalEdges)if (edge[3]) {
            outlineVerticalEdges.push(...this.#breakEdge(edge));
            this.#insert(edge);
        } else {
            this.#remove(edge);
            outlineVerticalEdges.push(...this.#breakEdge(edge));
        }
        return this.#getOutlines(outlineVerticalEdges);
    }
    #getOutlines(outlineVerticalEdges) {
        const edges = [];
        const allEdges = new Set();
        for (const edge of outlineVerticalEdges){
            const [x, y1, y2] = edge;
            edges.push([
                x,
                y1,
                edge
            ], [
                x,
                y2,
                edge
            ]);
        }
        edges.sort((a, b)=>a[1] - b[1] || a[0] - b[0]);
        for(let i = 0, ii = edges.length; i < ii; i += 2){
            const edge1 = edges[i][2];
            const edge2 = edges[i + 1][2];
            edge1.push(edge2);
            edge2.push(edge1);
            allEdges.add(edge1);
            allEdges.add(edge2);
        }
        const outlines = [];
        let outline;
        while(allEdges.size > 0){
            const edge = allEdges.values().next().value;
            let [x, y1, y2, edge1, edge2] = edge;
            allEdges.delete(edge);
            let lastPointX = x;
            let lastPointY = y1;
            outline = [
                x,
                y2
            ];
            outlines.push(outline);
            while(true){
                let e;
                if (allEdges.has(edge1)) e = edge1;
                else if (allEdges.has(edge2)) e = edge2;
                else break;
                allEdges.delete(e);
                [x, y1, y2, edge1, edge2] = e;
                if (lastPointX !== x) {
                    outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);
                    lastPointX = x;
                }
                lastPointY = lastPointY === y1 ? y2 : y1;
            }
            outline.push(lastPointX, lastPointY);
        }
        return new HighlightOutline(outlines, this.#box, this.#lastPoint);
    }
    #binarySearch(y) {
        const array = this.#intervals;
        let start = 0;
        let end = array.length - 1;
        while(start <= end){
            const middle = start + end >> 1;
            const y1 = array[middle][0];
            if (y1 === y) return middle;
            if (y1 < y) start = middle + 1;
            else end = middle - 1;
        }
        return end + 1;
    }
    #insert([, y1, y2]) {
        const index = this.#binarySearch(y1);
        this.#intervals.splice(index, 0, [
            y1,
            y2
        ]);
    }
    #remove([, y1, y2]) {
        const index = this.#binarySearch(y1);
        for(let i = index; i < this.#intervals.length; i++){
            const [start, end] = this.#intervals[i];
            if (start !== y1) break;
            if (start === y1 && end === y2) {
                this.#intervals.splice(i, 1);
                return;
            }
        }
        for(let i = index - 1; i >= 0; i--){
            const [start, end] = this.#intervals[i];
            if (start !== y1) break;
            if (start === y1 && end === y2) {
                this.#intervals.splice(i, 1);
                return;
            }
        }
    }
    #breakEdge(edge) {
        const [x, y1, y2] = edge;
        const results = [
            [
                x,
                y1,
                y2
            ]
        ];
        const index = this.#binarySearch(y2);
        for(let i = 0; i < index; i++){
            const [start, end] = this.#intervals[i];
            for(let j = 0, jj = results.length; j < jj; j++){
                const [, y3, y4] = results[j];
                if (end <= y3 || y4 <= start) continue;
                if (y3 >= start) {
                    if (y4 > end) results[j][1] = end;
                    else {
                        if (jj === 1) return [];
                        results.splice(j, 1);
                        j--;
                        jj--;
                    }
                    continue;
                }
                results[j][2] = start;
                if (y4 > end) results.push([
                    x,
                    end,
                    y4
                ]);
            }
        }
        return results;
    }
}
class HighlightOutline extends Outline {
    #box;
    #outlines;
    constructor(outlines, box, lastPoint){
        super();
        this.#outlines = outlines;
        this.#box = box;
        this.lastPoint = lastPoint;
    }
    toSVGPath() {
        const buffer = [];
        for (const polygon of this.#outlines){
            let [prevX, prevY] = polygon;
            buffer.push(`M${prevX} ${prevY}`);
            for(let i = 2; i < polygon.length; i += 2){
                const x = polygon[i];
                const y = polygon[i + 1];
                if (x === prevX) {
                    buffer.push(`V${y}`);
                    prevY = y;
                } else if (y === prevY) {
                    buffer.push(`H${x}`);
                    prevX = x;
                }
            }
            buffer.push("Z");
        }
        return buffer.join(" ");
    }
    serialize([blX, blY, trX, trY], _rotation) {
        const outlines = [];
        const width = trX - blX;
        const height = trY - blY;
        for (const outline of this.#outlines){
            const points = new Array(outline.length);
            for(let i = 0; i < outline.length; i += 2){
                points[i] = blX + outline[i] * width;
                points[i + 1] = trY - outline[i + 1] * height;
            }
            outlines.push(points);
        }
        return outlines;
    }
    get box() {
        return this.#box;
    }
    get classNamesForOutlining() {
        return [
            "highlightOutline"
        ];
    }
}
class FreeHighlightOutliner extends FreeDrawOutliner {
    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
        return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
    }
}
class FreeHighlightOutline extends FreeDrawOutline {
    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
        return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
    }
}
class ColorPicker {
    #button = null;
    #buttonSwatch = null;
    #defaultColor;
    #dropdown = null;
    #dropdownWasFromKeyboard = false;
    #isMainColorPicker = false;
    #editor = null;
    #eventBus;
    #openDropdownAC = null;
    #uiManager = null;
    #type;
    static #l10nColor = null;
    static get _keyboardManager() {
        return shadow(this, "_keyboardManager", new KeyboardManager([
            [
                [
                    "Escape",
                    "mac+Escape"
                ],
                ColorPicker.prototype._hideDropdownFromKeyboard
            ],
            [
                [
                    " ",
                    "mac+ "
                ],
                ColorPicker.prototype._colorSelectFromKeyboard
            ],
            [
                [
                    "ArrowDown",
                    "ArrowRight",
                    "mac+ArrowDown",
                    "mac+ArrowRight"
                ],
                ColorPicker.prototype._moveToNext
            ],
            [
                [
                    "ArrowUp",
                    "ArrowLeft",
                    "mac+ArrowUp",
                    "mac+ArrowLeft"
                ],
                ColorPicker.prototype._moveToPrevious
            ],
            [
                [
                    "Home",
                    "mac+Home"
                ],
                ColorPicker.prototype._moveToBeginning
            ],
            [
                [
                    "End",
                    "mac+End"
                ],
                ColorPicker.prototype._moveToEnd
            ]
        ]));
    }
    constructor({ editor = null, uiManager = null }){
        if (editor) {
            this.#isMainColorPicker = false;
            this.#type = AnnotationEditorParamsType.HIGHLIGHT_COLOR;
            this.#editor = editor;
        } else {
            this.#isMainColorPicker = true;
            this.#type = AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR;
        }
        this.#uiManager = editor?._uiManager || uiManager;
        this.#eventBus = this.#uiManager._eventBus;
        this.#defaultColor = editor?.color || this.#uiManager?.highlightColors.values().next().value || "#FFFF98";
        ColorPicker.#l10nColor ||= Object.freeze({
            blue: "pdfjs-editor-colorpicker-blue",
            green: "pdfjs-editor-colorpicker-green",
            pink: "pdfjs-editor-colorpicker-pink",
            red: "pdfjs-editor-colorpicker-red",
            yellow: "pdfjs-editor-colorpicker-yellow"
        });
    }
    renderButton() {
        const button = this.#button = document.createElement("button");
        button.className = "colorPicker";
        button.tabIndex = "0";
        button.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
        button.setAttribute("aria-haspopup", true);
        const signal = this.#uiManager._signal;
        button.addEventListener("click", this.#openDropdown.bind(this), {
            signal
        });
        button.addEventListener("keydown", this.#keyDown.bind(this), {
            signal
        });
        const swatch = this.#buttonSwatch = document.createElement("span");
        swatch.className = "swatch";
        swatch.setAttribute("aria-hidden", true);
        swatch.style.backgroundColor = this.#defaultColor;
        button.append(swatch);
        return button;
    }
    renderMainDropdown() {
        const dropdown = this.#dropdown = this.#getDropdownRoot();
        dropdown.setAttribute("aria-orientation", "horizontal");
        dropdown.setAttribute("aria-labelledby", "highlightColorPickerLabel");
        return dropdown;
    }
    #getDropdownRoot() {
        const div = document.createElement("div");
        const signal = this.#uiManager._signal;
        div.addEventListener("contextmenu", noContextMenu, {
            signal
        });
        div.className = "dropdown";
        div.role = "listbox";
        div.setAttribute("aria-multiselectable", false);
        div.setAttribute("aria-orientation", "vertical");
        div.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
        for (const [name, color] of this.#uiManager.highlightColors){
            const button = document.createElement("button");
            button.tabIndex = "0";
            button.role = "option";
            button.setAttribute("data-color", color);
            button.title = name;
            button.setAttribute("data-l10n-id", ColorPicker.#l10nColor[name]);
            const swatch = document.createElement("span");
            button.append(swatch);
            swatch.className = "swatch";
            swatch.style.backgroundColor = color;
            button.setAttribute("aria-selected", color === this.#defaultColor);
            button.addEventListener("click", this.#colorSelect.bind(this, color), {
                signal
            });
            div.append(button);
        }
        div.addEventListener("keydown", this.#keyDown.bind(this), {
            signal
        });
        return div;
    }
    #colorSelect(color, event) {
        event.stopPropagation();
        this.#eventBus.dispatch("switchannotationeditorparams", {
            source: this,
            type: this.#type,
            value: color
        });
    }
    _colorSelectFromKeyboard(event) {
        if (event.target === this.#button) {
            this.#openDropdown(event);
            return;
        }
        const color = event.target.getAttribute("data-color");
        if (!color) return;
        this.#colorSelect(color, event);
    }
    _moveToNext(event) {
        if (!this.#isDropdownVisible) {
            this.#openDropdown(event);
            return;
        }
        if (event.target === this.#button) {
            this.#dropdown.firstChild?.focus();
            return;
        }
        event.target.nextSibling?.focus();
    }
    _moveToPrevious(event) {
        if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {
            if (this.#isDropdownVisible) this._hideDropdownFromKeyboard();
            return;
        }
        if (!this.#isDropdownVisible) this.#openDropdown(event);
        event.target.previousSibling?.focus();
    }
    _moveToBeginning(event) {
        if (!this.#isDropdownVisible) {
            this.#openDropdown(event);
            return;
        }
        this.#dropdown.firstChild?.focus();
    }
    _moveToEnd(event) {
        if (!this.#isDropdownVisible) {
            this.#openDropdown(event);
            return;
        }
        this.#dropdown.lastChild?.focus();
    }
    #keyDown(event) {
        ColorPicker._keyboardManager.exec(this, event);
    }
    #openDropdown(event) {
        if (this.#isDropdownVisible) {
            this.hideDropdown();
            return;
        }
        this.#dropdownWasFromKeyboard = event.detail === 0;
        if (!this.#openDropdownAC) {
            this.#openDropdownAC = new AbortController();
            window.addEventListener("pointerdown", this.#pointerDown.bind(this), {
                signal: this.#uiManager.combinedSignal(this.#openDropdownAC)
            });
        }
        if (this.#dropdown) {
            this.#dropdown.classList.remove("hidden");
            return;
        }
        const root = this.#dropdown = this.#getDropdownRoot();
        this.#button.append(root);
    }
    #pointerDown(event) {
        if (this.#dropdown?.contains(event.target)) return;
        this.hideDropdown();
    }
    hideDropdown() {
        this.#dropdown?.classList.add("hidden");
        this.#openDropdownAC?.abort();
        this.#openDropdownAC = null;
    }
    get #isDropdownVisible() {
        return this.#dropdown && !this.#dropdown.classList.contains("hidden");
    }
    _hideDropdownFromKeyboard() {
        if (this.#isMainColorPicker) return;
        if (!this.#isDropdownVisible) {
            this.#editor?.unselect();
            return;
        }
        this.hideDropdown();
        this.#button.focus({
            preventScroll: true,
            focusVisible: this.#dropdownWasFromKeyboard
        });
    }
    updateColor(color) {
        if (this.#buttonSwatch) this.#buttonSwatch.style.backgroundColor = color;
        if (!this.#dropdown) return;
        const i = this.#uiManager.highlightColors.values();
        for (const child of this.#dropdown.children)child.setAttribute("aria-selected", i.next().value === color);
    }
    destroy() {
        this.#button?.remove();
        this.#button = null;
        this.#buttonSwatch = null;
        this.#dropdown?.remove();
        this.#dropdown = null;
    }
}
class HighlightEditor extends AnnotationEditor {
    #anchorNode = null;
    #anchorOffset = 0;
    #boxes;
    #clipPathId = null;
    #colorPicker = null;
    #focusOutlines = null;
    #focusNode = null;
    #focusOffset = 0;
    #highlightDiv = null;
    #highlightOutlines = null;
    #id = null;
    #isFreeHighlight = false;
    #lastPoint = null;
    #opacity;
    #outlineId = null;
    #text = "";
    #thickness;
    #methodOfCreation = "";
    static _defaultColor = null;
    static _defaultOpacity = 1;
    static _defaultThickness = 12;
    static _type = "highlight";
    static _editorType = AnnotationEditorType.HIGHLIGHT;
    static _freeHighlightId = -1;
    static _freeHighlight = null;
    static _freeHighlightClipId = "";
    static get _keyboardManager() {
        const proto = HighlightEditor.prototype;
        return shadow(this, "_keyboardManager", new KeyboardManager([
            [
                [
                    "ArrowLeft",
                    "mac+ArrowLeft"
                ],
                proto._moveCaret,
                {
                    args: [
                        0
                    ]
                }
            ],
            [
                [
                    "ArrowRight",
                    "mac+ArrowRight"
                ],
                proto._moveCaret,
                {
                    args: [
                        1
                    ]
                }
            ],
            [
                [
                    "ArrowUp",
                    "mac+ArrowUp"
                ],
                proto._moveCaret,
                {
                    args: [
                        2
                    ]
                }
            ],
            [
                [
                    "ArrowDown",
                    "mac+ArrowDown"
                ],
                proto._moveCaret,
                {
                    args: [
                        3
                    ]
                }
            ]
        ]));
    }
    constructor(params){
        super({
            ...params,
            name: "highlightEditor"
        });
        this.color = params.color || HighlightEditor._defaultColor;
        this.#thickness = params.thickness || HighlightEditor._defaultThickness;
        this.#opacity = params.opacity || HighlightEditor._defaultOpacity;
        this.#boxes = params.boxes || null;
        this.#methodOfCreation = params.methodOfCreation || "";
        this.#text = params.text || "";
        this._isDraggable = false;
        if (params.highlightId > -1) {
            this.#isFreeHighlight = true;
            this.#createFreeOutlines(params);
            this.#addToDrawLayer();
        } else if (this.#boxes) {
            this.#anchorNode = params.anchorNode;
            this.#anchorOffset = params.anchorOffset;
            this.#focusNode = params.focusNode;
            this.#focusOffset = params.focusOffset;
            this.#createOutlines();
            this.#addToDrawLayer();
            this.rotate(this.rotation);
        }
    }
    get telemetryInitialData() {
        return {
            action: "added",
            type: this.#isFreeHighlight ? "free_highlight" : "highlight",
            color: this._uiManager.highlightColorNames.get(this.color),
            thickness: this.#thickness,
            methodOfCreation: this.#methodOfCreation
        };
    }
    get telemetryFinalData() {
        return {
            type: "highlight",
            color: this._uiManager.highlightColorNames.get(this.color)
        };
    }
    static computeTelemetryFinalData(data) {
        return {
            numberOfColors: data.get("color").size
        };
    }
    #createOutlines() {
        const outliner = new HighlightOutliner(this.#boxes, 0.001);
        this.#highlightOutlines = outliner.getOutlines();
        [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;
        const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === "ltr");
        this.#focusOutlines = outlinerForOutline.getOutlines();
        const { lastPoint } = this.#focusOutlines;
        this.#lastPoint = [
            (lastPoint[0] - this.x) / this.width,
            (lastPoint[1] - this.y) / this.height
        ];
    }
    #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {
        this.#highlightOutlines = highlightOutlines;
        const extraThickness = 1.5;
        this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);
        if (highlightId >= 0) {
            this.#id = highlightId;
            this.#clipPathId = clipPathId;
            this.parent.drawLayer.finalizeDraw(highlightId, {
                bbox: highlightOutlines.box,
                path: {
                    d: highlightOutlines.toSVGPath()
                }
            });
            this.#outlineId = this.parent.drawLayer.drawOutline({
                rootClass: {
                    highlightOutline: true,
                    free: true
                },
                bbox: this.#focusOutlines.box,
                path: {
                    d: this.#focusOutlines.toSVGPath()
                }
            }, true);
        } else if (this.parent) {
            const angle = this.parent.viewport.rotation;
            this.parent.drawLayer.updateProperties(this.#id, {
                bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),
                path: {
                    d: highlightOutlines.toSVGPath()
                }
            });
            this.parent.drawLayer.updateProperties(this.#outlineId, {
                bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),
                path: {
                    d: this.#focusOutlines.toSVGPath()
                }
            });
        }
        const [x, y, width, height] = highlightOutlines.box;
        switch(this.rotation){
            case 0:
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                break;
            case 90:
                {
                    const [pageWidth, pageHeight] = this.parentDimensions;
                    this.x = y;
                    this.y = 1 - x;
                    this.width = width * pageHeight / pageWidth;
                    this.height = height * pageWidth / pageHeight;
                    break;
                }
            case 180:
                this.x = 1 - x;
                this.y = 1 - y;
                this.width = width;
                this.height = height;
                break;
            case 270:
                {
                    const [pageWidth, pageHeight] = this.parentDimensions;
                    this.x = 1 - y;
                    this.y = x;
                    this.width = width * pageHeight / pageWidth;
                    this.height = height * pageWidth / pageHeight;
                    break;
                }
        }
        const { lastPoint } = this.#focusOutlines;
        this.#lastPoint = [
            (lastPoint[0] - x) / width,
            (lastPoint[1] - y) / height
        ];
    }
    static initialize(l10n, uiManager) {
        AnnotationEditor.initialize(l10n, uiManager);
        HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || "#fff066";
    }
    static updateDefaultParams(type, value) {
        switch(type){
            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
                HighlightEditor._defaultColor = value;
                break;
            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
                HighlightEditor._defaultThickness = value;
                break;
        }
    }
    translateInPage(x, y) {}
    get toolbarPosition() {
        return this.#lastPoint;
    }
    updateParams(type, value) {
        switch(type){
            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
                this.#updateColor(value);
                break;
            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
                this.#updateThickness(value);
                break;
        }
    }
    static get defaultPropertiesToUpdate() {
        return [
            [
                AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR,
                HighlightEditor._defaultColor
            ],
            [
                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,
                HighlightEditor._defaultThickness
            ]
        ];
    }
    get propertiesToUpdate() {
        return [
            [
                AnnotationEditorParamsType.HIGHLIGHT_COLOR,
                this.color || HighlightEditor._defaultColor
            ],
            [
                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,
                this.#thickness || HighlightEditor._defaultThickness
            ],
            [
                AnnotationEditorParamsType.HIGHLIGHT_FREE,
                this.#isFreeHighlight
            ]
        ];
    }
    #updateColor(color) {
        const setColorAndOpacity = (col, opa)=>{
            this.color = col;
            this.#opacity = opa;
            this.parent?.drawLayer.updateProperties(this.#id, {
                root: {
                    fill: col,
                    "fill-opacity": opa
                }
            });
            this.#colorPicker?.updateColor(col);
        };
        const savedColor = this.color;
        const savedOpacity = this.#opacity;
        this.addCommands({
            cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),
            undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: true,
            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
            overwriteIfSameType: true,
            keepUndo: true
        });
        this._reportTelemetry({
            action: "color_changed",
            color: this._uiManager.highlightColorNames.get(color)
        }, true);
    }
    #updateThickness(thickness) {
        const savedThickness = this.#thickness;
        const setThickness = (th)=>{
            this.#thickness = th;
            this.#changeThickness(th);
        };
        this.addCommands({
            cmd: setThickness.bind(this, thickness),
            undo: setThickness.bind(this, savedThickness),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: true,
            type: AnnotationEditorParamsType.INK_THICKNESS,
            overwriteIfSameType: true,
            keepUndo: true
        });
        this._reportTelemetry({
            action: "thickness_changed",
            thickness
        }, true);
    }
    async addEditToolbar() {
        const toolbar = await super.addEditToolbar();
        if (!toolbar) return null;
        if (this._uiManager.highlightColors) {
            this.#colorPicker = new ColorPicker({
                editor: this
            });
            toolbar.addColorPicker(this.#colorPicker);
        }
        return toolbar;
    }
    disableEditing() {
        super.disableEditing();
        this.div.classList.toggle("disabled", true);
    }
    enableEditing() {
        super.enableEditing();
        this.div.classList.toggle("disabled", false);
    }
    fixAndSetPosition() {
        return super.fixAndSetPosition(this.#getRotation());
    }
    getBaseTranslation() {
        return [
            0,
            0
        ];
    }
    getRect(tx, ty) {
        return super.getRect(tx, ty, this.#getRotation());
    }
    onceAdded(focus) {
        if (!this.annotationElementId) this.parent.addUndoableEditor(this);
        if (focus) this.div.focus();
    }
    remove() {
        this.#cleanDrawLayer();
        this._reportTelemetry({
            action: "deleted"
        });
        super.remove();
    }
    rebuild() {
        if (!this.parent) return;
        super.rebuild();
        if (this.div === null) return;
        this.#addToDrawLayer();
        if (!this.isAttachedToDOM) this.parent.add(this);
    }
    setParent(parent) {
        let mustBeSelected = false;
        if (this.parent && !parent) this.#cleanDrawLayer();
        else if (parent) {
            this.#addToDrawLayer(parent);
            mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
        }
        super.setParent(parent);
        this.show(this._isVisible);
        if (mustBeSelected) this.select();
    }
    #changeThickness(thickness) {
        if (!this.#isFreeHighlight) return;
        this.#createFreeOutlines({
            highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)
        });
        this.fixAndSetPosition();
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(this.width * parentWidth, this.height * parentHeight);
    }
    #cleanDrawLayer() {
        if (this.#id === null || !this.parent) return;
        this.parent.drawLayer.remove(this.#id);
        this.#id = null;
        this.parent.drawLayer.remove(this.#outlineId);
        this.#outlineId = null;
    }
    #addToDrawLayer(parent = this.parent) {
        if (this.#id !== null) return;
        ({ id: this.#id, clipPathId: this.#clipPathId } = parent.drawLayer.draw({
            bbox: this.#highlightOutlines.box,
            root: {
                viewBox: "0 0 1 1",
                fill: this.color,
                "fill-opacity": this.#opacity
            },
            rootClass: {
                highlight: true,
                free: this.#isFreeHighlight
            },
            path: {
                d: this.#highlightOutlines.toSVGPath()
            }
        }, false, true));
        this.#outlineId = parent.drawLayer.drawOutline({
            rootClass: {
                highlightOutline: true,
                free: this.#isFreeHighlight
            },
            bbox: this.#focusOutlines.box,
            path: {
                d: this.#focusOutlines.toSVGPath()
            }
        }, this.#isFreeHighlight);
        if (this.#highlightDiv) this.#highlightDiv.style.clipPath = this.#clipPathId;
    }
    static #rotateBbox([x, y, width, height], angle) {
        switch(angle){
            case 90:
                return [
                    1 - y - height,
                    x,
                    height,
                    width
                ];
            case 180:
                return [
                    1 - x - width,
                    1 - y - height,
                    width,
                    height
                ];
            case 270:
                return [
                    y,
                    1 - x - width,
                    height,
                    width
                ];
        }
        return [
            x,
            y,
            width,
            height
        ];
    }
    rotate(angle) {
        const { drawLayer } = this.parent;
        let box;
        if (this.#isFreeHighlight) {
            angle = (angle - this.rotation + 360) % 360;
            box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);
        } else box = HighlightEditor.#rotateBbox([
            this.x,
            this.y,
            this.width,
            this.height
        ], angle);
        drawLayer.updateProperties(this.#id, {
            bbox: box,
            root: {
                "data-main-rotation": angle
            }
        });
        drawLayer.updateProperties(this.#outlineId, {
            bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),
            root: {
                "data-main-rotation": angle
            }
        });
    }
    render() {
        if (this.div) return this.div;
        const div = super.render();
        if (this.#text) {
            div.setAttribute("aria-label", this.#text);
            div.setAttribute("role", "mark");
        }
        if (this.#isFreeHighlight) div.classList.add("free");
        else this.div.addEventListener("keydown", this.#keydown.bind(this), {
            signal: this._uiManager._signal
        });
        const highlightDiv = this.#highlightDiv = document.createElement("div");
        div.append(highlightDiv);
        highlightDiv.setAttribute("aria-hidden", "true");
        highlightDiv.className = "internal";
        highlightDiv.style.clipPath = this.#clipPathId;
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(this.width * parentWidth, this.height * parentHeight);
        bindEvents(this, this.#highlightDiv, [
            "pointerover",
            "pointerleave"
        ]);
        this.enableEditing();
        return div;
    }
    pointerover() {
        if (!this.isSelected) this.parent?.drawLayer.updateProperties(this.#outlineId, {
            rootClass: {
                hovered: true
            }
        });
    }
    pointerleave() {
        if (!this.isSelected) this.parent?.drawLayer.updateProperties(this.#outlineId, {
            rootClass: {
                hovered: false
            }
        });
    }
    #keydown(event) {
        HighlightEditor._keyboardManager.exec(this, event);
    }
    _moveCaret(direction) {
        this.parent.unselect(this);
        switch(direction){
            case 0:
            case 2:
                this.#setCaret(true);
                break;
            case 1:
            case 3:
                this.#setCaret(false);
                break;
        }
    }
    #setCaret(start) {
        if (!this.#anchorNode) return;
        const selection = window.getSelection();
        if (start) selection.setPosition(this.#anchorNode, this.#anchorOffset);
        else selection.setPosition(this.#focusNode, this.#focusOffset);
    }
    select() {
        super.select();
        if (!this.#outlineId) return;
        this.parent?.drawLayer.updateProperties(this.#outlineId, {
            rootClass: {
                hovered: false,
                selected: true
            }
        });
    }
    unselect() {
        super.unselect();
        if (!this.#outlineId) return;
        this.parent?.drawLayer.updateProperties(this.#outlineId, {
            rootClass: {
                selected: false
            }
        });
        if (!this.#isFreeHighlight) this.#setCaret(false);
    }
    get _mustFixPosition() {
        return !this.#isFreeHighlight;
    }
    show(visible = this._isVisible) {
        super.show(visible);
        if (this.parent) {
            this.parent.drawLayer.updateProperties(this.#id, {
                rootClass: {
                    hidden: !visible
                }
            });
            this.parent.drawLayer.updateProperties(this.#outlineId, {
                rootClass: {
                    hidden: !visible
                }
            });
        }
    }
    #getRotation() {
        return this.#isFreeHighlight ? this.rotation : 0;
    }
    #serializeBoxes() {
        if (this.#isFreeHighlight) return null;
        const [pageWidth, pageHeight] = this.pageDimensions;
        const [pageX, pageY] = this.pageTranslation;
        const boxes = this.#boxes;
        const quadPoints = new Float32Array(boxes.length * 8);
        let i = 0;
        for (const { x, y, width, height } of boxes){
            const sx = x * pageWidth + pageX;
            const sy = (1 - y) * pageHeight + pageY;
            quadPoints[i] = quadPoints[i + 4] = sx;
            quadPoints[i + 1] = quadPoints[i + 3] = sy;
            quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
            quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;
            i += 8;
        }
        return quadPoints;
    }
    #serializeOutlines(rect) {
        return this.#highlightOutlines.serialize(rect, this.#getRotation());
    }
    static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {
        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();
        const ac = new AbortController();
        const signal = parent.combinedSignal(ac);
        const pointerUpCallback = (e)=>{
            ac.abort();
            this.#endHighlight(parent, e);
        };
        window.addEventListener("blur", pointerUpCallback, {
            signal
        });
        window.addEventListener("pointerup", pointerUpCallback, {
            signal
        });
        window.addEventListener("pointerdown", stopEvent, {
            capture: true,
            passive: false,
            signal
        });
        window.addEventListener("contextmenu", noContextMenu, {
            signal
        });
        textLayer.addEventListener("pointermove", this.#highlightMove.bind(this, parent), {
            signal
        });
        this._freeHighlight = new FreeHighlightOutliner({
            x,
            y
        }, [
            layerX,
            layerY,
            parentWidth,
            parentHeight
        ], parent.scale, this._defaultThickness / 2, isLTR, 0.001);
        ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = parent.drawLayer.draw({
            bbox: [
                0,
                0,
                1,
                1
            ],
            root: {
                viewBox: "0 0 1 1",
                fill: this._defaultColor,
                "fill-opacity": this._defaultOpacity
            },
            rootClass: {
                highlight: true,
                free: true
            },
            path: {
                d: this._freeHighlight.toSVGPath()
            }
        }, true, true));
    }
    static #highlightMove(parent, event) {
        if (this._freeHighlight.add(event)) parent.drawLayer.updateProperties(this._freeHighlightId, {
            path: {
                d: this._freeHighlight.toSVGPath()
            }
        });
    }
    static #endHighlight(parent, event) {
        if (!this._freeHighlight.isEmpty()) parent.createAndAddNewEditor(event, false, {
            highlightId: this._freeHighlightId,
            highlightOutlines: this._freeHighlight.getOutlines(),
            clipPathId: this._freeHighlightClipId,
            methodOfCreation: "main_toolbar"
        });
        else parent.drawLayer.remove(this._freeHighlightId);
        this._freeHighlightId = -1;
        this._freeHighlight = null;
        this._freeHighlightClipId = "";
    }
    static async deserialize(data, parent, uiManager) {
        let initialData = null;
        if (data instanceof HighlightAnnotationElement) {
            const { data: { quadPoints, rect, rotation, id, color, opacity, popupRef }, parent: { page: { pageNumber } } } = data;
            initialData = data = {
                annotationType: AnnotationEditorType.HIGHLIGHT,
                color: Array.from(color),
                opacity,
                quadPoints,
                boxes: null,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                id,
                deleted: false,
                popupRef
            };
        } else if (data instanceof InkAnnotationElement) {
            const { data: { inkLists, rect, rotation, id, color, borderStyle: { rawWidth: thickness }, popupRef }, parent: { page: { pageNumber } } } = data;
            initialData = data = {
                annotationType: AnnotationEditorType.HIGHLIGHT,
                color: Array.from(color),
                thickness,
                inkLists,
                boxes: null,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                id,
                deleted: false,
                popupRef
            };
        }
        const { color, quadPoints, inkLists, opacity } = data;
        const editor = await super.deserialize(data, parent, uiManager);
        editor.color = Util.makeHexColor(...color);
        editor.#opacity = opacity || 1;
        if (inkLists) editor.#thickness = data.thickness;
        editor.annotationElementId = data.id || null;
        editor._initialData = initialData;
        const [pageWidth, pageHeight] = editor.pageDimensions;
        const [pageX, pageY] = editor.pageTranslation;
        if (quadPoints) {
            const boxes = editor.#boxes = [];
            for(let i = 0; i < quadPoints.length; i += 8)boxes.push({
                x: (quadPoints[i] - pageX) / pageWidth,
                y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,
                width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
                height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight
            });
            editor.#createOutlines();
            editor.#addToDrawLayer();
            editor.rotate(editor.rotation);
        } else if (inkLists) {
            editor.#isFreeHighlight = true;
            const points = inkLists[0];
            const point = {
                x: points[0] - pageX,
                y: pageHeight - (points[1] - pageY)
            };
            const outliner = new FreeHighlightOutliner(point, [
                0,
                0,
                pageWidth,
                pageHeight
            ], 1, editor.#thickness / 2, true, 0.001);
            for(let i = 0, ii = points.length; i < ii; i += 2){
                point.x = points[i] - pageX;
                point.y = pageHeight - (points[i + 1] - pageY);
                outliner.add(point);
            }
            const { id, clipPathId } = parent.drawLayer.draw({
                bbox: [
                    0,
                    0,
                    1,
                    1
                ],
                root: {
                    viewBox: "0 0 1 1",
                    fill: editor.color,
                    "fill-opacity": editor._defaultOpacity
                },
                rootClass: {
                    highlight: true,
                    free: true
                },
                path: {
                    d: outliner.toSVGPath()
                }
            }, true, true);
            editor.#createFreeOutlines({
                highlightOutlines: outliner.getOutlines(),
                highlightId: id,
                clipPathId
            });
            editor.#addToDrawLayer();
        }
        return editor;
    }
    serialize(isForCopying = false) {
        if (this.isEmpty() || isForCopying) return null;
        if (this.deleted) return this.serializeDeleted();
        const rect = this.getRect(0, 0);
        const color = AnnotationEditor._colorManager.convert(this.color);
        const serialized = {
            annotationType: AnnotationEditorType.HIGHLIGHT,
            color,
            opacity: this.#opacity,
            thickness: this.#thickness,
            quadPoints: this.#serializeBoxes(),
            outlines: this.#serializeOutlines(rect),
            pageIndex: this.pageIndex,
            rect,
            rotation: this.#getRotation(),
            structTreeParentId: this._structTreeParentId
        };
        if (this.annotationElementId && !this.#hasElementChanged(serialized)) return null;
        serialized.id = this.annotationElementId;
        return serialized;
    }
    #hasElementChanged(serialized) {
        const { color } = this._initialData;
        return serialized.color.some((c, i)=>c !== color[i]);
    }
    renderAnnotationElement(annotation) {
        annotation.updateEdited({
            rect: this.getRect(0, 0)
        });
        return null;
    }
    static canCreateNewEmptyEditor() {
        return false;
    }
}
class DrawingOptions {
    #svgProperties = Object.create(null);
    updateProperty(name, value) {
        this[name] = value;
        this.updateSVGProperty(name, value);
    }
    updateProperties(properties) {
        if (!properties) return;
        for (const [name, value] of Object.entries(properties))this.updateProperty(name, value);
    }
    updateSVGProperty(name, value) {
        this.#svgProperties[name] = value;
    }
    toSVGProperties() {
        const root = this.#svgProperties;
        this.#svgProperties = Object.create(null);
        return {
            root
        };
    }
    reset() {
        this.#svgProperties = Object.create(null);
    }
    updateAll(options = this) {
        this.updateProperties(options);
    }
    clone() {
        unreachable("Not implemented");
    }
}
class DrawingEditor extends AnnotationEditor {
    #drawOutlines = null;
    #mustBeCommitted;
    _drawId = null;
    static _currentDrawId = -1;
    static _currentParent = null;
    static #currentDraw = null;
    static #currentDrawingAC = null;
    static #currentDrawingOptions = null;
    static #currentPointerId = NaN;
    static #currentPointerType = null;
    static #currentPointerIds = null;
    static #currentMoveTimestamp = NaN;
    static _INNER_MARGIN = 3;
    constructor(params){
        super(params);
        this.#mustBeCommitted = params.mustBeCommitted || false;
        if (params.drawOutlines) {
            this.#createDrawOutlines(params);
            this.#addToDrawLayer();
        }
    }
    #createDrawOutlines({ drawOutlines, drawId, drawingOptions }) {
        this.#drawOutlines = drawOutlines;
        this._drawingOptions ||= drawingOptions;
        if (drawId >= 0) {
            this._drawId = drawId;
            this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);
        } else this._drawId = this.#createDrawing(drawOutlines, this.parent);
        this.#updateBbox(drawOutlines.box);
    }
    #createDrawing(drawOutlines, parent) {
        const { id } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);
        return id;
    }
    static _mergeSVGProperties(p1, p2) {
        const p1Keys = new Set(Object.keys(p1));
        for (const [key, value] of Object.entries(p2))if (p1Keys.has(key)) Object.assign(p1[key], value);
        else p1[key] = value;
        return p1;
    }
    static getDefaultDrawingOptions(_options) {
        unreachable("Not implemented");
    }
    static get typesMap() {
        unreachable("Not implemented");
    }
    static get isDrawer() {
        return true;
    }
    static get supportMultipleDrawings() {
        return false;
    }
    static updateDefaultParams(type, value) {
        const propertyName = this.typesMap.get(type);
        if (propertyName) this._defaultDrawingOptions.updateProperty(propertyName, value);
        if (this._currentParent) {
            DrawingEditor.#currentDraw.updateProperty(propertyName, value);
            this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
        }
    }
    updateParams(type, value) {
        const propertyName = this.constructor.typesMap.get(type);
        if (propertyName) this._updateProperty(type, propertyName, value);
    }
    static get defaultPropertiesToUpdate() {
        const properties = [];
        const options = this._defaultDrawingOptions;
        for (const [type, name] of this.typesMap)properties.push([
            type,
            options[name]
        ]);
        return properties;
    }
    get propertiesToUpdate() {
        const properties = [];
        const { _drawingOptions } = this;
        for (const [type, name] of this.constructor.typesMap)properties.push([
            type,
            _drawingOptions[name]
        ]);
        return properties;
    }
    _updateProperty(type, name, value) {
        const options = this._drawingOptions;
        const savedValue = options[name];
        const setter = (val)=>{
            options.updateProperty(name, val);
            const bbox = this.#drawOutlines.updateProperty(name, val);
            if (bbox) this.#updateBbox(bbox);
            this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());
        };
        this.addCommands({
            cmd: setter.bind(this, value),
            undo: setter.bind(this, savedValue),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: true,
            type,
            overwriteIfSameType: true,
            keepUndo: true
        });
    }
    _onResizing() {
        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {
            bbox: this.#rotateBox()
        }));
    }
    _onResized() {
        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {
            bbox: this.#rotateBox()
        }));
    }
    _onTranslating(x, y) {
        this.parent?.drawLayer.updateProperties(this._drawId, {
            bbox: this.#rotateBox(x, y)
        });
    }
    _onTranslated() {
        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {
            bbox: this.#rotateBox()
        }));
    }
    _onStartDragging() {
        this.parent?.drawLayer.updateProperties(this._drawId, {
            rootClass: {
                moving: true
            }
        });
    }
    _onStopDragging() {
        this.parent?.drawLayer.updateProperties(this._drawId, {
            rootClass: {
                moving: false
            }
        });
    }
    commit() {
        super.commit();
        this.disableEditMode();
        this.disableEditing();
    }
    disableEditing() {
        super.disableEditing();
        this.div.classList.toggle("disabled", true);
    }
    enableEditing() {
        super.enableEditing();
        this.div.classList.toggle("disabled", false);
    }
    getBaseTranslation() {
        return [
            0,
            0
        ];
    }
    get isResizable() {
        return true;
    }
    onceAdded(focus) {
        if (!this.annotationElementId) this.parent.addUndoableEditor(this);
        this._isDraggable = true;
        if (this.#mustBeCommitted) {
            this.#mustBeCommitted = false;
            this.commit();
            this.parent.setSelected(this);
            if (focus && this.isOnScreen) this.div.focus();
        }
    }
    remove() {
        this.#cleanDrawLayer();
        super.remove();
    }
    rebuild() {
        if (!this.parent) return;
        super.rebuild();
        if (this.div === null) return;
        this.#addToDrawLayer();
        this.#updateBbox(this.#drawOutlines.box);
        if (!this.isAttachedToDOM) this.parent.add(this);
    }
    setParent(parent) {
        let mustBeSelected = false;
        if (this.parent && !parent) {
            this._uiManager.removeShouldRescale(this);
            this.#cleanDrawLayer();
        } else if (parent) {
            this._uiManager.addShouldRescale(this);
            this.#addToDrawLayer(parent);
            mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
        }
        super.setParent(parent);
        if (mustBeSelected) this.select();
    }
    #cleanDrawLayer() {
        if (this._drawId === null || !this.parent) return;
        this.parent.drawLayer.remove(this._drawId);
        this._drawId = null;
        this._drawingOptions.reset();
    }
    #addToDrawLayer(parent = this.parent) {
        if (this._drawId !== null && this.parent === parent) return;
        if (this._drawId !== null) {
            this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);
            return;
        }
        this._drawingOptions.updateAll();
        this._drawId = this.#createDrawing(this.#drawOutlines, parent);
    }
    #convertToParentSpace([x, y, width, height]) {
        const { parentDimensions: [pW, pH], rotation } = this;
        switch(rotation){
            case 90:
                return [
                    y,
                    1 - x,
                    width * (pH / pW),
                    height * (pW / pH)
                ];
            case 180:
                return [
                    1 - x,
                    1 - y,
                    width,
                    height
                ];
            case 270:
                return [
                    1 - y,
                    x,
                    width * (pH / pW),
                    height * (pW / pH)
                ];
            default:
                return [
                    x,
                    y,
                    width,
                    height
                ];
        }
    }
    #convertToDrawSpace() {
        const { x, y, width, height, parentDimensions: [pW, pH], rotation } = this;
        switch(rotation){
            case 90:
                return [
                    1 - y,
                    x,
                    width * (pW / pH),
                    height * (pH / pW)
                ];
            case 180:
                return [
                    1 - x,
                    1 - y,
                    width,
                    height
                ];
            case 270:
                return [
                    y,
                    1 - x,
                    width * (pW / pH),
                    height * (pH / pW)
                ];
            default:
                return [
                    x,
                    y,
                    width,
                    height
                ];
        }
    }
    #updateBbox(bbox) {
        [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);
        if (this.div) {
            this.fixAndSetPosition();
            const [parentWidth, parentHeight] = this.parentDimensions;
            this.setDims(this.width * parentWidth, this.height * parentHeight);
        }
        this._onResized();
    }
    #rotateBox() {
        const { x, y, width, height, rotation, parentRotation, parentDimensions: [pW, pH] } = this;
        switch((rotation * 4 + parentRotation) / 90){
            case 1:
                return [
                    1 - y - height,
                    x,
                    height,
                    width
                ];
            case 2:
                return [
                    1 - x - width,
                    1 - y - height,
                    width,
                    height
                ];
            case 3:
                return [
                    y,
                    1 - x - width,
                    height,
                    width
                ];
            case 4:
                return [
                    x,
                    y - width * (pW / pH),
                    height * (pH / pW),
                    width * (pW / pH)
                ];
            case 5:
                return [
                    1 - y,
                    x,
                    width * (pW / pH),
                    height * (pH / pW)
                ];
            case 6:
                return [
                    1 - x - height * (pH / pW),
                    1 - y,
                    height * (pH / pW),
                    width * (pW / pH)
                ];
            case 7:
                return [
                    y - width * (pW / pH),
                    1 - x - height * (pH / pW),
                    width * (pW / pH),
                    height * (pH / pW)
                ];
            case 8:
                return [
                    x - width,
                    y - height,
                    width,
                    height
                ];
            case 9:
                return [
                    1 - y,
                    x - width,
                    height,
                    width
                ];
            case 10:
                return [
                    1 - x,
                    1 - y,
                    width,
                    height
                ];
            case 11:
                return [
                    y - height,
                    1 - x,
                    height,
                    width
                ];
            case 12:
                return [
                    x - height * (pH / pW),
                    y,
                    height * (pH / pW),
                    width * (pW / pH)
                ];
            case 13:
                return [
                    1 - y - width * (pW / pH),
                    x - height * (pH / pW),
                    width * (pW / pH),
                    height * (pH / pW)
                ];
            case 14:
                return [
                    1 - x,
                    1 - y - width * (pW / pH),
                    height * (pH / pW),
                    width * (pW / pH)
                ];
            case 15:
                return [
                    y,
                    1 - x,
                    width * (pW / pH),
                    height * (pH / pW)
                ];
            default:
                return [
                    x,
                    y,
                    width,
                    height
                ];
        }
    }
    rotate() {
        if (!this.parent) return;
        this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({
            bbox: this.#rotateBox()
        }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));
    }
    onScaleChanging() {
        if (!this.parent) return;
        this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));
    }
    static onScaleChangingWhenDrawing() {}
    render() {
        if (this.div) return this.div;
        const div = super.render();
        div.classList.add("draw");
        const drawDiv = document.createElement("div");
        div.append(drawDiv);
        drawDiv.setAttribute("aria-hidden", "true");
        drawDiv.className = "internal";
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(this.width * parentWidth, this.height * parentHeight);
        this._uiManager.addShouldRescale(this);
        this.disableEditing();
        return div;
    }
    static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {
        unreachable("Not implemented");
    }
    static startDrawing(parent, uiManager, _isLTR, event) {
        const { target, offsetX: x, offsetY: y, pointerId, pointerType } = event;
        if (DrawingEditor.#currentPointerType && DrawingEditor.#currentPointerType !== pointerType) return;
        const { viewport: { rotation } } = parent;
        const { width: parentWidth, height: parentHeight } = target.getBoundingClientRect();
        const ac = DrawingEditor.#currentDrawingAC = new AbortController();
        const signal = parent.combinedSignal(ac);
        DrawingEditor.#currentPointerId ||= pointerId;
        DrawingEditor.#currentPointerType ??= pointerType;
        window.addEventListener("pointerup", (e)=>{
            if (DrawingEditor.#currentPointerId === e.pointerId) this._endDraw(e);
            else DrawingEditor.#currentPointerIds?.delete(e.pointerId);
        }, {
            signal
        });
        window.addEventListener("pointercancel", (e)=>{
            if (DrawingEditor.#currentPointerId === e.pointerId) this._currentParent.endDrawingSession();
            else DrawingEditor.#currentPointerIds?.delete(e.pointerId);
        }, {
            signal
        });
        window.addEventListener("pointerdown", (e)=>{
            if (DrawingEditor.#currentPointerType !== e.pointerType) return;
            (DrawingEditor.#currentPointerIds ||= new Set()).add(e.pointerId);
            if (DrawingEditor.#currentDraw.isCancellable()) {
                DrawingEditor.#currentDraw.removeLastElement();
                if (DrawingEditor.#currentDraw.isEmpty()) this._currentParent.endDrawingSession(true);
                else this._endDraw(null);
            }
        }, {
            capture: true,
            passive: false,
            signal
        });
        window.addEventListener("contextmenu", noContextMenu, {
            signal
        });
        target.addEventListener("pointermove", this._drawMove.bind(this), {
            signal
        });
        target.addEventListener("touchmove", (e)=>{
            if (e.timeStamp === DrawingEditor.#currentMoveTimestamp) stopEvent(e);
        }, {
            signal
        });
        parent.toggleDrawing();
        uiManager._editorUndoBar?.hide();
        if (DrawingEditor.#currentDraw) {
            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));
            return;
        }
        uiManager.updateUIForDefaultProperties(this);
        DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);
        DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();
        this._currentParent = parent;
        ({ id: this._currentDrawId } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));
    }
    static _drawMove(event) {
        DrawingEditor.#currentMoveTimestamp = -1;
        if (!DrawingEditor.#currentDraw) return;
        const { offsetX, offsetY, pointerId } = event;
        if (DrawingEditor.#currentPointerId !== pointerId) return;
        if (DrawingEditor.#currentPointerIds?.size >= 1) {
            this._endDraw(event);
            return;
        }
        this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));
        DrawingEditor.#currentMoveTimestamp = event.timeStamp;
        stopEvent(event);
    }
    static _cleanup(all) {
        if (all) {
            this._currentDrawId = -1;
            this._currentParent = null;
            DrawingEditor.#currentDraw = null;
            DrawingEditor.#currentDrawingOptions = null;
            DrawingEditor.#currentPointerType = null;
            DrawingEditor.#currentMoveTimestamp = NaN;
        }
        if (DrawingEditor.#currentDrawingAC) {
            DrawingEditor.#currentDrawingAC.abort();
            DrawingEditor.#currentDrawingAC = null;
            DrawingEditor.#currentPointerId = NaN;
            DrawingEditor.#currentPointerIds = null;
        }
    }
    static _endDraw(event) {
        const parent = this._currentParent;
        if (!parent) return;
        parent.toggleDrawing(true);
        this._cleanup(false);
        if (event) parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));
        if (this.supportMultipleDrawings) {
            const draw = DrawingEditor.#currentDraw;
            const drawId = this._currentDrawId;
            const lastElement = draw.getLastElement();
            parent.addCommands({
                cmd: ()=>{
                    parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));
                },
                undo: ()=>{
                    parent.drawLayer.updateProperties(drawId, draw.removeLastElement());
                },
                mustExec: false,
                type: AnnotationEditorParamsType.DRAW_STEP
            });
            return;
        }
        this.endDrawing(false);
    }
    static endDrawing(isAborted) {
        const parent = this._currentParent;
        if (!parent) return null;
        parent.toggleDrawing(true);
        parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);
        if (!DrawingEditor.#currentDraw.isEmpty()) {
            const { pageDimensions: [pageWidth, pageHeight], scale } = parent;
            const editor = parent.createAndAddNewEditor({
                offsetX: 0,
                offsetY: 0
            }, false, {
                drawId: this._currentDrawId,
                drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),
                drawingOptions: DrawingEditor.#currentDrawingOptions,
                mustBeCommitted: !isAborted
            });
            this._cleanup(true);
            return editor;
        }
        parent.drawLayer.remove(this._currentDrawId);
        this._cleanup(true);
        return null;
    }
    createDrawingOptions(_data) {}
    static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {
        unreachable("Not implemented");
    }
    static async deserialize(data, parent, uiManager) {
        const { rawDims: { pageWidth, pageHeight, pageX, pageY } } = parent.viewport;
        const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);
        const editor = await super.deserialize(data, parent, uiManager);
        editor.createDrawingOptions(data);
        editor.#createDrawOutlines({
            drawOutlines
        });
        editor.#addToDrawLayer();
        editor.onScaleChanging();
        editor.rotate();
        return editor;
    }
    serializeDraw(isForCopying) {
        const [pageX, pageY] = this.pageTranslation;
        const [pageWidth, pageHeight] = this.pageDimensions;
        return this.#drawOutlines.serialize([
            pageX,
            pageY,
            pageWidth,
            pageHeight
        ], isForCopying);
    }
    renderAnnotationElement(annotation) {
        annotation.updateEdited({
            rect: this.getRect(0, 0)
        });
        return null;
    }
    static canCreateNewEmptyEditor() {
        return false;
    }
}
class InkDrawOutliner {
    #last = new Float64Array(6);
    #line;
    #lines;
    #rotation;
    #thickness;
    #points;
    #lastSVGPath = "";
    #lastIndex = 0;
    #outlines = new InkDrawOutline();
    #parentWidth;
    #parentHeight;
    constructor(x, y, parentWidth, parentHeight, rotation, thickness){
        this.#parentWidth = parentWidth;
        this.#parentHeight = parentHeight;
        this.#rotation = rotation;
        this.#thickness = thickness;
        [x, y] = this.#normalizePoint(x, y);
        const line = this.#line = [
            NaN,
            NaN,
            NaN,
            NaN,
            x,
            y
        ];
        this.#points = [
            x,
            y
        ];
        this.#lines = [
            {
                line,
                points: this.#points
            }
        ];
        this.#last.set(line, 0);
    }
    updateProperty(name, value) {
        if (name === "stroke-width") this.#thickness = value;
    }
    #normalizePoint(x, y) {
        return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);
    }
    isEmpty() {
        return !this.#lines || this.#lines.length === 0;
    }
    isCancellable() {
        return this.#points.length <= 10;
    }
    add(x, y) {
        [x, y] = this.#normalizePoint(x, y);
        const [x1, y1, x2, y2] = this.#last.subarray(2, 6);
        const diffX = x - x2;
        const diffY = y - y2;
        const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);
        if (d <= 2) return null;
        this.#points.push(x, y);
        if (isNaN(x1)) {
            this.#last.set([
                x2,
                y2,
                x,
                y
            ], 2);
            this.#line.push(NaN, NaN, NaN, NaN, x, y);
            return {
                path: {
                    d: this.toSVGPath()
                }
            };
        }
        if (isNaN(this.#last[0])) this.#line.splice(6, 6);
        this.#last.set([
            x1,
            y1,
            x2,
            y2,
            x,
            y
        ], 0);
        this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));
        return {
            path: {
                d: this.toSVGPath()
            }
        };
    }
    end(x, y) {
        const change = this.add(x, y);
        if (change) return change;
        if (this.#points.length === 2) return {
            path: {
                d: this.toSVGPath()
            }
        };
        return null;
    }
    startNew(x, y, parentWidth, parentHeight, rotation) {
        this.#parentWidth = parentWidth;
        this.#parentHeight = parentHeight;
        this.#rotation = rotation;
        [x, y] = this.#normalizePoint(x, y);
        const line = this.#line = [
            NaN,
            NaN,
            NaN,
            NaN,
            x,
            y
        ];
        this.#points = [
            x,
            y
        ];
        const last = this.#lines.at(-1);
        if (last) {
            last.line = new Float32Array(last.line);
            last.points = new Float32Array(last.points);
        }
        this.#lines.push({
            line,
            points: this.#points
        });
        this.#last.set(line, 0);
        this.#lastIndex = 0;
        this.toSVGPath();
        return null;
    }
    getLastElement() {
        return this.#lines.at(-1);
    }
    setLastElement(element) {
        if (!this.#lines) return this.#outlines.setLastElement(element);
        this.#lines.push(element);
        this.#line = element.line;
        this.#points = element.points;
        this.#lastIndex = 0;
        return {
            path: {
                d: this.toSVGPath()
            }
        };
    }
    removeLastElement() {
        if (!this.#lines) return this.#outlines.removeLastElement();
        this.#lines.pop();
        this.#lastSVGPath = "";
        for(let i = 0, ii = this.#lines.length; i < ii; i++){
            const { line, points } = this.#lines[i];
            this.#line = line;
            this.#points = points;
            this.#lastIndex = 0;
            this.toSVGPath();
        }
        return {
            path: {
                d: this.#lastSVGPath
            }
        };
    }
    toSVGPath() {
        const firstX = Outline.svgRound(this.#line[4]);
        const firstY = Outline.svgRound(this.#line[5]);
        if (this.#points.length === 2) {
            this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;
            return this.#lastSVGPath;
        }
        if (this.#points.length <= 6) {
            const i = this.#lastSVGPath.lastIndexOf("M");
            this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;
            this.#lastIndex = 6;
        }
        if (this.#points.length === 4) {
            const secondX = Outline.svgRound(this.#line[10]);
            const secondY = Outline.svgRound(this.#line[11]);
            this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;
            this.#lastIndex = 12;
            return this.#lastSVGPath;
        }
        const buffer = [];
        if (this.#lastIndex === 0) {
            buffer.push(`M ${firstX} ${firstY}`);
            this.#lastIndex = 6;
        }
        for(let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6){
            const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);
            buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
        }
        this.#lastSVGPath += buffer.join(" ");
        this.#lastIndex = this.#line.length;
        return this.#lastSVGPath;
    }
    getOutlines(parentWidth, parentHeight, scale, innerMargin) {
        const last = this.#lines.at(-1);
        last.line = new Float32Array(last.line);
        last.points = new Float32Array(last.points);
        this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);
        this.#last = null;
        this.#line = null;
        this.#lines = null;
        this.#lastSVGPath = null;
        return this.#outlines;
    }
    get defaultSVGProperties() {
        return {
            root: {
                viewBox: "0 0 10000 10000"
            },
            rootClass: {
                draw: true
            },
            bbox: [
                0,
                0,
                1,
                1
            ]
        };
    }
}
class InkDrawOutline extends Outline {
    #bbox;
    #currentRotation = 0;
    #innerMargin;
    #lines;
    #parentWidth;
    #parentHeight;
    #parentScale;
    #rotation;
    #thickness;
    build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {
        this.#parentWidth = parentWidth;
        this.#parentHeight = parentHeight;
        this.#parentScale = parentScale;
        this.#rotation = rotation;
        this.#thickness = thickness;
        this.#innerMargin = innerMargin ?? 0;
        this.#lines = lines;
        this.#computeBbox();
    }
    setLastElement(element) {
        this.#lines.push(element);
        return {
            path: {
                d: this.toSVGPath()
            }
        };
    }
    removeLastElement() {
        this.#lines.pop();
        return {
            path: {
                d: this.toSVGPath()
            }
        };
    }
    toSVGPath() {
        const buffer = [];
        for (const { line } of this.#lines){
            buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);
            if (line.length === 6) {
                buffer.push("Z");
                continue;
            }
            if (line.length === 12) {
                buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);
                continue;
            }
            for(let i = 6, ii = line.length; i < ii; i += 6){
                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);
                buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
            }
        }
        return buffer.join("");
    }
    serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {
        const serializedLines = [];
        const serializedPoints = [];
        const [x, y, width, height] = this.#getBBoxWithNoMargin();
        let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;
        switch(this.#rotation){
            case 0:
                rescaleFn = Outline._rescale;
                tx = pageX;
                ty = pageY + pageHeight;
                sx = pageWidth;
                sy = -pageHeight;
                x1 = pageX + x * pageWidth;
                y1 = pageY + (1 - y - height) * pageHeight;
                x2 = pageX + (x + width) * pageWidth;
                y2 = pageY + (1 - y) * pageHeight;
                break;
            case 90:
                rescaleFn = Outline._rescaleAndSwap;
                tx = pageX;
                ty = pageY;
                sx = pageWidth;
                sy = pageHeight;
                x1 = pageX + y * pageWidth;
                y1 = pageY + x * pageHeight;
                x2 = pageX + (y + height) * pageWidth;
                y2 = pageY + (x + width) * pageHeight;
                break;
            case 180:
                rescaleFn = Outline._rescale;
                tx = pageX + pageWidth;
                ty = pageY;
                sx = -pageWidth;
                sy = pageHeight;
                x1 = pageX + (1 - x - width) * pageWidth;
                y1 = pageY + y * pageHeight;
                x2 = pageX + (1 - x) * pageWidth;
                y2 = pageY + (y + height) * pageHeight;
                break;
            case 270:
                rescaleFn = Outline._rescaleAndSwap;
                tx = pageX + pageWidth;
                ty = pageY + pageHeight;
                sx = -pageWidth;
                sy = -pageHeight;
                x1 = pageX + (1 - y - height) * pageWidth;
                y1 = pageY + (1 - x - width) * pageHeight;
                x2 = pageX + (1 - y) * pageWidth;
                y2 = pageY + (1 - x) * pageHeight;
                break;
        }
        for (const { line, points } of this.#lines){
            serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));
            serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));
        }
        return {
            lines: serializedLines,
            points: serializedPoints,
            rect: [
                x1,
                y1,
                x2,
                y2
            ]
        };
    }
    static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, { paths: { lines, points }, rotation, thickness }) {
        const newLines = [];
        let tx, ty, sx, sy, rescaleFn;
        switch(rotation){
            case 0:
                rescaleFn = Outline._rescale;
                tx = -pageX / pageWidth;
                ty = pageY / pageHeight + 1;
                sx = 1 / pageWidth;
                sy = -1 / pageHeight;
                break;
            case 90:
                rescaleFn = Outline._rescaleAndSwap;
                tx = -pageY / pageHeight;
                ty = -pageX / pageWidth;
                sx = 1 / pageHeight;
                sy = 1 / pageWidth;
                break;
            case 180:
                rescaleFn = Outline._rescale;
                tx = pageX / pageWidth + 1;
                ty = -pageY / pageHeight;
                sx = -1 / pageWidth;
                sy = 1 / pageHeight;
                break;
            case 270:
                rescaleFn = Outline._rescaleAndSwap;
                tx = pageY / pageHeight + 1;
                ty = pageX / pageWidth + 1;
                sx = -1 / pageHeight;
                sy = -1 / pageWidth;
                break;
        }
        if (!lines) {
            lines = [];
            for (const point of points){
                const len = point.length;
                if (len === 2) {
                    lines.push(new Float32Array([
                        NaN,
                        NaN,
                        NaN,
                        NaN,
                        point[0],
                        point[1]
                    ]));
                    continue;
                }
                if (len === 4) {
                    lines.push(new Float32Array([
                        NaN,
                        NaN,
                        NaN,
                        NaN,
                        point[0],
                        point[1],
                        NaN,
                        NaN,
                        NaN,
                        NaN,
                        point[2],
                        point[3]
                    ]));
                    continue;
                }
                const line = new Float32Array(3 * (len - 2));
                lines.push(line);
                let [x1, y1, x2, y2] = point.subarray(0, 4);
                line.set([
                    NaN,
                    NaN,
                    NaN,
                    NaN,
                    x1,
                    y1
                ], 0);
                for(let i = 4; i < len; i += 2){
                    const x = point[i];
                    const y = point[i + 1];
                    line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
                    [x1, y1, x2, y2] = [
                        x2,
                        y2,
                        x,
                        y
                    ];
                }
            }
        }
        for(let i = 0, ii = lines.length; i < ii; i++)newLines.push({
            line: rescaleFn(lines[i].map((x)=>x ?? NaN), tx, ty, sx, sy),
            points: rescaleFn(points[i].map((x)=>x ?? NaN), tx, ty, sx, sy)
        });
        const outlines = new InkDrawOutline();
        outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);
        return outlines;
    }
    #getMarginComponents(thickness = this.#thickness) {
        const margin = this.#innerMargin + thickness / 2 * this.#parentScale;
        return this.#rotation % 180 === 0 ? [
            margin / this.#parentWidth,
            margin / this.#parentHeight
        ] : [
            margin / this.#parentHeight,
            margin / this.#parentWidth
        ];
    }
    #getBBoxWithNoMargin() {
        const [x, y, width, height] = this.#bbox;
        const [marginX, marginY] = this.#getMarginComponents(0);
        return [
            x + marginX,
            y + marginY,
            width - 2 * marginX,
            height - 2 * marginY
        ];
    }
    #computeBbox() {
        const bbox = this.#bbox = new Float32Array([
            Infinity,
            Infinity,
            -Infinity,
            -Infinity
        ]);
        for (const { line } of this.#lines){
            if (line.length <= 12) {
                for(let i = 4, ii = line.length; i < ii; i += 6){
                    const [x, y] = line.subarray(i, i + 2);
                    bbox[0] = Math.min(bbox[0], x);
                    bbox[1] = Math.min(bbox[1], y);
                    bbox[2] = Math.max(bbox[2], x);
                    bbox[3] = Math.max(bbox[3], y);
                }
                continue;
            }
            let lastX = line[4], lastY = line[5];
            for(let i = 6, ii = line.length; i < ii; i += 6){
                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);
                Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);
                lastX = x;
                lastY = y;
            }
        }
        const [marginX, marginY] = this.#getMarginComponents();
        bbox[0] = Math.min(1, Math.max(0, bbox[0] - marginX));
        bbox[1] = Math.min(1, Math.max(0, bbox[1] - marginY));
        bbox[2] = Math.min(1, Math.max(0, bbox[2] + marginX));
        bbox[3] = Math.min(1, Math.max(0, bbox[3] + marginY));
        bbox[2] -= bbox[0];
        bbox[3] -= bbox[1];
    }
    get box() {
        return this.#bbox;
    }
    updateProperty(name, value) {
        if (name === "stroke-width") return this.#updateThickness(value);
        return null;
    }
    #updateThickness(thickness) {
        const [oldMarginX, oldMarginY] = this.#getMarginComponents();
        this.#thickness = thickness;
        const [newMarginX, newMarginY] = this.#getMarginComponents();
        const [diffMarginX, diffMarginY] = [
            newMarginX - oldMarginX,
            newMarginY - oldMarginY
        ];
        const bbox = this.#bbox;
        bbox[0] -= diffMarginX;
        bbox[1] -= diffMarginY;
        bbox[2] += 2 * diffMarginX;
        bbox[3] += 2 * diffMarginY;
        return bbox;
    }
    updateParentDimensions([width, height], scale) {
        const [oldMarginX, oldMarginY] = this.#getMarginComponents();
        this.#parentWidth = width;
        this.#parentHeight = height;
        this.#parentScale = scale;
        const [newMarginX, newMarginY] = this.#getMarginComponents();
        const diffMarginX = newMarginX - oldMarginX;
        const diffMarginY = newMarginY - oldMarginY;
        const bbox = this.#bbox;
        bbox[0] -= diffMarginX;
        bbox[1] -= diffMarginY;
        bbox[2] += 2 * diffMarginX;
        bbox[3] += 2 * diffMarginY;
        return bbox;
    }
    updateRotation(rotation) {
        this.#currentRotation = rotation;
        return {
            path: {
                transform: this.rotationTransform
            }
        };
    }
    get viewBox() {
        return this.#bbox.map(Outline.svgRound).join(" ");
    }
    get defaultProperties() {
        const [x, y] = this.#bbox;
        return {
            root: {
                viewBox: this.viewBox
            },
            path: {
                "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`
            }
        };
    }
    get rotationTransform() {
        const [, , width, height] = this.#bbox;
        let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;
        switch(this.#currentRotation){
            case 90:
                b = height / width;
                c = -width / height;
                e = width;
                break;
            case 180:
                a = -1;
                d = -1;
                e = width;
                f = height;
                break;
            case 270:
                b = -height / width;
                c = width / height;
                f = height;
                break;
            default:
                return "";
        }
        return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;
    }
    getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {
        const [marginX, marginY] = this.#getMarginComponents();
        const [x, y, width, height] = this.#bbox;
        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
            const tx = newX + newWidth / 2 - (x + width / 2);
            const ty = newY + newHeight / 2 - (y + height / 2);
            return {
                path: {
                    "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
                    transform: `${this.rotationTransform} translate(${tx} ${ty})`
                }
            };
        }
        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
        const s2x = width / newWidth;
        const s2y = height / newHeight;
        return {
            path: {
                "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,
                transform: `${this.rotationTransform} scale(${s2x} ${s2y}) ` + `translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) ` + `translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`
            }
        };
    }
    getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {
        const [marginX, marginY] = this.#getMarginComponents();
        const bbox = this.#bbox;
        const [x, y, width, height] = bbox;
        bbox[0] = newX;
        bbox[1] = newY;
        bbox[2] = newWidth;
        bbox[3] = newHeight;
        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
            const tx = newX + newWidth / 2 - (x + width / 2);
            const ty = newY + newHeight / 2 - (y + height / 2);
            for (const { line, points } of this.#lines){
                Outline._translate(line, tx, ty, line);
                Outline._translate(points, tx, ty, points);
            }
            return {
                root: {
                    viewBox: this.viewBox
                },
                path: {
                    "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
                    transform: this.rotationTransform || null,
                    d: this.toSVGPath()
                }
            };
        }
        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
        const tx = -s1x * (x + marginX) + newX + marginX;
        const ty = -s1y * (y + marginY) + newY + marginY;
        if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) for (const { line, points } of this.#lines){
            Outline._rescale(line, tx, ty, s1x, s1y, line);
            Outline._rescale(points, tx, ty, s1x, s1y, points);
        }
        return {
            root: {
                viewBox: this.viewBox
            },
            path: {
                "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
                transform: this.rotationTransform || null,
                d: this.toSVGPath()
            }
        };
    }
    getPathTranslatedSVGProperties([newX, newY], parentDimensions) {
        const [newParentWidth, newParentHeight] = parentDimensions;
        const bbox = this.#bbox;
        const tx = newX - bbox[0];
        const ty = newY - bbox[1];
        if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) for (const { line, points } of this.#lines){
            Outline._translate(line, tx, ty, line);
            Outline._translate(points, tx, ty, points);
        }
        else {
            const sx = this.#parentWidth / newParentWidth;
            const sy = this.#parentHeight / newParentHeight;
            this.#parentWidth = newParentWidth;
            this.#parentHeight = newParentHeight;
            for (const { line, points } of this.#lines){
                Outline._rescale(line, tx, ty, sx, sy, line);
                Outline._rescale(points, tx, ty, sx, sy, points);
            }
            bbox[2] *= sx;
            bbox[3] *= sy;
        }
        bbox[0] = newX;
        bbox[1] = newY;
        return {
            root: {
                viewBox: this.viewBox
            },
            path: {
                d: this.toSVGPath(),
                "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`
            }
        };
    }
    get defaultSVGProperties() {
        const bbox = this.#bbox;
        return {
            root: {
                viewBox: this.viewBox
            },
            rootClass: {
                draw: true
            },
            path: {
                d: this.toSVGPath(),
                "transform-origin": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,
                transform: this.rotationTransform || null
            },
            bbox
        };
    }
}
class InkDrawingOptions extends DrawingOptions {
    #viewParameters;
    constructor(viewerParameters){
        super();
        this.#viewParameters = viewerParameters;
        super.updateProperties({
            fill: "none",
            stroke: AnnotationEditor._defaultLineColor,
            "stroke-opacity": 1,
            "stroke-width": 1,
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-miterlimit": 10
        });
    }
    updateSVGProperty(name, value) {
        if (name === "stroke-width") {
            value ??= this["stroke-width"];
            value *= this.#viewParameters.realScale;
        }
        super.updateSVGProperty(name, value);
    }
    clone() {
        const clone = new InkDrawingOptions(this.#viewParameters);
        clone.updateAll(this);
        return clone;
    }
}
class InkEditor extends DrawingEditor {
    static _type = "ink";
    static _editorType = AnnotationEditorType.INK;
    static _defaultDrawingOptions = null;
    constructor(params){
        super({
            ...params,
            name: "inkEditor"
        });
        this._willKeepAspectRatio = true;
    }
    static initialize(l10n, uiManager) {
        AnnotationEditor.initialize(l10n, uiManager);
        this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);
    }
    static getDefaultDrawingOptions(options) {
        const clone = this._defaultDrawingOptions.clone();
        clone.updateProperties(options);
        return clone;
    }
    static get supportMultipleDrawings() {
        return true;
    }
    static get typesMap() {
        return shadow(this, "typesMap", new Map([
            [
                AnnotationEditorParamsType.INK_THICKNESS,
                "stroke-width"
            ],
            [
                AnnotationEditorParamsType.INK_COLOR,
                "stroke"
            ],
            [
                AnnotationEditorParamsType.INK_OPACITY,
                "stroke-opacity"
            ]
        ]));
    }
    static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {
        return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions["stroke-width"]);
    }
    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
    }
    static async deserialize(data, parent, uiManager) {
        let initialData = null;
        if (data instanceof InkAnnotationElement) {
            const { data: { inkLists, rect, rotation, id, color, opacity, borderStyle: { rawWidth: thickness }, popupRef }, parent: { page: { pageNumber } } } = data;
            initialData = data = {
                annotationType: AnnotationEditorType.INK,
                color: Array.from(color),
                thickness,
                opacity,
                paths: {
                    points: inkLists
                },
                boxes: null,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                id,
                deleted: false,
                popupRef
            };
        }
        const editor = await super.deserialize(data, parent, uiManager);
        editor.annotationElementId = data.id || null;
        editor._initialData = initialData;
        return editor;
    }
    onScaleChanging() {
        if (!this.parent) return;
        super.onScaleChanging();
        const { _drawId, _drawingOptions, parent } = this;
        _drawingOptions.updateSVGProperty("stroke-width");
        parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());
    }
    static onScaleChangingWhenDrawing() {
        const parent = this._currentParent;
        if (!parent) return;
        super.onScaleChangingWhenDrawing();
        this._defaultDrawingOptions.updateSVGProperty("stroke-width");
        parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
    }
    createDrawingOptions({ color, thickness, opacity }) {
        this._drawingOptions = InkEditor.getDefaultDrawingOptions({
            stroke: Util.makeHexColor(...color),
            "stroke-width": thickness,
            "stroke-opacity": opacity
        });
    }
    serialize(isForCopying = false) {
        if (this.isEmpty()) return null;
        if (this.deleted) return this.serializeDeleted();
        const { lines, points, rect } = this.serializeDraw(isForCopying);
        const { _drawingOptions: { stroke, "stroke-opacity": opacity, "stroke-width": thickness } } = this;
        const serialized = {
            annotationType: AnnotationEditorType.INK,
            color: AnnotationEditor._colorManager.convert(stroke),
            opacity,
            thickness,
            paths: {
                lines,
                points
            },
            pageIndex: this.pageIndex,
            rect,
            rotation: this.rotation,
            structTreeParentId: this._structTreeParentId
        };
        if (isForCopying) return serialized;
        if (this.annotationElementId && !this.#hasElementChanged(serialized)) return null;
        serialized.id = this.annotationElementId;
        return serialized;
    }
    #hasElementChanged(serialized) {
        const { color, thickness, opacity, pageIndex } = this._initialData;
        return this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i)=>c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;
    }
    renderAnnotationElement(annotation) {
        const { points, rect } = this.serializeDraw(false);
        annotation.updateEdited({
            rect,
            thickness: this._drawingOptions["stroke-width"],
            points
        });
        return null;
    }
}
class StampEditor extends AnnotationEditor {
    #bitmap = null;
    #bitmapId = null;
    #bitmapPromise = null;
    #bitmapUrl = null;
    #bitmapFile = null;
    #bitmapFileName = "";
    #canvas = null;
    #resizeTimeoutId = null;
    #isSvg = false;
    #hasBeenAddedInUndoStack = false;
    static _type = "stamp";
    static _editorType = AnnotationEditorType.STAMP;
    constructor(params){
        super({
            ...params,
            name: "stampEditor"
        });
        this.#bitmapUrl = params.bitmapUrl;
        this.#bitmapFile = params.bitmapFile;
    }
    static initialize(l10n, uiManager) {
        AnnotationEditor.initialize(l10n, uiManager);
    }
    static get supportedTypes() {
        const types = [
            "apng",
            "avif",
            "bmp",
            "gif",
            "jpeg",
            "png",
            "svg+xml",
            "webp",
            "x-icon"
        ];
        return shadow(this, "supportedTypes", types.map((type)=>`image/${type}`));
    }
    static get supportedTypesStr() {
        return shadow(this, "supportedTypesStr", this.supportedTypes.join(","));
    }
    static isHandlingMimeForPasting(mime) {
        return this.supportedTypes.includes(mime);
    }
    static paste(item, parent) {
        parent.pasteEditor(AnnotationEditorType.STAMP, {
            bitmapFile: item.getAsFile()
        });
    }
    altTextFinish() {
        if (this._uiManager.useNewAltTextFlow) this.div.hidden = false;
        super.altTextFinish();
    }
    get telemetryFinalData() {
        return {
            type: "stamp",
            hasAltText: !!this.altTextData?.altText
        };
    }
    static computeTelemetryFinalData(data) {
        const hasAltTextStats = data.get("hasAltText");
        return {
            hasAltText: hasAltTextStats.get(true) ?? 0,
            hasNoAltText: hasAltTextStats.get(false) ?? 0
        };
    }
    #getBitmapFetched(data, fromId = false) {
        if (!data) {
            this.remove();
            return;
        }
        this.#bitmap = data.bitmap;
        if (!fromId) {
            this.#bitmapId = data.id;
            this.#isSvg = data.isSvg;
        }
        if (data.file) this.#bitmapFileName = data.file.name;
        this.#createCanvas();
    }
    #getBitmapDone() {
        this.#bitmapPromise = null;
        this._uiManager.enableWaiting(false);
        if (!this.#canvas) return;
        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {
            this._editToolbar.hide();
            this._uiManager.editAltText(this, true);
            return;
        }
        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {
            this._reportTelemetry({
                action: "pdfjs.image.image_added",
                data: {
                    alt_text_modal: false,
                    alt_text_type: "empty"
                }
            });
            try {
                this.mlGuessAltText();
            } catch  {}
        }
        this.div.focus();
    }
    async mlGuessAltText(imageData = null, updateAltTextData = true) {
        if (this.hasAltTextData()) return null;
        const { mlManager } = this._uiManager;
        if (!mlManager) throw new Error("No ML.");
        if (!await mlManager.isEnabledFor("altText")) throw new Error("ML isn't enabled for alt text.");
        const { data, width, height } = imageData || this.copyCanvas(null, null, true).imageData;
        const response = await mlManager.guess({
            name: "altText",
            request: {
                data,
                width,
                height,
                channels: data.length / (width * height)
            }
        });
        if (!response) throw new Error("No response from the AI service.");
        if (response.error) throw new Error("Error from the AI service.");
        if (response.cancel) return null;
        if (!response.output) throw new Error("No valid response from the AI service.");
        const altText = response.output;
        await this.setGuessedAltText(altText);
        if (updateAltTextData && !this.hasAltTextData()) this.altTextData = {
            alt: altText,
            decorative: false
        };
        return altText;
    }
    #getBitmap() {
        if (this.#bitmapId) {
            this._uiManager.enableWaiting(true);
            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());
            return;
        }
        if (this.#bitmapUrl) {
            const url = this.#bitmapUrl;
            this.#bitmapUrl = null;
            this._uiManager.enableWaiting(true);
            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());
            return;
        }
        if (this.#bitmapFile) {
            const file = this.#bitmapFile;
            this.#bitmapFile = null;
            this._uiManager.enableWaiting(true);
            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());
            return;
        }
        const input = document.createElement("input");
        input.type = "file";
        input.accept = StampEditor.supportedTypesStr;
        const signal = this._uiManager._signal;
        this.#bitmapPromise = new Promise((resolve)=>{
            input.addEventListener("change", async ()=>{
                if (!input.files || input.files.length === 0) this.remove();
                else {
                    this._uiManager.enableWaiting(true);
                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
                    this._reportTelemetry({
                        action: "pdfjs.image.image_selected",
                        data: {
                            alt_text_modal: this._uiManager.useNewAltTextFlow
                        }
                    });
                    this.#getBitmapFetched(data);
                }
                resolve();
            }, {
                signal
            });
            input.addEventListener("cancel", ()=>{
                this.remove();
                resolve();
            }, {
                signal
            });
        }).finally(()=>this.#getBitmapDone());
        input.click();
    }
    remove() {
        if (this.#bitmapId) {
            this.#bitmap = null;
            this._uiManager.imageManager.deleteId(this.#bitmapId);
            this.#canvas?.remove();
            this.#canvas = null;
            if (this.#resizeTimeoutId) {
                clearTimeout(this.#resizeTimeoutId);
                this.#resizeTimeoutId = null;
            }
        }
        super.remove();
    }
    rebuild() {
        if (!this.parent) {
            if (this.#bitmapId) this.#getBitmap();
            return;
        }
        super.rebuild();
        if (this.div === null) return;
        if (this.#bitmapId && this.#canvas === null) this.#getBitmap();
        if (!this.isAttachedToDOM) this.parent.add(this);
    }
    onceAdded(focus) {
        this._isDraggable = true;
        if (focus) this.div.focus();
    }
    isEmpty() {
        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId);
    }
    get isResizable() {
        return true;
    }
    render() {
        if (this.div) return this.div;
        let baseX, baseY;
        if (this.width) {
            baseX = this.x;
            baseY = this.y;
        }
        super.render();
        this.div.hidden = true;
        this.div.setAttribute("role", "figure");
        this.addAltTextButton();
        if (this.#bitmap) this.#createCanvas();
        else this.#getBitmap();
        if (this.width && !this.annotationElementId) {
            const [parentWidth, parentHeight] = this.parentDimensions;
            this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
        }
        this._uiManager.addShouldRescale(this);
        return this.div;
    }
    _onResized() {
        this.onScaleChanging();
    }
    onScaleChanging() {
        if (!this.parent) return;
        if (this.#resizeTimeoutId !== null) clearTimeout(this.#resizeTimeoutId);
        const TIME_TO_WAIT = 200;
        this.#resizeTimeoutId = setTimeout(()=>{
            this.#resizeTimeoutId = null;
            this.#drawBitmap();
        }, TIME_TO_WAIT);
    }
    #createCanvas() {
        const { div } = this;
        let { width, height } = this.#bitmap;
        const [pageWidth, pageHeight] = this.pageDimensions;
        const MAX_RATIO = 0.75;
        if (this.width) {
            width = this.width * pageWidth;
            height = this.height * pageHeight;
        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
            width *= factor;
            height *= factor;
        }
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);
        this._uiManager.enableWaiting(false);
        const canvas = this.#canvas = document.createElement("canvas");
        canvas.setAttribute("role", "img");
        this.addContainer(canvas);
        this.width = width / pageWidth;
        this.height = height / pageHeight;
        if (this._initialOptions?.isCentered) this.center();
        else this.fixAndSetPosition();
        this._initialOptions = null;
        if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) div.hidden = false;
        this.#drawBitmap();
        if (!this.#hasBeenAddedInUndoStack) {
            this.parent.addUndoableEditor(this);
            this.#hasBeenAddedInUndoStack = true;
        }
        this._reportTelemetry({
            action: "inserted_image"
        });
        if (this.#bitmapFileName) canvas.setAttribute("aria-label", this.#bitmapFileName);
    }
    copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {
        if (!maxDataDimension) maxDataDimension = 224;
        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;
        const outputScale = new OutputScale();
        let bitmap = this.#bitmap;
        let width = bitmapWidth, height = bitmapHeight;
        let canvas = null;
        if (maxPreviewDimension) {
            if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {
                const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);
                width = Math.floor(bitmapWidth * ratio);
                height = Math.floor(bitmapHeight * ratio);
            }
            canvas = document.createElement("canvas");
            const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);
            const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);
            if (!this.#isSvg) bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);
            const ctx = canvas.getContext("2d");
            ctx.filter = this._uiManager.hcmFilter;
            let white = "white", black = "#cfcfd8";
            if (this._uiManager.hcmFilter !== "none") black = "black";
            else if (window.matchMedia?.("(prefers-color-scheme: dark)").matches) {
                white = "#8f8f9d";
                black = "#42414d";
            }
            const boxDim = 15;
            const boxDimWidth = boxDim * outputScale.sx;
            const boxDimHeight = boxDim * outputScale.sy;
            const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);
            const patternCtx = pattern.getContext("2d");
            patternCtx.fillStyle = white;
            patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);
            patternCtx.fillStyle = black;
            patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);
            patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);
            ctx.fillStyle = ctx.createPattern(pattern, "repeat");
            ctx.fillRect(0, 0, scaledWidth, scaledHeight);
            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
        }
        let imageData = null;
        if (createImageData) {
            let dataWidth, dataHeight;
            if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {
                dataWidth = bitmap.width;
                dataHeight = bitmap.height;
            } else {
                bitmap = this.#bitmap;
                if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {
                    const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);
                    dataWidth = Math.floor(bitmapWidth * ratio);
                    dataHeight = Math.floor(bitmapHeight * ratio);
                    if (!this.#isSvg) bitmap = this.#scaleBitmap(dataWidth, dataHeight);
                }
            }
            const offscreen = new OffscreenCanvas(dataWidth, dataHeight);
            const offscreenCtx = offscreen.getContext("2d", {
                willReadFrequently: true
            });
            offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);
            imageData = {
                width: dataWidth,
                height: dataHeight,
                data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data
            };
        }
        return {
            canvas,
            width,
            height,
            imageData
        };
    }
    #scaleBitmap(width, height) {
        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;
        let newWidth = bitmapWidth;
        let newHeight = bitmapHeight;
        let bitmap = this.#bitmap;
        while(newWidth > 2 * width || newHeight > 2 * height){
            const prevWidth = newWidth;
            const prevHeight = newHeight;
            if (newWidth > 2 * width) newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
            if (newHeight > 2 * height) newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
            const offscreen = new OffscreenCanvas(newWidth, newHeight);
            const ctx = offscreen.getContext("2d");
            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
            bitmap = offscreen.transferToImageBitmap();
        }
        return bitmap;
    }
    #drawBitmap() {
        const [parentWidth, parentHeight] = this.parentDimensions;
        const { width, height } = this;
        const outputScale = new OutputScale();
        const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);
        const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);
        const canvas = this.#canvas;
        if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) return;
        canvas.width = scaledWidth;
        canvas.height = scaledHeight;
        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);
        const ctx = canvas.getContext("2d");
        ctx.filter = this._uiManager.hcmFilter;
        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
    }
    getImageForAltText() {
        return this.#canvas;
    }
    #serializeBitmap(toUrl) {
        if (toUrl) {
            if (this.#isSvg) {
                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);
                if (url) return url;
            }
            const canvas = document.createElement("canvas");
            ({ width: canvas.width, height: canvas.height } = this.#bitmap);
            const ctx = canvas.getContext("2d");
            ctx.drawImage(this.#bitmap, 0, 0);
            return canvas.toDataURL();
        }
        if (this.#isSvg) {
            const [pageWidth, pageHeight] = this.pageDimensions;
            const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);
            const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);
            const offscreen = new OffscreenCanvas(width, height);
            const ctx = offscreen.getContext("2d");
            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);
            return offscreen.transferToImageBitmap();
        }
        return structuredClone(this.#bitmap);
    }
    static async deserialize(data, parent, uiManager) {
        let initialData = null;
        if (data instanceof StampAnnotationElement) {
            const { data: { rect, rotation, id, structParent, popupRef }, container, parent: { page: { pageNumber } } } = data;
            const canvas = container.querySelector("canvas");
            const imageData = uiManager.imageManager.getFromCanvas(container.id, canvas);
            canvas.remove();
            const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get("aria-label") || "";
            initialData = data = {
                annotationType: AnnotationEditorType.STAMP,
                bitmapId: imageData.id,
                bitmap: imageData.bitmap,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                id,
                deleted: false,
                accessibilityData: {
                    decorative: false,
                    altText
                },
                isSvg: false,
                structParent,
                popupRef
            };
        }
        const editor = await super.deserialize(data, parent, uiManager);
        const { rect, bitmap, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;
        if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
            editor.#bitmapId = bitmapId;
            if (bitmap) editor.#bitmap = bitmap;
        } else editor.#bitmapUrl = bitmapUrl;
        editor.#isSvg = isSvg;
        const [parentWidth, parentHeight] = editor.pageDimensions;
        editor.width = (rect[2] - rect[0]) / parentWidth;
        editor.height = (rect[3] - rect[1]) / parentHeight;
        editor.annotationElementId = data.id || null;
        if (accessibilityData) editor.altTextData = accessibilityData;
        editor._initialData = initialData;
        editor.#hasBeenAddedInUndoStack = !!initialData;
        return editor;
    }
    serialize(isForCopying = false, context = null) {
        if (this.isEmpty()) return null;
        if (this.deleted) return this.serializeDeleted();
        const serialized = {
            annotationType: AnnotationEditorType.STAMP,
            bitmapId: this.#bitmapId,
            pageIndex: this.pageIndex,
            rect: this.getRect(0, 0),
            rotation: this.rotation,
            isSvg: this.#isSvg,
            structTreeParentId: this._structTreeParentId
        };
        if (isForCopying) {
            serialized.bitmapUrl = this.#serializeBitmap(true);
            serialized.accessibilityData = this.serializeAltText(true);
            return serialized;
        }
        const { decorative, altText } = this.serializeAltText(false);
        if (!decorative && altText) serialized.accessibilityData = {
            type: "Figure",
            alt: altText
        };
        if (this.annotationElementId) {
            const changes = this.#hasElementChanged(serialized);
            if (changes.isSame) return null;
            if (changes.isSameAltText) delete serialized.accessibilityData;
            else serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;
        }
        serialized.id = this.annotationElementId;
        if (context === null) return serialized;
        context.stamps ||= new Map();
        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
        if (!context.stamps.has(this.#bitmapId)) {
            context.stamps.set(this.#bitmapId, {
                area,
                serialized
            });
            serialized.bitmap = this.#serializeBitmap(false);
        } else if (this.#isSvg) {
            const prevData = context.stamps.get(this.#bitmapId);
            if (area > prevData.area) {
                prevData.area = area;
                prevData.serialized.bitmap.close();
                prevData.serialized.bitmap = this.#serializeBitmap(false);
            }
        }
        return serialized;
    }
    #hasElementChanged(serialized) {
        const { pageIndex, accessibilityData: { altText } } = this._initialData;
        const isSamePageIndex = serialized.pageIndex === pageIndex;
        const isSameAltText = (serialized.accessibilityData?.alt || "") === altText;
        return {
            isSame: !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,
            isSameAltText
        };
    }
    renderAnnotationElement(annotation) {
        annotation.updateEdited({
            rect: this.getRect(0, 0)
        });
        return null;
    }
}
class AnnotationEditorLayer {
    #accessibilityManager;
    #allowClick = false;
    #annotationLayer = null;
    #clickAC = null;
    #editorFocusTimeoutId = null;
    #editors = new Map();
    #hadPointerDown = false;
    #isDisabling = false;
    #isEnabling = false;
    #drawingAC = null;
    #focusedElement = null;
    #textLayer = null;
    #textSelectionAC = null;
    #uiManager;
    static _initialized = false;
    static #editorTypes = new Map([
        FreeTextEditor,
        InkEditor,
        StampEditor,
        HighlightEditor
    ].map((type)=>[
            type._editorType,
            type
        ]));
    constructor({ uiManager, pageIndex, div, structTreeLayer, accessibilityManager, annotationLayer, drawLayer, textLayer, viewport, l10n }){
        const editorTypes = [
            ...AnnotationEditorLayer.#editorTypes.values()
        ];
        if (!AnnotationEditorLayer._initialized) {
            AnnotationEditorLayer._initialized = true;
            for (const editorType of editorTypes)editorType.initialize(l10n, uiManager);
        }
        uiManager.registerEditorTypes(editorTypes);
        this.#uiManager = uiManager;
        this.pageIndex = pageIndex;
        this.div = div;
        this.#accessibilityManager = accessibilityManager;
        this.#annotationLayer = annotationLayer;
        this.viewport = viewport;
        this.#textLayer = textLayer;
        this.drawLayer = drawLayer;
        this._structTree = structTreeLayer;
        this.#uiManager.addLayer(this);
    }
    get isEmpty() {
        return this.#editors.size === 0;
    }
    get isInvisible() {
        return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;
    }
    updateToolbar(mode) {
        this.#uiManager.updateToolbar(mode);
    }
    updateMode(mode = this.#uiManager.getMode()) {
        this.#cleanup();
        switch(mode){
            case AnnotationEditorType.NONE:
                this.disableTextSelection();
                this.togglePointerEvents(false);
                this.toggleAnnotationLayerPointerEvents(true);
                this.disableClick();
                return;
            case AnnotationEditorType.INK:
                this.disableTextSelection();
                this.togglePointerEvents(true);
                this.enableClick();
                break;
            case AnnotationEditorType.HIGHLIGHT:
                this.enableTextSelection();
                this.togglePointerEvents(false);
                this.disableClick();
                break;
            default:
                this.disableTextSelection();
                this.togglePointerEvents(true);
                this.enableClick();
        }
        this.toggleAnnotationLayerPointerEvents(false);
        const { classList } = this.div;
        for (const editorType of AnnotationEditorLayer.#editorTypes.values())classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);
        this.div.hidden = false;
    }
    hasTextLayer(textLayer) {
        return textLayer === this.#textLayer?.div;
    }
    setEditingState(isEditing) {
        this.#uiManager.setEditingState(isEditing);
    }
    addCommands(params) {
        this.#uiManager.addCommands(params);
    }
    cleanUndoStack(type) {
        this.#uiManager.cleanUndoStack(type);
    }
    toggleDrawing(enabled = false) {
        this.div.classList.toggle("drawing", !enabled);
    }
    togglePointerEvents(enabled = false) {
        this.div.classList.toggle("disabled", !enabled);
    }
    toggleAnnotationLayerPointerEvents(enabled = false) {
        this.#annotationLayer?.div.classList.toggle("disabled", !enabled);
    }
    async enable() {
        this.#isEnabling = true;
        this.div.tabIndex = 0;
        this.togglePointerEvents(true);
        const annotationElementIds = new Set();
        for (const editor of this.#editors.values()){
            editor.enableEditing();
            editor.show(true);
            if (editor.annotationElementId) {
                this.#uiManager.removeChangedExistingAnnotation(editor);
                annotationElementIds.add(editor.annotationElementId);
            }
        }
        if (!this.#annotationLayer) {
            this.#isEnabling = false;
            return;
        }
        const editables = this.#annotationLayer.getEditableAnnotations();
        for (const editable of editables){
            editable.hide();
            if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) continue;
            if (annotationElementIds.has(editable.data.id)) continue;
            const editor = await this.deserialize(editable);
            if (!editor) continue;
            this.addOrRebuild(editor);
            editor.enableEditing();
        }
        this.#isEnabling = false;
    }
    disable() {
        this.#isDisabling = true;
        this.div.tabIndex = -1;
        this.togglePointerEvents(false);
        const changedAnnotations = new Map();
        const resetAnnotations = new Map();
        for (const editor of this.#editors.values()){
            editor.disableEditing();
            if (!editor.annotationElementId) continue;
            if (editor.serialize() !== null) {
                changedAnnotations.set(editor.annotationElementId, editor);
                continue;
            } else resetAnnotations.set(editor.annotationElementId, editor);
            this.getEditableAnnotation(editor.annotationElementId)?.show();
            editor.remove();
        }
        if (this.#annotationLayer) {
            const editables = this.#annotationLayer.getEditableAnnotations();
            for (const editable of editables){
                const { id } = editable.data;
                if (this.#uiManager.isDeletedAnnotationElement(id)) continue;
                let editor = resetAnnotations.get(id);
                if (editor) {
                    editor.resetAnnotationElement(editable);
                    editor.show(false);
                    editable.show();
                    continue;
                }
                editor = changedAnnotations.get(id);
                if (editor) {
                    this.#uiManager.addChangedExistingAnnotation(editor);
                    if (editor.renderAnnotationElement(editable)) editor.show(false);
                }
                editable.show();
            }
        }
        this.#cleanup();
        if (this.isEmpty) this.div.hidden = true;
        const { classList } = this.div;
        for (const editorType of AnnotationEditorLayer.#editorTypes.values())classList.remove(`${editorType._type}Editing`);
        this.disableTextSelection();
        this.toggleAnnotationLayerPointerEvents(true);
        this.#isDisabling = false;
    }
    getEditableAnnotation(id) {
        return this.#annotationLayer?.getEditableAnnotation(id) || null;
    }
    setActiveEditor(editor) {
        const currentActive = this.#uiManager.getActive();
        if (currentActive === editor) return;
        this.#uiManager.setActiveEditor(editor);
    }
    enableTextSelection() {
        this.div.tabIndex = -1;
        if (this.#textLayer?.div && !this.#textSelectionAC) {
            this.#textSelectionAC = new AbortController();
            const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);
            this.#textLayer.div.addEventListener("pointerdown", this.#textLayerPointerDown.bind(this), {
                signal
            });
            this.#textLayer.div.classList.add("highlighting");
        }
    }
    disableTextSelection() {
        this.div.tabIndex = 0;
        if (this.#textLayer?.div && this.#textSelectionAC) {
            this.#textSelectionAC.abort();
            this.#textSelectionAC = null;
            this.#textLayer.div.classList.remove("highlighting");
        }
    }
    #textLayerPointerDown(event) {
        this.#uiManager.unselectAll();
        const { target } = event;
        if (target === this.#textLayer.div || (target.getAttribute("role") === "img" || target.classList.contains("endOfContent")) && this.#textLayer.div.contains(target)) {
            const { isMac } = util_FeatureTest.platform;
            if (event.button !== 0 || event.ctrlKey && isMac) return;
            this.#uiManager.showAllEditors("highlight", true, true);
            this.#textLayer.div.classList.add("free");
            this.toggleDrawing();
            HighlightEditor.startHighlighting(this, this.#uiManager.direction === "ltr", {
                target: this.#textLayer.div,
                x: event.x,
                y: event.y
            });
            this.#textLayer.div.addEventListener("pointerup", ()=>{
                this.#textLayer.div.classList.remove("free");
                this.toggleDrawing(true);
            }, {
                once: true,
                signal: this.#uiManager._signal
            });
            event.preventDefault();
        }
    }
    enableClick() {
        if (this.#clickAC) return;
        this.#clickAC = new AbortController();
        const signal = this.#uiManager.combinedSignal(this.#clickAC);
        this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
            signal
        });
        const pointerup = this.pointerup.bind(this);
        this.div.addEventListener("pointerup", pointerup, {
            signal
        });
        this.div.addEventListener("pointercancel", pointerup, {
            signal
        });
    }
    disableClick() {
        this.#clickAC?.abort();
        this.#clickAC = null;
    }
    attach(editor) {
        this.#editors.set(editor.id, editor);
        const { annotationElementId } = editor;
        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) this.#uiManager.removeDeletedAnnotationElement(editor);
    }
    detach(editor) {
        this.#editors.delete(editor.id);
        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
        if (!this.#isDisabling && editor.annotationElementId) this.#uiManager.addDeletedAnnotationElement(editor);
    }
    remove(editor) {
        this.detach(editor);
        this.#uiManager.removeEditor(editor);
        editor.div.remove();
        editor.isAttachedToDOM = false;
    }
    changeParent(editor) {
        if (editor.parent === this) return;
        if (editor.parent && editor.annotationElementId) {
            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);
            AnnotationEditor.deleteAnnotationElement(editor);
            editor.annotationElementId = null;
        }
        this.attach(editor);
        editor.parent?.detach(editor);
        editor.setParent(this);
        if (editor.div && editor.isAttachedToDOM) {
            editor.div.remove();
            this.div.append(editor.div);
        }
    }
    add(editor) {
        if (editor.parent === this && editor.isAttachedToDOM) return;
        this.changeParent(editor);
        this.#uiManager.addEditor(editor);
        this.attach(editor);
        if (!editor.isAttachedToDOM) {
            const div = editor.render();
            this.div.append(div);
            editor.isAttachedToDOM = true;
        }
        editor.fixAndSetPosition();
        editor.onceAdded(!this.#isEnabling);
        this.#uiManager.addToAnnotationStorage(editor);
        editor._reportTelemetry(editor.telemetryInitialData);
    }
    moveEditorInDOM(editor) {
        if (!editor.isAttachedToDOM) return;
        const { activeElement } = document;
        if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {
            editor._focusEventsAllowed = false;
            this.#editorFocusTimeoutId = setTimeout(()=>{
                this.#editorFocusTimeoutId = null;
                if (!editor.div.contains(document.activeElement)) {
                    editor.div.addEventListener("focusin", ()=>{
                        editor._focusEventsAllowed = true;
                    }, {
                        once: true,
                        signal: this.#uiManager._signal
                    });
                    activeElement.focus();
                } else editor._focusEventsAllowed = true;
            }, 0);
        }
        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
    }
    addOrRebuild(editor) {
        if (editor.needsToBeRebuilt()) {
            editor.parent ||= this;
            editor.rebuild();
            editor.show();
        } else this.add(editor);
    }
    addUndoableEditor(editor) {
        const cmd = ()=>editor._uiManager.rebuild(editor);
        const undo = ()=>{
            editor.remove();
        };
        this.addCommands({
            cmd,
            undo,
            mustExec: false
        });
    }
    getNextId() {
        return this.#uiManager.getId();
    }
    get #currentEditorType() {
        return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());
    }
    combinedSignal(ac) {
        return this.#uiManager.combinedSignal(ac);
    }
    #createNewEditor(params) {
        const editorType = this.#currentEditorType;
        return editorType ? new editorType.prototype.constructor(params) : null;
    }
    canCreateNewEmptyEditor() {
        return this.#currentEditorType?.canCreateNewEmptyEditor();
    }
    pasteEditor(mode, params) {
        this.#uiManager.updateToolbar(mode);
        this.#uiManager.updateMode(mode);
        const { offsetX, offsetY } = this.#getCenterPoint();
        const id = this.getNextId();
        const editor = this.#createNewEditor({
            parent: this,
            id,
            x: offsetX,
            y: offsetY,
            uiManager: this.#uiManager,
            isCentered: true,
            ...params
        });
        if (editor) this.add(editor);
    }
    async deserialize(data) {
        return await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;
    }
    createAndAddNewEditor(event, isCentered, data = {}) {
        const id = this.getNextId();
        const editor = this.#createNewEditor({
            parent: this,
            id,
            x: event.offsetX,
            y: event.offsetY,
            uiManager: this.#uiManager,
            isCentered,
            ...data
        });
        if (editor) this.add(editor);
        return editor;
    }
    #getCenterPoint() {
        const { x, y, width, height } = this.div.getBoundingClientRect();
        const tlX = Math.max(0, x);
        const tlY = Math.max(0, y);
        const brX = Math.min(window.innerWidth, x + width);
        const brY = Math.min(window.innerHeight, y + height);
        const centerX = (tlX + brX) / 2 - x;
        const centerY = (tlY + brY) / 2 - y;
        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [
            centerX,
            centerY
        ] : [
            centerY,
            centerX
        ];
        return {
            offsetX,
            offsetY
        };
    }
    addNewEditor() {
        this.createAndAddNewEditor(this.#getCenterPoint(), true);
    }
    setSelected(editor) {
        this.#uiManager.setSelected(editor);
    }
    toggleSelected(editor) {
        this.#uiManager.toggleSelected(editor);
    }
    unselect(editor) {
        this.#uiManager.unselect(editor);
    }
    pointerup(event) {
        const { isMac } = util_FeatureTest.platform;
        if (event.button !== 0 || event.ctrlKey && isMac) return;
        if (event.target !== this.div) return;
        if (!this.#hadPointerDown) return;
        this.#hadPointerDown = false;
        if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) return;
        if (!this.#allowClick) {
            this.#allowClick = true;
            return;
        }
        if (this.#uiManager.getMode() === AnnotationEditorType.STAMP) {
            this.#uiManager.unselectAll();
            return;
        }
        this.createAndAddNewEditor(event, false);
    }
    pointerdown(event) {
        if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) this.enableTextSelection();
        if (this.#hadPointerDown) {
            this.#hadPointerDown = false;
            return;
        }
        const { isMac } = util_FeatureTest.platform;
        if (event.button !== 0 || event.ctrlKey && isMac) return;
        if (event.target !== this.div) return;
        this.#hadPointerDown = true;
        if (this.#currentEditorType?.isDrawer) {
            this.startDrawingSession(event);
            return;
        }
        const editor = this.#uiManager.getActive();
        this.#allowClick = !editor || editor.isEmpty();
    }
    startDrawingSession(event) {
        this.div.focus();
        if (this.#drawingAC) {
            this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);
            return;
        }
        this.#uiManager.setCurrentDrawingSession(this);
        this.#drawingAC = new AbortController();
        const signal = this.#uiManager.combinedSignal(this.#drawingAC);
        this.div.addEventListener("blur", ({ relatedTarget })=>{
            if (relatedTarget && !this.div.contains(relatedTarget)) {
                this.#focusedElement = null;
                this.commitOrRemove();
            }
        }, {
            signal
        });
        this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);
    }
    pause(on) {
        if (on) {
            const { activeElement } = document;
            if (this.div.contains(activeElement)) this.#focusedElement = activeElement;
            return;
        }
        if (this.#focusedElement) setTimeout(()=>{
            this.#focusedElement?.focus();
            this.#focusedElement = null;
        }, 0);
    }
    endDrawingSession(isAborted = false) {
        if (!this.#drawingAC) return null;
        this.#uiManager.setCurrentDrawingSession(null);
        this.#drawingAC.abort();
        this.#drawingAC = null;
        this.#focusedElement = null;
        return this.#currentEditorType.endDrawing(isAborted);
    }
    findNewParent(editor, x, y) {
        const layer = this.#uiManager.findParent(x, y);
        if (layer === null || layer === this) return false;
        layer.changeParent(editor);
        return true;
    }
    commitOrRemove() {
        if (this.#drawingAC) {
            this.endDrawingSession();
            return true;
        }
        return false;
    }
    onScaleChanging() {
        if (!this.#drawingAC) return;
        this.#currentEditorType.onScaleChangingWhenDrawing(this);
    }
    destroy() {
        this.commitOrRemove();
        if (this.#uiManager.getActive()?.parent === this) {
            this.#uiManager.commitOrRemove();
            this.#uiManager.setActiveEditor(null);
        }
        if (this.#editorFocusTimeoutId) {
            clearTimeout(this.#editorFocusTimeoutId);
            this.#editorFocusTimeoutId = null;
        }
        for (const editor of this.#editors.values()){
            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
            editor.setParent(null);
            editor.isAttachedToDOM = false;
            editor.div.remove();
        }
        this.div = null;
        this.#editors.clear();
        this.#uiManager.removeLayer(this);
    }
    #cleanup() {
        for (const editor of this.#editors.values())if (editor.isEmpty()) editor.remove();
    }
    render({ viewport }) {
        this.viewport = viewport;
        setLayerDimensions(this.div, viewport);
        for (const editor of this.#uiManager.getEditors(this.pageIndex)){
            this.add(editor);
            editor.rebuild();
        }
        this.updateMode();
    }
    update({ viewport }) {
        this.#uiManager.commitOrRemove();
        this.#cleanup();
        const oldRotation = this.viewport.rotation;
        const rotation = viewport.rotation;
        this.viewport = viewport;
        setLayerDimensions(this.div, {
            rotation
        });
        if (oldRotation !== rotation) for (const editor of this.#editors.values())editor.rotate(rotation);
    }
    get pageDimensions() {
        const { pageWidth, pageHeight } = this.viewport.rawDims;
        return [
            pageWidth,
            pageHeight
        ];
    }
    get scale() {
        return this.#uiManager.viewParameters.realScale;
    }
}
class DrawLayer {
    #parent = null;
    #id = 0;
    #mapping = new Map();
    #toUpdate = new Map();
    constructor({ pageIndex }){
        this.pageIndex = pageIndex;
    }
    setParent(parent) {
        if (!this.#parent) {
            this.#parent = parent;
            return;
        }
        if (this.#parent !== parent) {
            if (this.#mapping.size > 0) for (const root of this.#mapping.values()){
                root.remove();
                parent.append(root);
            }
            this.#parent = parent;
        }
    }
    static get _svgFactory() {
        return shadow(this, "_svgFactory", new DOMSVGFactory());
    }
    static #setBox(element, [x, y, width, height]) {
        const { style } = element;
        style.top = `${100 * y}%`;
        style.left = `${100 * x}%`;
        style.width = `${100 * width}%`;
        style.height = `${100 * height}%`;
    }
    #createSVG() {
        const svg = DrawLayer._svgFactory.create(1, 1, true);
        this.#parent.append(svg);
        svg.setAttribute("aria-hidden", true);
        return svg;
    }
    #createClipPath(defs, pathId) {
        const clipPath = DrawLayer._svgFactory.createElement("clipPath");
        defs.append(clipPath);
        const clipPathId = `clip_${pathId}`;
        clipPath.setAttribute("id", clipPathId);
        clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
        const clipPathUse = DrawLayer._svgFactory.createElement("use");
        clipPath.append(clipPathUse);
        clipPathUse.setAttribute("href", `#${pathId}`);
        clipPathUse.classList.add("clip");
        return clipPathId;
    }
    #updateProperties(element, properties) {
        for (const [key, value] of Object.entries(properties))if (value === null) element.removeAttribute(key);
        else element.setAttribute(key, value);
    }
    draw(properties, isPathUpdatable = false, hasClip = false) {
        const id = this.#id++;
        const root = this.#createSVG();
        const defs = DrawLayer._svgFactory.createElement("defs");
        root.append(defs);
        const path = DrawLayer._svgFactory.createElement("path");
        defs.append(path);
        const pathId = `path_p${this.pageIndex}_${id}`;
        path.setAttribute("id", pathId);
        path.setAttribute("vector-effect", "non-scaling-stroke");
        if (isPathUpdatable) this.#toUpdate.set(id, path);
        const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;
        const use = DrawLayer._svgFactory.createElement("use");
        root.append(use);
        use.setAttribute("href", `#${pathId}`);
        this.updateProperties(root, properties);
        this.#mapping.set(id, root);
        return {
            id,
            clipPathId: `url(#${clipPathId})`
        };
    }
    drawOutline(properties, mustRemoveSelfIntersections) {
        const id = this.#id++;
        const root = this.#createSVG();
        const defs = DrawLayer._svgFactory.createElement("defs");
        root.append(defs);
        const path = DrawLayer._svgFactory.createElement("path");
        defs.append(path);
        const pathId = `path_p${this.pageIndex}_${id}`;
        path.setAttribute("id", pathId);
        path.setAttribute("vector-effect", "non-scaling-stroke");
        let maskId;
        if (mustRemoveSelfIntersections) {
            const mask = DrawLayer._svgFactory.createElement("mask");
            defs.append(mask);
            maskId = `mask_p${this.pageIndex}_${id}`;
            mask.setAttribute("id", maskId);
            mask.setAttribute("maskUnits", "objectBoundingBox");
            const rect = DrawLayer._svgFactory.createElement("rect");
            mask.append(rect);
            rect.setAttribute("width", "1");
            rect.setAttribute("height", "1");
            rect.setAttribute("fill", "white");
            const use = DrawLayer._svgFactory.createElement("use");
            mask.append(use);
            use.setAttribute("href", `#${pathId}`);
            use.setAttribute("stroke", "none");
            use.setAttribute("fill", "black");
            use.setAttribute("fill-rule", "nonzero");
            use.classList.add("mask");
        }
        const use1 = DrawLayer._svgFactory.createElement("use");
        root.append(use1);
        use1.setAttribute("href", `#${pathId}`);
        if (maskId) use1.setAttribute("mask", `url(#${maskId})`);
        const use2 = use1.cloneNode();
        root.append(use2);
        use1.classList.add("mainOutline");
        use2.classList.add("secondaryOutline");
        this.updateProperties(root, properties);
        this.#mapping.set(id, root);
        return id;
    }
    finalizeDraw(id, properties) {
        this.#toUpdate.delete(id);
        this.updateProperties(id, properties);
    }
    updateProperties(elementOrId, properties) {
        if (!properties) return;
        const { root, bbox, rootClass, path } = properties;
        const element = typeof elementOrId === "number" ? this.#mapping.get(elementOrId) : elementOrId;
        if (!element) return;
        if (root) this.#updateProperties(element, root);
        if (bbox) DrawLayer.#setBox(element, bbox);
        if (rootClass) {
            const { classList } = element;
            for (const [className, value] of Object.entries(rootClass))classList.toggle(className, value);
        }
        if (path) {
            const defs = element.firstChild;
            const pathElement = defs.firstChild;
            this.#updateProperties(pathElement, path);
        }
    }
    updateParent(id, layer) {
        if (layer === this) return;
        const root = this.#mapping.get(id);
        if (!root) return;
        layer.#parent.append(root);
        this.#mapping.delete(id);
        layer.#mapping.set(id, root);
    }
    remove(id) {
        this.#toUpdate.delete(id);
        if (this.#parent === null) return;
        this.#mapping.get(id).remove();
        this.#mapping.delete(id);
    }
    destroy() {
        this.#parent = null;
        for (const root of this.#mapping.values())root.remove();
        this.#mapping.clear();
        this.#toUpdate.clear();
    }
}
const pdfjsVersion = "4.10.38";
const pdfjsBuild = "f9bea397f";
globalThis.pdfjsTestingUtils = {
    HighlightOutliner: HighlightOutliner
};
var __webpack_exports__AbortException = __webpack_exports__.AbortException;
var __webpack_exports__AnnotationEditorLayer = __webpack_exports__.AnnotationEditorLayer;
var __webpack_exports__AnnotationEditorParamsType = __webpack_exports__.AnnotationEditorParamsType;
var __webpack_exports__AnnotationEditorType = __webpack_exports__.AnnotationEditorType;
var __webpack_exports__AnnotationEditorUIManager = __webpack_exports__.AnnotationEditorUIManager;
var __webpack_exports__AnnotationLayer = __webpack_exports__.AnnotationLayer;
var __webpack_exports__AnnotationMode = __webpack_exports__.AnnotationMode;
var __webpack_exports__ColorPicker = __webpack_exports__.ColorPicker;
var __webpack_exports__DOMSVGFactory = __webpack_exports__.DOMSVGFactory;
var __webpack_exports__DrawLayer = __webpack_exports__.DrawLayer;
var __webpack_exports__FeatureTest = __webpack_exports__.FeatureTest;
var __webpack_exports__GlobalWorkerOptions = __webpack_exports__.GlobalWorkerOptions;
var __webpack_exports__ImageKind = __webpack_exports__.ImageKind;
var __webpack_exports__InvalidPDFException = __webpack_exports__.InvalidPDFException;
var __webpack_exports__MissingPDFException = __webpack_exports__.MissingPDFException;
var __webpack_exports__OPS = __webpack_exports__.OPS;
var __webpack_exports__OutputScale = __webpack_exports__.OutputScale;
var __webpack_exports__PDFDataRangeTransport = __webpack_exports__.PDFDataRangeTransport;
var __webpack_exports__PDFDateString = __webpack_exports__.PDFDateString;
var __webpack_exports__PDFWorker = __webpack_exports__.PDFWorker;
var __webpack_exports__PasswordResponses = __webpack_exports__.PasswordResponses;
var __webpack_exports__PermissionFlag = __webpack_exports__.PermissionFlag;
var __webpack_exports__PixelsPerInch = __webpack_exports__.PixelsPerInch;
var __webpack_exports__RenderingCancelledException = __webpack_exports__.RenderingCancelledException;
var __webpack_exports__TextLayer = __webpack_exports__.TextLayer;
var __webpack_exports__TouchManager = __webpack_exports__.TouchManager;
var __webpack_exports__UnexpectedResponseException = __webpack_exports__.UnexpectedResponseException;
var __webpack_exports__Util = __webpack_exports__.Util;
var __webpack_exports__VerbosityLevel = __webpack_exports__.VerbosityLevel;
var __webpack_exports__XfaLayer = __webpack_exports__.XfaLayer;
var __webpack_exports__build = __webpack_exports__.build;
var __webpack_exports__createValidAbsoluteUrl = __webpack_exports__.createValidAbsoluteUrl;
var __webpack_exports__fetchData = __webpack_exports__.fetchData;
var __webpack_exports__getDocument = __webpack_exports__.getDocument;
var __webpack_exports__getFilenameFromUrl = __webpack_exports__.getFilenameFromUrl;
var __webpack_exports__getPdfFilenameFromUrl = __webpack_exports__.getPdfFilenameFromUrl;
var __webpack_exports__getXfaPageViewport = __webpack_exports__.getXfaPageViewport;
var __webpack_exports__isDataScheme = __webpack_exports__.isDataScheme;
var __webpack_exports__isPdfFile = __webpack_exports__.isPdfFile;
var __webpack_exports__noContextMenu = __webpack_exports__.noContextMenu;
var __webpack_exports__normalizeUnicode = __webpack_exports__.normalizeUnicode;
var __webpack_exports__setLayerDimensions = __webpack_exports__.setLayerDimensions;
var __webpack_exports__shadow = __webpack_exports__.shadow;
var __webpack_exports__stopEvent = __webpack_exports__.stopEvent;
var __webpack_exports__version = __webpack_exports__.version;

},{"dac986d78ccfd4c4":"euskh","2c902924488e9bb7":"i2v7G","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"euskh":[function(require,module,exports,__globalThis) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"i2v7G":[function(require,module,exports,__globalThis) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
var base64 = require("936d7d40ee51556e");
var ieee754 = require("a9454e8447bbf491");
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
 ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"936d7d40ee51556e":"ljNvB","a9454e8447bbf491":"eGhdT"}],"ljNvB":[function(require,module,exports,__globalThis) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}

},{}],"eGhdT":[function(require,module,exports,__globalThis) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"fhdYz":[function(require,module,exports,__globalThis) {
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/ var Buffer = require("f7295d6075386111").Buffer;
var global = arguments[3];
var process = require("cf30dbb97a1d82ba");
!function(e) {
    module.exports = e();
}(function() {
    return (function s(a, o, h) {
        function u(r, e) {
            if (!o[r]) {
                if (!a[r]) {
                    var t = undefined;
                    if (!e && t) return t(r, !0);
                    if (l) return l(r, !0);
                    var n = new Error("Cannot find module '" + r + "'");
                    throw n.code = "MODULE_NOT_FOUND", n;
                }
                var i = o[r] = {
                    exports: {}
                };
                a[r][0].call(i.exports, function(e) {
                    var t = a[r][1][e];
                    return u(t || e);
                }, i, i.exports, s, a, o, h);
            }
            return o[r].exports;
        }
        for(var l = undefined, e = 0; e < h.length; e++)u(h[e]);
        return u;
    })({
        1: [
            function(e, t, r) {
                "use strict";
                var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                r.encode = function(e) {
                    for(var t, r, n, i, s, a, o, h = [], u = 0, l = e.length, f = l, c = "string" !== d.getTypeOf(e); u < e.length;)f = l - u, n = c ? (t = e[u++], r = u < l ? e[u++] : 0, u < l ? e[u++] : 0) : (t = e.charCodeAt(u++), r = u < l ? e.charCodeAt(u++) : 0, u < l ? e.charCodeAt(u++) : 0), i = t >> 2, s = (3 & t) << 4 | r >> 4, a = 1 < f ? (15 & r) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
                    return h.join("");
                }, r.decode = function(e) {
                    var t, r, n, i, s, a, o = 0, h = 0, u = "data:";
                    if (e.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
                    var l, f = 3 * (e = e.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
                    if (e.charAt(e.length - 1) === p.charAt(64) && f--, e.charAt(e.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
                    for(l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e.length;)t = p.indexOf(e.charAt(o++)) << 2 | (i = p.indexOf(e.charAt(o++))) >> 4, r = (15 & i) << 4 | (s = p.indexOf(e.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e.charAt(o++))), l[h++] = t, 64 !== s && (l[h++] = r), 64 !== a && (l[h++] = n);
                    return l;
                };
            },
            {
                "./support": 30,
                "./utils": 32
            }
        ],
        2: [
            function(e, t, r) {
                "use strict";
                var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
                function o(e, t, r, n, i) {
                    this.compressedSize = e, this.uncompressedSize = t, this.crc32 = r, this.compression = n, this.compressedContent = i;
                }
                o.prototype = {
                    getContentWorker: function() {
                        var e = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t = this;
                        return e.on("end", function() {
                            if (this.streamInfo.data_length !== t.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
                        }), e;
                    },
                    getCompressedWorker: function() {
                        return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
                    }
                }, o.createWorkerFrom = function(e, t, r) {
                    return e.pipe(new s).pipe(new a("uncompressedSize")).pipe(t.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression", t);
                }, t.exports = o;
            },
            {
                "./external": 6,
                "./stream/Crc32Probe": 25,
                "./stream/DataLengthProbe": 26,
                "./stream/DataWorker": 27
            }
        ],
        3: [
            function(e, t, r) {
                "use strict";
                var n = e("./stream/GenericWorker");
                r.STORE = {
                    magic: "\0\0",
                    compressWorker: function() {
                        return new n("STORE compression");
                    },
                    uncompressWorker: function() {
                        return new n("STORE decompression");
                    }
                }, r.DEFLATE = e("./flate");
            },
            {
                "./flate": 7,
                "./stream/GenericWorker": 28
            }
        ],
        4: [
            function(e, t, r) {
                "use strict";
                var n = e("./utils");
                var o = function() {
                    for(var e, t = [], r = 0; r < 256; r++){
                        e = r;
                        for(var n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                        t[r] = e;
                    }
                    return t;
                }();
                t.exports = function(e, t) {
                    return void 0 !== e && e.length ? "string" !== n.getTypeOf(e) ? function(e, t, r, n) {
                        var i = o, s = n + r;
                        e ^= -1;
                        for(var a = n; a < s; a++)e = e >>> 8 ^ i[255 & (e ^ t[a])];
                        return -1 ^ e;
                    }(0 | t, e, e.length, 0) : function(e, t, r, n) {
                        var i = o, s = n + r;
                        e ^= -1;
                        for(var a = n; a < s; a++)e = e >>> 8 ^ i[255 & (e ^ t.charCodeAt(a))];
                        return -1 ^ e;
                    }(0 | t, e, e.length, 0) : 0;
                };
            },
            {
                "./utils": 32
            }
        ],
        5: [
            function(e, t, r) {
                "use strict";
                r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
            },
            {}
        ],
        6: [
            function(e, t, r) {
                "use strict";
                var n = null;
                n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = {
                    Promise: n
                };
            },
            {
                lie: 37
            }
        ],
        7: [
            function(e, t, r) {
                "use strict";
                var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
                function h(e, t) {
                    a.call(this, "FlateWorker/" + e), this._pako = null, this._pakoAction = e, this._pakoOptions = t, this.meta = {};
                }
                r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e) {
                    this.meta = e.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e.data), !1);
                }, h.prototype.flush = function() {
                    a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], !0);
                }, h.prototype.cleanUp = function() {
                    a.prototype.cleanUp.call(this), this._pako = null;
                }, h.prototype._createPako = function() {
                    this._pako = new i[this._pakoAction]({
                        raw: !0,
                        level: this._pakoOptions.level || -1
                    });
                    var t = this;
                    this._pako.onData = function(e) {
                        t.push({
                            data: e,
                            meta: t.meta
                        });
                    };
                }, r.compressWorker = function(e) {
                    return new h("Deflate", e);
                }, r.uncompressWorker = function() {
                    return new h("Inflate", {});
                };
            },
            {
                "./stream/GenericWorker": 28,
                "./utils": 32,
                pako: 38
            }
        ],
        8: [
            function(e, t, r) {
                "use strict";
                function A(e, t) {
                    var r, n = "";
                    for(r = 0; r < t; r++)n += String.fromCharCode(255 & e), e >>>= 8;
                    return n;
                }
                function n(e, t, r, n, i, s) {
                    var a, o, h = e.file, u = e.compression, l = s !== O.utf8encode, f = I.transformTo("string", s(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = {
                        crc32: 0,
                        compressedSize: 0,
                        uncompressedSize: 0
                    };
                    t && !r || (x.crc32 = e.crc32, x.compressedSize = e.compressedSize, x.uncompressedSize = e.uncompressedSize);
                    var S = 0;
                    t && (S |= 8), l || !_ && !g || (S |= 2048);
                    var z = 0, C = 0;
                    w && (z |= 16), "UNIX" === i ? (C = 798, z |= function(e, t) {
                        var r = e;
                        return e || (r = t ? 16893 : 33204), (65535 & r) << 16;
                    }(h.unixPermissions, w)) : (C = 20, z |= function(e) {
                        return 63 & (e || 0);
                    }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
                    var E = "";
                    return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), {
                        fileRecord: R.LOCAL_FILE_HEADER + E + f + b,
                        dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n, 4) + f + b + p
                    };
                }
                var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
                function s(e, t, r, n) {
                    i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t, this.zipPlatform = r, this.encodeFileName = n, this.streamFiles = e, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
                }
                I.inherits(s, i), s.prototype.push = function(e) {
                    var t = e.meta.percent || 0, r = this.entriesCount, n = this._sources.length;
                    this.accumulate ? this.contentBuffer.push(e) : (this.bytesWritten += e.data.length, i.prototype.push.call(this, {
                        data: e.data,
                        meta: {
                            currentFile: this.currentFile,
                            percent: r ? (t + 100 * (r - n - 1)) / r : 100
                        }
                    }));
                }, s.prototype.openedSource = function(e) {
                    this.currentSourceOffset = this.bytesWritten, this.currentFile = e.file.name;
                    var t = this.streamFiles && !e.file.dir;
                    if (t) {
                        var r = n(e, t, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                        this.push({
                            data: r.fileRecord,
                            meta: {
                                percent: 0
                            }
                        });
                    } else this.accumulate = !0;
                }, s.prototype.closedSource = function(e) {
                    this.accumulate = !1;
                    var t = this.streamFiles && !e.file.dir, r = n(e, t, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                    if (this.dirRecords.push(r.dirRecord), t) this.push({
                        data: function(e) {
                            return R.DATA_DESCRIPTOR + A(e.crc32, 4) + A(e.compressedSize, 4) + A(e.uncompressedSize, 4);
                        }(e),
                        meta: {
                            percent: 100
                        }
                    });
                    else for(this.push({
                        data: r.fileRecord,
                        meta: {
                            percent: 0
                        }
                    }); this.contentBuffer.length;)this.push(this.contentBuffer.shift());
                    this.currentFile = null;
                }, s.prototype.flush = function() {
                    for(var e = this.bytesWritten, t = 0; t < this.dirRecords.length; t++)this.push({
                        data: this.dirRecords[t],
                        meta: {
                            percent: 100
                        }
                    });
                    var r = this.bytesWritten - e, n = function(e, t, r, n, i) {
                        var s = I.transformTo("string", i(n));
                        return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e, 2) + A(e, 2) + A(t, 4) + A(r, 4) + A(s.length, 2) + s;
                    }(this.dirRecords.length, r, e, this.zipComment, this.encodeFileName);
                    this.push({
                        data: n,
                        meta: {
                            percent: 100
                        }
                    });
                }, s.prototype.prepareNextSource = function() {
                    this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
                }, s.prototype.registerPrevious = function(e) {
                    this._sources.push(e);
                    var t = this;
                    return e.on("data", function(e) {
                        t.processChunk(e);
                    }), e.on("end", function() {
                        t.closedSource(t.previous.streamInfo), t._sources.length ? t.prepareNextSource() : t.end();
                    }), e.on("error", function(e) {
                        t.error(e);
                    }), this;
                }, s.prototype.resume = function() {
                    return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
                }, s.prototype.error = function(e) {
                    var t = this._sources;
                    if (!i.prototype.error.call(this, e)) return !1;
                    for(var r = 0; r < t.length; r++)try {
                        t[r].error(e);
                    } catch (e) {}
                    return !0;
                }, s.prototype.lock = function() {
                    i.prototype.lock.call(this);
                    for(var e = this._sources, t = 0; t < e.length; t++)e[t].lock();
                }, t.exports = s;
            },
            {
                "../crc32": 4,
                "../signature": 23,
                "../stream/GenericWorker": 28,
                "../utf8": 31,
                "../utils": 32
            }
        ],
        9: [
            function(e, t, r) {
                "use strict";
                var u = e("../compressions"), n = e("./ZipFileWorker");
                r.generateWorker = function(e, a, t) {
                    var o = new n(a.streamFiles, t, a.platform, a.encodeFileName), h = 0;
                    try {
                        e.forEach(function(e, t) {
                            h++;
                            var r = function(e, t) {
                                var r = e || t, n = u[r];
                                if (!n) throw new Error(r + " is not a valid compression method !");
                                return n;
                            }(t.options.compression, a.compression), n = t.options.compressionOptions || a.compressionOptions || {}, i = t.dir, s = t.date;
                            t._compressWorker(r, n).withStreamInfo("file", {
                                name: e,
                                dir: i,
                                date: s,
                                comment: t.comment || "",
                                unixPermissions: t.unixPermissions,
                                dosPermissions: t.dosPermissions
                            }).pipe(o);
                        }), o.entriesCount = h;
                    } catch (e) {
                        o.error(e);
                    }
                    return o;
                };
            },
            {
                "../compressions": 3,
                "./ZipFileWorker": 8
            }
        ],
        10: [
            function(e, t, r) {
                "use strict";
                function n() {
                    if (!(this instanceof n)) return new n;
                    if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                    this.files = Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                        var e = new n;
                        for(var t in this)"function" != typeof this[t] && (e[t] = this[t]);
                        return e;
                    };
                }
                (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e, t) {
                    return (new n).loadAsync(e, t);
                }, n.external = e("./external"), t.exports = n;
            },
            {
                "./defaults": 5,
                "./external": 6,
                "./load": 11,
                "./object": 15,
                "./support": 30
            }
        ],
        11: [
            function(e, t, r) {
                "use strict";
                var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
                function f(n) {
                    return new i.Promise(function(e, t) {
                        var r = n.decompressed.getContentWorker().pipe(new a);
                        r.on("error", function(e) {
                            t(e);
                        }).on("end", function() {
                            r.streamInfo.crc32 !== n.decompressed.crc32 ? t(new Error("Corrupted zip : CRC32 mismatch")) : e();
                        }).resume();
                    });
                }
                t.exports = function(e, o) {
                    var h = this;
                    return o = u.extend(o || {}, {
                        base64: !1,
                        checkCRC32: !1,
                        optimizedBinaryString: !1,
                        createFolders: !1,
                        decodeFileName: n.utf8decode
                    }), l.isNode && l.isStream(e) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e, !0, o.optimizedBinaryString, o.base64).then(function(e) {
                        var t = new s(o);
                        return t.load(e), t;
                    }).then(function(e) {
                        var t = [
                            i.Promise.resolve(e)
                        ], r = e.files;
                        if (o.checkCRC32) for(var n = 0; n < r.length; n++)t.push(f(r[n]));
                        return i.Promise.all(t);
                    }).then(function(e) {
                        for(var t = e.shift(), r = t.files, n = 0; n < r.length; n++){
                            var i = r[n], s = i.fileNameStr, a = u.resolve(i.fileNameStr);
                            h.file(a, i.decompressed, {
                                binary: !0,
                                optimizedBinaryString: !0,
                                date: i.date,
                                dir: i.dir,
                                comment: i.fileCommentStr.length ? i.fileCommentStr : null,
                                unixPermissions: i.unixPermissions,
                                dosPermissions: i.dosPermissions,
                                createFolders: o.createFolders
                            }), i.dir || (h.file(a).unsafeOriginalName = s);
                        }
                        return t.zipComment.length && (h.comment = t.zipComment), h;
                    });
                };
            },
            {
                "./external": 6,
                "./nodejsUtils": 14,
                "./stream/Crc32Probe": 25,
                "./utf8": 31,
                "./utils": 32,
                "./zipEntries": 33
            }
        ],
        12: [
            function(e, t, r) {
                "use strict";
                var n = e("../utils"), i = e("../stream/GenericWorker");
                function s(e, t) {
                    i.call(this, "Nodejs stream input adapter for " + e), this._upstreamEnded = !1, this._bindStream(t);
                }
                n.inherits(s, i), s.prototype._bindStream = function(e) {
                    var t = this;
                    (this._stream = e).pause(), e.on("data", function(e) {
                        t.push({
                            data: e,
                            meta: {
                                percent: 0
                            }
                        });
                    }).on("error", function(e) {
                        t.isPaused ? this.generatedError = e : t.error(e);
                    }).on("end", function() {
                        t.isPaused ? t._upstreamEnded = !0 : t.end();
                    });
                }, s.prototype.pause = function() {
                    return !!i.prototype.pause.call(this) && (this._stream.pause(), !0);
                }, s.prototype.resume = function() {
                    return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
                }, t.exports = s;
            },
            {
                "../stream/GenericWorker": 28,
                "../utils": 32
            }
        ],
        13: [
            function(e, t, r) {
                "use strict";
                var i = e("readable-stream").Readable;
                function n(e, t, r) {
                    i.call(this, t), this._helper = e;
                    var n = this;
                    e.on("data", function(e, t) {
                        n.push(e) || n._helper.pause(), r && r(t);
                    }).on("error", function(e) {
                        n.emit("error", e);
                    }).on("end", function() {
                        n.push(null);
                    });
                }
                e("../utils").inherits(n, i), n.prototype._read = function() {
                    this._helper.resume();
                }, t.exports = n;
            },
            {
                "../utils": 32,
                "readable-stream": 16
            }
        ],
        14: [
            function(e, t, r) {
                "use strict";
                t.exports = {
                    isNode: "undefined" != typeof Buffer,
                    newBufferFrom: function(e, t) {
                        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e, t);
                        if ("number" == typeof e) throw new Error('The "data" argument must not be a number');
                        return new Buffer(e, t);
                    },
                    allocBuffer: function(e) {
                        if (Buffer.alloc) return Buffer.alloc(e);
                        var t = new Buffer(e);
                        return t.fill(0), t;
                    },
                    isBuffer: function(e) {
                        return Buffer.isBuffer(e);
                    },
                    isStream: function(e) {
                        return e && "function" == typeof e.on && "function" == typeof e.pause && "function" == typeof e.resume;
                    }
                };
            },
            {}
        ],
        15: [
            function(e, t, r) {
                "use strict";
                function s(e, t, r) {
                    var n, i = u.getTypeOf(t), s = u.extend(r || {}, f);
                    s.date = s.date || new Date, null !== s.compression && (s.compression = s.compression.toUpperCase()), "string" == typeof s.unixPermissions && (s.unixPermissions = parseInt(s.unixPermissions, 8)), s.unixPermissions && 16384 & s.unixPermissions && (s.dir = !0), s.dosPermissions && 16 & s.dosPermissions && (s.dir = !0), s.dir && (e = g(e)), s.createFolders && (n = _(e)) && b.call(this, n, !0);
                    var a = "string" === i && !1 === s.binary && !1 === s.base64;
                    r && void 0 !== r.binary || (s.binary = !a), (t instanceof c && 0 === t.uncompressedSize || s.dir || !t || 0 === t.length) && (s.base64 = !1, s.binary = !0, t = "", s.compression = "STORE", i = "string");
                    var o = null;
                    o = t instanceof c || t instanceof l ? t : p.isNode && p.isStream(t) ? new m(e, t) : u.prepareContent(e, t, s.binary, s.optimizedBinaryString, s.base64);
                    var h = new d(e, o, s);
                    this.files[e] = h;
                }
                var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e) {
                    "/" === e.slice(-1) && (e = e.substring(0, e.length - 1));
                    var t = e.lastIndexOf("/");
                    return 0 < t ? e.substring(0, t) : "";
                }, g = function(e) {
                    return "/" !== e.slice(-1) && (e += "/"), e;
                }, b = function(e, t) {
                    return t = void 0 !== t ? t : f.createFolders, e = g(e), this.files[e] || s.call(this, e, null, {
                        dir: !0,
                        createFolders: t
                    }), this.files[e];
                };
                function h(e) {
                    return "[object RegExp]" === Object.prototype.toString.call(e);
                }
                var n = {
                    load: function() {
                        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                    },
                    forEach: function(e) {
                        var t, r, n;
                        for(t in this.files)n = this.files[t], (r = t.slice(this.root.length, t.length)) && t.slice(0, this.root.length) === this.root && e(r, n);
                    },
                    filter: function(r) {
                        var n = [];
                        return this.forEach(function(e, t) {
                            r(e, t) && n.push(t);
                        }), n;
                    },
                    file: function(e, t, r) {
                        if (1 !== arguments.length) return e = this.root + e, s.call(this, e, t, r), this;
                        if (h(e)) {
                            var n = e;
                            return this.filter(function(e, t) {
                                return !t.dir && n.test(e);
                            });
                        }
                        var i = this.files[this.root + e];
                        return i && !i.dir ? i : null;
                    },
                    folder: function(r) {
                        if (!r) return this;
                        if (h(r)) return this.filter(function(e, t) {
                            return t.dir && r.test(e);
                        });
                        var e = this.root + r, t = b.call(this, e), n = this.clone();
                        return n.root = t.name, n;
                    },
                    remove: function(r) {
                        r = this.root + r;
                        var e = this.files[r];
                        if (e || ("/" !== r.slice(-1) && (r += "/"), e = this.files[r]), e && !e.dir) delete this.files[r];
                        else for(var t = this.filter(function(e, t) {
                            return t.name.slice(0, r.length) === r;
                        }), n = 0; n < t.length; n++)delete this.files[t[n].name];
                        return this;
                    },
                    generate: function() {
                        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                    },
                    generateInternalStream: function(e) {
                        var t, r = {};
                        try {
                            if ((r = u.extend(e || {}, {
                                streamFiles: !1,
                                compression: "STORE",
                                compressionOptions: null,
                                type: "",
                                platform: "DOS",
                                comment: null,
                                mimeType: "application/zip",
                                encodeFileName: i.utf8encode
                            })).type = r.type.toLowerCase(), r.compression = r.compression.toUpperCase(), "binarystring" === r.type && (r.type = "string"), !r.type) throw new Error("No output type specified.");
                            u.checkSupport(r.type), "darwin" !== r.platform && "freebsd" !== r.platform && "linux" !== r.platform && "sunos" !== r.platform || (r.platform = "UNIX"), "win32" === r.platform && (r.platform = "DOS");
                            var n = r.comment || this.comment || "";
                            t = o.generateWorker(this, r, n);
                        } catch (e) {
                            (t = new l("error")).error(e);
                        }
                        return new a(t, r.type || "string", r.mimeType);
                    },
                    generateAsync: function(e, t) {
                        return this.generateInternalStream(e).accumulate(t);
                    },
                    generateNodeStream: function(e, t) {
                        return (e = e || {}).type || (e.type = "nodebuffer"), this.generateInternalStream(e).toNodejsStream(t);
                    }
                };
                t.exports = n;
            },
            {
                "./compressedObject": 2,
                "./defaults": 5,
                "./generate": 9,
                "./nodejs/NodejsStreamInputAdapter": 12,
                "./nodejsUtils": 14,
                "./stream/GenericWorker": 28,
                "./stream/StreamHelper": 29,
                "./utf8": 31,
                "./utils": 32,
                "./zipObject": 35
            }
        ],
        16: [
            function(e, t, r) {
                "use strict";
                t.exports = e("stream");
            },
            {
                stream: void 0
            }
        ],
        17: [
            function(e, t, r) {
                "use strict";
                var n = e("./DataReader");
                function i(e) {
                    n.call(this, e);
                    for(var t = 0; t < this.data.length; t++)e[t] = 255 & e[t];
                }
                e("../utils").inherits(i, n), i.prototype.byteAt = function(e) {
                    return this.data[this.zero + e];
                }, i.prototype.lastIndexOfSignature = function(e) {
                    for(var t = e.charCodeAt(0), r = e.charCodeAt(1), n = e.charCodeAt(2), i = e.charCodeAt(3), s = this.length - 4; 0 <= s; --s)if (this.data[s] === t && this.data[s + 1] === r && this.data[s + 2] === n && this.data[s + 3] === i) return s - this.zero;
                    return -1;
                }, i.prototype.readAndCheckSignature = function(e) {
                    var t = e.charCodeAt(0), r = e.charCodeAt(1), n = e.charCodeAt(2), i = e.charCodeAt(3), s = this.readData(4);
                    return t === s[0] && r === s[1] && n === s[2] && i === s[3];
                }, i.prototype.readData = function(e) {
                    if (this.checkOffset(e), 0 === e) return [];
                    var t = this.data.slice(this.zero + this.index, this.zero + this.index + e);
                    return this.index += e, t;
                }, t.exports = i;
            },
            {
                "../utils": 32,
                "./DataReader": 18
            }
        ],
        18: [
            function(e, t, r) {
                "use strict";
                var n = e("../utils");
                function i(e) {
                    this.data = e, this.length = e.length, this.index = 0, this.zero = 0;
                }
                i.prototype = {
                    checkOffset: function(e) {
                        this.checkIndex(this.index + e);
                    },
                    checkIndex: function(e) {
                        if (this.length < this.zero + e || e < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e + "). Corrupted zip ?");
                    },
                    setIndex: function(e) {
                        this.checkIndex(e), this.index = e;
                    },
                    skip: function(e) {
                        this.setIndex(this.index + e);
                    },
                    byteAt: function() {},
                    readInt: function(e) {
                        var t, r = 0;
                        for(this.checkOffset(e), t = this.index + e - 1; t >= this.index; t--)r = (r << 8) + this.byteAt(t);
                        return this.index += e, r;
                    },
                    readString: function(e) {
                        return n.transformTo("string", this.readData(e));
                    },
                    readData: function() {},
                    lastIndexOfSignature: function() {},
                    readAndCheckSignature: function() {},
                    readDate: function() {
                        var e = this.readInt(4);
                        return new Date(Date.UTC(1980 + (e >> 25 & 127), (e >> 21 & 15) - 1, e >> 16 & 31, e >> 11 & 31, e >> 5 & 63, (31 & e) << 1));
                    }
                }, t.exports = i;
            },
            {
                "../utils": 32
            }
        ],
        19: [
            function(e, t, r) {
                "use strict";
                var n = e("./Uint8ArrayReader");
                function i(e) {
                    n.call(this, e);
                }
                e("../utils").inherits(i, n), i.prototype.readData = function(e) {
                    this.checkOffset(e);
                    var t = this.data.slice(this.zero + this.index, this.zero + this.index + e);
                    return this.index += e, t;
                }, t.exports = i;
            },
            {
                "../utils": 32,
                "./Uint8ArrayReader": 21
            }
        ],
        20: [
            function(e, t, r) {
                "use strict";
                var n = e("./DataReader");
                function i(e) {
                    n.call(this, e);
                }
                e("../utils").inherits(i, n), i.prototype.byteAt = function(e) {
                    return this.data.charCodeAt(this.zero + e);
                }, i.prototype.lastIndexOfSignature = function(e) {
                    return this.data.lastIndexOf(e) - this.zero;
                }, i.prototype.readAndCheckSignature = function(e) {
                    return e === this.readData(4);
                }, i.prototype.readData = function(e) {
                    this.checkOffset(e);
                    var t = this.data.slice(this.zero + this.index, this.zero + this.index + e);
                    return this.index += e, t;
                }, t.exports = i;
            },
            {
                "../utils": 32,
                "./DataReader": 18
            }
        ],
        21: [
            function(e, t, r) {
                "use strict";
                var n = e("./ArrayReader");
                function i(e) {
                    n.call(this, e);
                }
                e("../utils").inherits(i, n), i.prototype.readData = function(e) {
                    if (this.checkOffset(e), 0 === e) return new Uint8Array(0);
                    var t = this.data.subarray(this.zero + this.index, this.zero + this.index + e);
                    return this.index += e, t;
                }, t.exports = i;
            },
            {
                "../utils": 32,
                "./ArrayReader": 17
            }
        ],
        22: [
            function(e, t, r) {
                "use strict";
                var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
                t.exports = function(e) {
                    var t = n.getTypeOf(e);
                    return n.checkSupport(t), "string" !== t || i.uint8array ? "nodebuffer" === t ? new o(e) : i.uint8array ? new h(n.transformTo("uint8array", e)) : new s(n.transformTo("array", e)) : new a(e);
                };
            },
            {
                "../support": 30,
                "../utils": 32,
                "./ArrayReader": 17,
                "./NodeBufferReader": 19,
                "./StringReader": 20,
                "./Uint8ArrayReader": 21
            }
        ],
        23: [
            function(e, t, r) {
                "use strict";
                r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\b";
            },
            {}
        ],
        24: [
            function(e, t, r) {
                "use strict";
                var n = e("./GenericWorker"), i = e("../utils");
                function s(e) {
                    n.call(this, "ConvertWorker to " + e), this.destType = e;
                }
                i.inherits(s, n), s.prototype.processChunk = function(e) {
                    this.push({
                        data: i.transformTo(this.destType, e.data),
                        meta: e.meta
                    });
                }, t.exports = s;
            },
            {
                "../utils": 32,
                "./GenericWorker": 28
            }
        ],
        25: [
            function(e, t, r) {
                "use strict";
                var n = e("./GenericWorker"), i = e("../crc32");
                function s() {
                    n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
                }
                e("../utils").inherits(s, n), s.prototype.processChunk = function(e) {
                    this.streamInfo.crc32 = i(e.data, this.streamInfo.crc32 || 0), this.push(e);
                }, t.exports = s;
            },
            {
                "../crc32": 4,
                "../utils": 32,
                "./GenericWorker": 28
            }
        ],
        26: [
            function(e, t, r) {
                "use strict";
                var n = e("../utils"), i = e("./GenericWorker");
                function s(e) {
                    i.call(this, "DataLengthProbe for " + e), this.propName = e, this.withStreamInfo(e, 0);
                }
                n.inherits(s, i), s.prototype.processChunk = function(e) {
                    if (e) {
                        var t = this.streamInfo[this.propName] || 0;
                        this.streamInfo[this.propName] = t + e.data.length;
                    }
                    i.prototype.processChunk.call(this, e);
                }, t.exports = s;
            },
            {
                "../utils": 32,
                "./GenericWorker": 28
            }
        ],
        27: [
            function(e, t, r) {
                "use strict";
                var n = e("../utils"), i = e("./GenericWorker");
                function s(e) {
                    i.call(this, "DataWorker");
                    var t = this;
                    this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, e.then(function(e) {
                        t.dataIsReady = !0, t.data = e, t.max = e && e.length || 0, t.type = n.getTypeOf(e), t.isPaused || t._tickAndRepeat();
                    }, function(e) {
                        t.error(e);
                    });
                }
                n.inherits(s, i), s.prototype.cleanUp = function() {
                    i.prototype.cleanUp.call(this), this.data = null;
                }, s.prototype.resume = function() {
                    return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, n.delay(this._tickAndRepeat, [], this)), !0);
                }, s.prototype._tickAndRepeat = function() {
                    this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
                }, s.prototype._tick = function() {
                    if (this.isPaused || this.isFinished) return !1;
                    var e = null, t = Math.min(this.max, this.index + 16384);
                    if (this.index >= this.max) return this.end();
                    switch(this.type){
                        case "string":
                            e = this.data.substring(this.index, t);
                            break;
                        case "uint8array":
                            e = this.data.subarray(this.index, t);
                            break;
                        case "array":
                        case "nodebuffer":
                            e = this.data.slice(this.index, t);
                    }
                    return this.index = t, this.push({
                        data: e,
                        meta: {
                            percent: this.max ? this.index / this.max * 100 : 0
                        }
                    });
                }, t.exports = s;
            },
            {
                "../utils": 32,
                "./GenericWorker": 28
            }
        ],
        28: [
            function(e, t, r) {
                "use strict";
                function n(e) {
                    this.name = e || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
                        data: [],
                        end: [],
                        error: []
                    }, this.previous = null;
                }
                n.prototype = {
                    push: function(e) {
                        this.emit("data", e);
                    },
                    end: function() {
                        if (this.isFinished) return !1;
                        this.flush();
                        try {
                            this.emit("end"), this.cleanUp(), this.isFinished = !0;
                        } catch (e) {
                            this.emit("error", e);
                        }
                        return !0;
                    },
                    error: function(e) {
                        return !this.isFinished && (this.isPaused ? this.generatedError = e : (this.isFinished = !0, this.emit("error", e), this.previous && this.previous.error(e), this.cleanUp()), !0);
                    },
                    on: function(e, t) {
                        return this._listeners[e].push(t), this;
                    },
                    cleanUp: function() {
                        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
                    },
                    emit: function(e, t) {
                        if (this._listeners[e]) for(var r = 0; r < this._listeners[e].length; r++)this._listeners[e][r].call(this, t);
                    },
                    pipe: function(e) {
                        return e.registerPrevious(this);
                    },
                    registerPrevious: function(e) {
                        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                        this.streamInfo = e.streamInfo, this.mergeStreamInfo(), this.previous = e;
                        var t = this;
                        return e.on("data", function(e) {
                            t.processChunk(e);
                        }), e.on("end", function() {
                            t.end();
                        }), e.on("error", function(e) {
                            t.error(e);
                        }), this;
                    },
                    pause: function() {
                        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
                    },
                    resume: function() {
                        if (!this.isPaused || this.isFinished) return !1;
                        var e = this.isPaused = !1;
                        return this.generatedError && (this.error(this.generatedError), e = !0), this.previous && this.previous.resume(), !e;
                    },
                    flush: function() {},
                    processChunk: function(e) {
                        this.push(e);
                    },
                    withStreamInfo: function(e, t) {
                        return this.extraStreamInfo[e] = t, this.mergeStreamInfo(), this;
                    },
                    mergeStreamInfo: function() {
                        for(var e in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e) && (this.streamInfo[e] = this.extraStreamInfo[e]);
                    },
                    lock: function() {
                        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                        this.isLocked = !0, this.previous && this.previous.lock();
                    },
                    toString: function() {
                        var e = "Worker " + this.name;
                        return this.previous ? this.previous + " -> " + e : e;
                    }
                }, t.exports = n;
            },
            {}
        ],
        29: [
            function(e, t, r) {
                "use strict";
                var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
                if (n.nodestream) try {
                    o = e("../nodejs/NodejsStreamOutputAdapter");
                } catch (e) {}
                function l(e, o) {
                    return new a.Promise(function(t, r) {
                        var n = [], i = e._internalType, s = e._outputType, a = e._mimeType;
                        e.on("data", function(e, t) {
                            n.push(e), o && o(t);
                        }).on("error", function(e) {
                            n = [], r(e);
                        }).on("end", function() {
                            try {
                                var e = function(e, t, r) {
                                    switch(e){
                                        case "blob":
                                            return h.newBlob(h.transformTo("arraybuffer", t), r);
                                        case "base64":
                                            return u.encode(t);
                                        default:
                                            return h.transformTo(e, t);
                                    }
                                }(s, function(e, t) {
                                    var r, n = 0, i = null, s = 0;
                                    for(r = 0; r < t.length; r++)s += t[r].length;
                                    switch(e){
                                        case "string":
                                            return t.join("");
                                        case "array":
                                            return Array.prototype.concat.apply([], t);
                                        case "uint8array":
                                            for(i = new Uint8Array(s), r = 0; r < t.length; r++)i.set(t[r], n), n += t[r].length;
                                            return i;
                                        case "nodebuffer":
                                            return Buffer.concat(t);
                                        default:
                                            throw new Error("concat : unsupported type '" + e + "'");
                                    }
                                }(i, n), a);
                                t(e);
                            } catch (e) {
                                r(e);
                            }
                            n = [];
                        }).resume();
                    });
                }
                function f(e, t, r) {
                    var n = t;
                    switch(t){
                        case "blob":
                        case "arraybuffer":
                            n = "uint8array";
                            break;
                        case "base64":
                            n = "string";
                    }
                    try {
                        this._internalType = n, this._outputType = t, this._mimeType = r, h.checkSupport(n), this._worker = e.pipe(new i(n)), e.lock();
                    } catch (e) {
                        this._worker = new s("error"), this._worker.error(e);
                    }
                }
                f.prototype = {
                    accumulate: function(e) {
                        return l(this, e);
                    },
                    on: function(e, t) {
                        var r = this;
                        return "data" === e ? this._worker.on(e, function(e) {
                            t.call(r, e.data, e.meta);
                        }) : this._worker.on(e, function() {
                            h.delay(t, arguments, r);
                        }), this;
                    },
                    resume: function() {
                        return h.delay(this._worker.resume, [], this._worker), this;
                    },
                    pause: function() {
                        return this._worker.pause(), this;
                    },
                    toNodejsStream: function(e) {
                        if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
                        return new o(this, {
                            objectMode: "nodebuffer" !== this._outputType
                        }, e);
                    }
                }, t.exports = f;
            },
            {
                "../base64": 1,
                "../external": 6,
                "../nodejs/NodejsStreamOutputAdapter": 13,
                "../support": 30,
                "../utils": 32,
                "./ConvertWorker": 24,
                "./GenericWorker": 28
            }
        ],
        30: [
            function(e, t, r) {
                "use strict";
                if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = !1;
                else {
                    var n = new ArrayBuffer(0);
                    try {
                        r.blob = 0 === new Blob([
                            n
                        ], {
                            type: "application/zip"
                        }).size;
                    } catch (e) {
                        try {
                            var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
                            i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
                        } catch (e) {
                            r.blob = !1;
                        }
                    }
                }
                try {
                    r.nodestream = !!e("readable-stream").Readable;
                } catch (e) {
                    r.nodestream = !1;
                }
            },
            {
                "readable-stream": 16
            }
        ],
        31: [
            function(e, t, s) {
                "use strict";
                for(var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
                u[254] = u[254] = 1;
                function a() {
                    n.call(this, "utf-8 decode"), this.leftOver = null;
                }
                function l() {
                    n.call(this, "utf-8 encode");
                }
                s.utf8encode = function(e) {
                    return h.nodebuffer ? r.newBufferFrom(e, "utf-8") : function(e) {
                        var t, r, n, i, s, a = e.length, o = 0;
                        for(i = 0; i < a; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
                        for(t = h.uint8array ? new Uint8Array(o) : new Array(o), i = s = 0; s < o; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), r < 128 ? t[s++] = r : (r < 2048 ? t[s++] = 192 | r >>> 6 : (r < 65536 ? t[s++] = 224 | r >>> 12 : (t[s++] = 240 | r >>> 18, t[s++] = 128 | r >>> 12 & 63), t[s++] = 128 | r >>> 6 & 63), t[s++] = 128 | 63 & r);
                        return t;
                    }(e);
                }, s.utf8decode = function(e) {
                    return h.nodebuffer ? o.transformTo("nodebuffer", e).toString("utf-8") : function(e) {
                        var t, r, n, i, s = e.length, a = new Array(2 * s);
                        for(t = r = 0; t < s;)if ((n = e[t++]) < 128) a[r++] = n;
                        else if (4 < (i = u[n])) a[r++] = 65533, t += i - 1;
                        else {
                            for(n &= 2 === i ? 31 : 3 === i ? 15 : 7; 1 < i && t < s;)n = n << 6 | 63 & e[t++], i--;
                            1 < i ? a[r++] = 65533 : n < 65536 ? a[r++] = n : (n -= 65536, a[r++] = 55296 | n >> 10 & 1023, a[r++] = 56320 | 1023 & n);
                        }
                        return a.length !== r && (a.subarray ? a = a.subarray(0, r) : a.length = r), o.applyFromCharCode(a);
                    }(e = o.transformTo(h.uint8array ? "uint8array" : "array", e));
                }, o.inherits(a, n), a.prototype.processChunk = function(e) {
                    var t = o.transformTo(h.uint8array ? "uint8array" : "array", e.data);
                    if (this.leftOver && this.leftOver.length) {
                        if (h.uint8array) {
                            var r = t;
                            (t = new Uint8Array(r.length + this.leftOver.length)).set(this.leftOver, 0), t.set(r, this.leftOver.length);
                        } else t = this.leftOver.concat(t);
                        this.leftOver = null;
                    }
                    var n = function(e, t) {
                        var r;
                        for((t = t || e.length) > e.length && (t = e.length), r = t - 1; 0 <= r && 128 == (192 & e[r]);)r--;
                        return r < 0 ? t : 0 === r ? t : r + u[e[r]] > t ? r : t;
                    }(t), i = t;
                    n !== t.length && (h.uint8array ? (i = t.subarray(0, n), this.leftOver = t.subarray(n, t.length)) : (i = t.slice(0, n), this.leftOver = t.slice(n, t.length))), this.push({
                        data: s.utf8decode(i),
                        meta: e.meta
                    });
                }, a.prototype.flush = function() {
                    this.leftOver && this.leftOver.length && (this.push({
                        data: s.utf8decode(this.leftOver),
                        meta: {}
                    }), this.leftOver = null);
                }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e) {
                    this.push({
                        data: s.utf8encode(e.data),
                        meta: e.meta
                    });
                }, s.Utf8EncodeWorker = l;
            },
            {
                "./nodejsUtils": 14,
                "./stream/GenericWorker": 28,
                "./support": 30,
                "./utils": 32
            }
        ],
        32: [
            function(e, t, a) {
                "use strict";
                var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
                function n(e) {
                    return e;
                }
                function l(e, t) {
                    for(var r = 0; r < e.length; ++r)t[r] = 255 & e.charCodeAt(r);
                    return t;
                }
                e("setimmediate"), a.newBlob = function(t, r) {
                    a.checkSupport("blob");
                    try {
                        return new Blob([
                            t
                        ], {
                            type: r
                        });
                    } catch (e) {
                        try {
                            var n = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
                            return n.append(t), n.getBlob(r);
                        } catch (e) {
                            throw new Error("Bug : can't construct the Blob.");
                        }
                    }
                };
                var i = {
                    stringifyByChunk: function(e, t, r) {
                        var n = [], i = 0, s = e.length;
                        if (s <= r) return String.fromCharCode.apply(null, e);
                        for(; i < s;)"array" === t || "nodebuffer" === t ? n.push(String.fromCharCode.apply(null, e.slice(i, Math.min(i + r, s)))) : n.push(String.fromCharCode.apply(null, e.subarray(i, Math.min(i + r, s)))), i += r;
                        return n.join("");
                    },
                    stringifyByChar: function(e) {
                        for(var t = "", r = 0; r < e.length; r++)t += String.fromCharCode(e[r]);
                        return t;
                    },
                    applyCanBeUsed: {
                        uint8array: function() {
                            try {
                                return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
                            } catch (e) {
                                return !1;
                            }
                        }(),
                        nodebuffer: function() {
                            try {
                                return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
                            } catch (e) {
                                return !1;
                            }
                        }()
                    }
                };
                function s(e) {
                    var t = 65536, r = a.getTypeOf(e), n = !0;
                    if ("uint8array" === r ? n = i.applyCanBeUsed.uint8array : "nodebuffer" === r && (n = i.applyCanBeUsed.nodebuffer), n) for(; 1 < t;)try {
                        return i.stringifyByChunk(e, r, t);
                    } catch (e) {
                        t = Math.floor(t / 2);
                    }
                    return i.stringifyByChar(e);
                }
                function f(e, t) {
                    for(var r = 0; r < e.length; r++)t[r] = e[r];
                    return t;
                }
                a.applyFromCharCode = s;
                var c = {};
                c.string = {
                    string: n,
                    array: function(e) {
                        return l(e, new Array(e.length));
                    },
                    arraybuffer: function(e) {
                        return c.string.uint8array(e).buffer;
                    },
                    uint8array: function(e) {
                        return l(e, new Uint8Array(e.length));
                    },
                    nodebuffer: function(e) {
                        return l(e, r.allocBuffer(e.length));
                    }
                }, c.array = {
                    string: s,
                    array: n,
                    arraybuffer: function(e) {
                        return new Uint8Array(e).buffer;
                    },
                    uint8array: function(e) {
                        return new Uint8Array(e);
                    },
                    nodebuffer: function(e) {
                        return r.newBufferFrom(e);
                    }
                }, c.arraybuffer = {
                    string: function(e) {
                        return s(new Uint8Array(e));
                    },
                    array: function(e) {
                        return f(new Uint8Array(e), new Array(e.byteLength));
                    },
                    arraybuffer: n,
                    uint8array: function(e) {
                        return new Uint8Array(e);
                    },
                    nodebuffer: function(e) {
                        return r.newBufferFrom(new Uint8Array(e));
                    }
                }, c.uint8array = {
                    string: s,
                    array: function(e) {
                        return f(e, new Array(e.length));
                    },
                    arraybuffer: function(e) {
                        return e.buffer;
                    },
                    uint8array: n,
                    nodebuffer: function(e) {
                        return r.newBufferFrom(e);
                    }
                }, c.nodebuffer = {
                    string: s,
                    array: function(e) {
                        return f(e, new Array(e.length));
                    },
                    arraybuffer: function(e) {
                        return c.nodebuffer.uint8array(e).buffer;
                    },
                    uint8array: function(e) {
                        return f(e, new Uint8Array(e.length));
                    },
                    nodebuffer: n
                }, a.transformTo = function(e, t) {
                    if (t = t || "", !e) return t;
                    a.checkSupport(e);
                    var r = a.getTypeOf(t);
                    return c[r][e](t);
                }, a.resolve = function(e) {
                    for(var t = e.split("/"), r = [], n = 0; n < t.length; n++){
                        var i = t[n];
                        "." === i || "" === i && 0 !== n && n !== t.length - 1 || (".." === i ? r.pop() : r.push(i));
                    }
                    return r.join("/");
                }, a.getTypeOf = function(e) {
                    return "string" == typeof e ? "string" : "[object Array]" === Object.prototype.toString.call(e) ? "array" : o.nodebuffer && r.isBuffer(e) ? "nodebuffer" : o.uint8array && e instanceof Uint8Array ? "uint8array" : o.arraybuffer && e instanceof ArrayBuffer ? "arraybuffer" : void 0;
                }, a.checkSupport = function(e) {
                    if (!o[e.toLowerCase()]) throw new Error(e + " is not supported by this platform");
                }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e) {
                    var t, r, n = "";
                    for(r = 0; r < (e || "").length; r++)n += "\\x" + ((t = e.charCodeAt(r)) < 16 ? "0" : "") + t.toString(16).toUpperCase();
                    return n;
                }, a.delay = function(e, t, r) {
                    setImmediate(function() {
                        e.apply(r || null, t || []);
                    });
                }, a.inherits = function(e, t) {
                    function r() {}
                    r.prototype = t.prototype, e.prototype = new r;
                }, a.extend = function() {
                    var e, t, r = {};
                    for(e = 0; e < arguments.length; e++)for(t in arguments[e])Object.prototype.hasOwnProperty.call(arguments[e], t) && void 0 === r[t] && (r[t] = arguments[e][t]);
                    return r;
                }, a.prepareContent = function(r, e, n, i, s) {
                    return u.Promise.resolve(e).then(function(n) {
                        return o.blob && (n instanceof Blob || -1 !== [
                            "[object File]",
                            "[object Blob]"
                        ].indexOf(Object.prototype.toString.call(n))) && "undefined" != typeof FileReader ? new u.Promise(function(t, r) {
                            var e = new FileReader;
                            e.onload = function(e) {
                                t(e.target.result);
                            }, e.onerror = function(e) {
                                r(e.target.error);
                            }, e.readAsArrayBuffer(n);
                        }) : n;
                    }).then(function(e) {
                        var t = a.getTypeOf(e);
                        return t ? ("arraybuffer" === t ? e = a.transformTo("uint8array", e) : "string" === t && (s ? e = h.decode(e) : n && !0 !== i && (e = function(e) {
                            return l(e, o.uint8array ? new Uint8Array(e.length) : new Array(e.length));
                        }(e))), e) : u.Promise.reject(new Error("Can't read the data of '" + r + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
                    });
                };
            },
            {
                "./base64": 1,
                "./external": 6,
                "./nodejsUtils": 14,
                "./support": 30,
                setimmediate: 54
            }
        ],
        33: [
            function(e, t, r) {
                "use strict";
                var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
                function h(e) {
                    this.files = [], this.loadOptions = e;
                }
                h.prototype = {
                    checkSignature: function(e) {
                        if (!this.reader.readAndCheckSignature(e)) {
                            this.reader.index -= 4;
                            var t = this.reader.readString(4);
                            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t) + ", expected " + i.pretty(e) + ")");
                        }
                    },
                    isSignature: function(e, t) {
                        var r = this.reader.index;
                        this.reader.setIndex(e);
                        var n = this.reader.readString(4) === t;
                        return this.reader.setIndex(r), n;
                    },
                    readBlockEndOfCentral: function() {
                        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                        var e = this.reader.readData(this.zipCommentLength), t = o.uint8array ? "uint8array" : "array", r = i.transformTo(t, e);
                        this.zipComment = this.loadOptions.decodeFileName(r);
                    },
                    readBlockZip64EndOfCentral: function() {
                        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                        for(var e, t, r, n = this.zip64EndOfCentralSize - 44; 0 < n;)e = this.reader.readInt(2), t = this.reader.readInt(4), r = this.reader.readData(t), this.zip64ExtensibleData[e] = {
                            id: e,
                            length: t,
                            value: r
                        };
                    },
                    readBlockZip64EndOfCentralLocator: function() {
                        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
                    },
                    readLocalFiles: function() {
                        var e, t;
                        for(e = 0; e < this.files.length; e++)t = this.files[e], this.reader.setIndex(t.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t.readLocalPart(this.reader), t.handleUTF8(), t.processAttributes();
                    },
                    readCentralDir: function() {
                        var e;
                        for(this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e = new a({
                            zip64: this.zip64
                        }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e);
                        if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                    },
                    readEndOfCentral: function() {
                        var e = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
                        if (e < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
                        this.reader.setIndex(e);
                        var t = e;
                        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
                            if (this.zip64 = !0, (e = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                            if (this.reader.setIndex(e), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
                        }
                        var r = this.centralDirOffset + this.centralDirSize;
                        this.zip64 && (r += 20, r += 12 + this.zip64EndOfCentralSize);
                        var n = t - r;
                        if (0 < n) this.isSignature(t, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n);
                        else if (n < 0) throw new Error("Corrupted zip: missing " + Math.abs(n) + " bytes.");
                    },
                    prepareReader: function(e) {
                        this.reader = n(e);
                    },
                    load: function(e) {
                        this.prepareReader(e), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
                    }
                }, t.exports = h;
            },
            {
                "./reader/readerFor": 22,
                "./signature": 23,
                "./support": 30,
                "./utils": 32,
                "./zipEntry": 34
            }
        ],
        34: [
            function(e, t, r) {
                "use strict";
                var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
                function l(e, t) {
                    this.options = e, this.loadOptions = t;
                }
                l.prototype = {
                    isEncrypted: function() {
                        return 1 == (1 & this.bitFlag);
                    },
                    useUTF8: function() {
                        return 2048 == (2048 & this.bitFlag);
                    },
                    readLocalPart: function(e) {
                        var t, r;
                        if (e.skip(22), this.fileNameLength = e.readInt(2), r = e.readInt(2), this.fileName = e.readData(this.fileNameLength), e.skip(r), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                        if (null === (t = function(e) {
                            for(var t in h)if (Object.prototype.hasOwnProperty.call(h, t) && h[t].magic === e) return h[t];
                            return null;
                        }(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
                        this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t, e.readData(this.compressedSize));
                    },
                    readCentralPart: function(e) {
                        this.versionMadeBy = e.readInt(2), e.skip(2), this.bitFlag = e.readInt(2), this.compressionMethod = e.readString(2), this.date = e.readDate(), this.crc32 = e.readInt(4), this.compressedSize = e.readInt(4), this.uncompressedSize = e.readInt(4);
                        var t = e.readInt(2);
                        if (this.extraFieldsLength = e.readInt(2), this.fileCommentLength = e.readInt(2), this.diskNumberStart = e.readInt(2), this.internalFileAttributes = e.readInt(2), this.externalFileAttributes = e.readInt(4), this.localHeaderOffset = e.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
                        e.skip(t), this.readExtraFields(e), this.parseZIP64ExtraField(e), this.fileComment = e.readData(this.fileCommentLength);
                    },
                    processAttributes: function() {
                        this.unixPermissions = null, this.dosPermissions = null;
                        var e = this.versionMadeBy >> 8;
                        this.dir = !!(16 & this.externalFileAttributes), 0 == e && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = !0);
                    },
                    parseZIP64ExtraField: function() {
                        if (this.extraFields[1]) {
                            var e = n(this.extraFields[1].value);
                            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e.readInt(4));
                        }
                    },
                    readExtraFields: function(e) {
                        var t, r, n, i = e.index + this.extraFieldsLength;
                        for(this.extraFields || (this.extraFields = {}); e.index + 4 < i;)t = e.readInt(2), r = e.readInt(2), n = e.readData(r), this.extraFields[t] = {
                            id: t,
                            length: r,
                            value: n
                        };
                        e.setIndex(i);
                    },
                    handleUTF8: function() {
                        var e = u.uint8array ? "uint8array" : "array";
                        if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
                        else {
                            var t = this.findExtraFieldUnicodePath();
                            if (null !== t) this.fileNameStr = t;
                            else {
                                var r = s.transformTo(e, this.fileName);
                                this.fileNameStr = this.loadOptions.decodeFileName(r);
                            }
                            var n = this.findExtraFieldUnicodeComment();
                            if (null !== n) this.fileCommentStr = n;
                            else {
                                var i = s.transformTo(e, this.fileComment);
                                this.fileCommentStr = this.loadOptions.decodeFileName(i);
                            }
                        }
                    },
                    findExtraFieldUnicodePath: function() {
                        var e = this.extraFields[28789];
                        if (e) {
                            var t = n(e.value);
                            return 1 !== t.readInt(1) ? null : a(this.fileName) !== t.readInt(4) ? null : o.utf8decode(t.readData(e.length - 5));
                        }
                        return null;
                    },
                    findExtraFieldUnicodeComment: function() {
                        var e = this.extraFields[25461];
                        if (e) {
                            var t = n(e.value);
                            return 1 !== t.readInt(1) ? null : a(this.fileComment) !== t.readInt(4) ? null : o.utf8decode(t.readData(e.length - 5));
                        }
                        return null;
                    }
                }, t.exports = l;
            },
            {
                "./compressedObject": 2,
                "./compressions": 3,
                "./crc32": 4,
                "./reader/readerFor": 22,
                "./support": 30,
                "./utf8": 31,
                "./utils": 32
            }
        ],
        35: [
            function(e, t, r) {
                "use strict";
                function n(e, t, r) {
                    this.name = e, this.dir = r.dir, this.date = r.date, this.comment = r.comment, this.unixPermissions = r.unixPermissions, this.dosPermissions = r.dosPermissions, this._data = t, this._dataBinary = r.binary, this.options = {
                        compression: r.compression,
                        compressionOptions: r.compressionOptions
                    };
                }
                var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
                n.prototype = {
                    internalStream: function(e) {
                        var t = null, r = "string";
                        try {
                            if (!e) throw new Error("No output type specified.");
                            var n = "string" === (r = e.toLowerCase()) || "text" === r;
                            "binarystring" !== r && "text" !== r || (r = "string"), t = this._decompressWorker();
                            var i = !this._dataBinary;
                            i && !n && (t = t.pipe(new a.Utf8EncodeWorker)), !i && n && (t = t.pipe(new a.Utf8DecodeWorker));
                        } catch (e) {
                            (t = new h("error")).error(e);
                        }
                        return new s(t, r, "");
                    },
                    async: function(e, t) {
                        return this.internalStream(e).accumulate(t);
                    },
                    nodeStream: function(e, t) {
                        return this.internalStream(e || "nodebuffer").toNodejsStream(t);
                    },
                    _compressWorker: function(e, t) {
                        if (this._data instanceof o && this._data.compression.magic === e.magic) return this._data.getCompressedWorker();
                        var r = this._decompressWorker();
                        return this._dataBinary || (r = r.pipe(new a.Utf8EncodeWorker)), o.createWorkerFrom(r, e, t);
                    },
                    _decompressWorker: function() {
                        return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
                    }
                };
                for(var u = [
                    "asText",
                    "asBinary",
                    "asNodeBuffer",
                    "asUint8Array",
                    "asArrayBuffer"
                ], l = function() {
                    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                }, f = 0; f < u.length; f++)n.prototype[u[f]] = l;
                t.exports = n;
            },
            {
                "./compressedObject": 2,
                "./stream/DataWorker": 27,
                "./stream/GenericWorker": 28,
                "./stream/StreamHelper": 29,
                "./utf8": 31
            }
        ],
        36: [
            function(e, l, t) {
                (function(t) {
                    "use strict";
                    var r, n, e = t.MutationObserver || t.WebKitMutationObserver;
                    if (e) {
                        var i = 0, s = new e(u), a = t.document.createTextNode("");
                        s.observe(a, {
                            characterData: !0
                        }), r = function() {
                            a.data = i = ++i % 2;
                        };
                    } else if (t.setImmediate || void 0 === t.MessageChannel) r = "document" in t && "onreadystatechange" in t.document.createElement("script") ? function() {
                        var e = t.document.createElement("script");
                        e.onreadystatechange = function() {
                            u(), e.onreadystatechange = null, e.parentNode.removeChild(e), e = null;
                        }, t.document.documentElement.appendChild(e);
                    } : function() {
                        setTimeout(u, 0);
                    };
                    else {
                        var o = new t.MessageChannel;
                        o.port1.onmessage = u, r = function() {
                            o.port2.postMessage(0);
                        };
                    }
                    var h = [];
                    function u() {
                        var e, t;
                        n = !0;
                        for(var r = h.length; r;){
                            for(t = h, h = [], e = -1; ++e < r;)t[e]();
                            r = h.length;
                        }
                        n = !1;
                    }
                    l.exports = function(e) {
                        1 !== h.push(e) || n || r();
                    };
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
            },
            {}
        ],
        37: [
            function(e, t, r) {
                "use strict";
                var i = e("immediate");
                function u() {}
                var l = {}, s = [
                    "REJECTED"
                ], a = [
                    "FULFILLED"
                ], n = [
                    "PENDING"
                ];
                function o(e) {
                    if ("function" != typeof e) throw new TypeError("resolver must be a function");
                    this.state = n, this.queue = [], this.outcome = void 0, e !== u && d(this, e);
                }
                function h(e, t, r) {
                    this.promise = e, "function" == typeof t && (this.onFulfilled = t, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r && (this.onRejected = r, this.callRejected = this.otherCallRejected);
                }
                function f(t, r, n) {
                    i(function() {
                        var e;
                        try {
                            e = r(n);
                        } catch (e) {
                            return l.reject(t, e);
                        }
                        e === t ? l.reject(t, new TypeError("Cannot resolve promise with itself")) : l.resolve(t, e);
                    });
                }
                function c(e) {
                    var t = e && e.then;
                    if (e && ("object" == typeof e || "function" == typeof e) && "function" == typeof t) return function() {
                        t.apply(e, arguments);
                    };
                }
                function d(t, e) {
                    var r = !1;
                    function n(e) {
                        r || (r = !0, l.reject(t, e));
                    }
                    function i(e) {
                        r || (r = !0, l.resolve(t, e));
                    }
                    var s = p(function() {
                        e(i, n);
                    });
                    "error" === s.status && n(s.value);
                }
                function p(e, t) {
                    var r = {};
                    try {
                        r.value = e(t), r.status = "success";
                    } catch (e) {
                        r.status = "error", r.value = e;
                    }
                    return r;
                }
                (t.exports = o).prototype.finally = function(t) {
                    if ("function" != typeof t) return this;
                    var r = this.constructor;
                    return this.then(function(e) {
                        return r.resolve(t()).then(function() {
                            return e;
                        });
                    }, function(e) {
                        return r.resolve(t()).then(function() {
                            throw e;
                        });
                    });
                }, o.prototype.catch = function(e) {
                    return this.then(null, e);
                }, o.prototype.then = function(e, t) {
                    if ("function" != typeof e && this.state === a || "function" != typeof t && this.state === s) return this;
                    var r = new this.constructor(u);
                    this.state !== n ? f(r, this.state === a ? e : t, this.outcome) : this.queue.push(new h(r, e, t));
                    return r;
                }, h.prototype.callFulfilled = function(e) {
                    l.resolve(this.promise, e);
                }, h.prototype.otherCallFulfilled = function(e) {
                    f(this.promise, this.onFulfilled, e);
                }, h.prototype.callRejected = function(e) {
                    l.reject(this.promise, e);
                }, h.prototype.otherCallRejected = function(e) {
                    f(this.promise, this.onRejected, e);
                }, l.resolve = function(e, t) {
                    var r = p(c, t);
                    if ("error" === r.status) return l.reject(e, r.value);
                    var n = r.value;
                    if (n) d(e, n);
                    else {
                        e.state = a, e.outcome = t;
                        for(var i = -1, s = e.queue.length; ++i < s;)e.queue[i].callFulfilled(t);
                    }
                    return e;
                }, l.reject = function(e, t) {
                    e.state = s, e.outcome = t;
                    for(var r = -1, n = e.queue.length; ++r < n;)e.queue[r].callRejected(t);
                    return e;
                }, o.resolve = function(e) {
                    if (e instanceof this) return e;
                    return l.resolve(new this(u), e);
                }, o.reject = function(e) {
                    var t = new this(u);
                    return l.reject(t, e);
                }, o.all = function(e) {
                    var r = this;
                    if ("[object Array]" !== Object.prototype.toString.call(e)) return this.reject(new TypeError("must be an array"));
                    var n = e.length, i = !1;
                    if (!n) return this.resolve([]);
                    var s = new Array(n), a = 0, t = -1, o = new this(u);
                    for(; ++t < n;)h(e[t], t);
                    return o;
                    function h(e, t) {
                        r.resolve(e).then(function(e) {
                            s[t] = e, ++a !== n || i || (i = !0, l.resolve(o, s));
                        }, function(e) {
                            i || (i = !0, l.reject(o, e));
                        });
                    }
                }, o.race = function(e) {
                    var t = this;
                    if ("[object Array]" !== Object.prototype.toString.call(e)) return this.reject(new TypeError("must be an array"));
                    var r = e.length, n = !1;
                    if (!r) return this.resolve([]);
                    var i = -1, s = new this(u);
                    for(; ++i < r;)a = e[i], t.resolve(a).then(function(e) {
                        n || (n = !0, l.resolve(s, e));
                    }, function(e) {
                        n || (n = !0, l.reject(s, e));
                    });
                    var a;
                    return s;
                };
            },
            {
                immediate: 36
            }
        ],
        38: [
            function(e, t, r) {
                "use strict";
                var n = {};
                (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
            },
            {
                "./lib/deflate": 39,
                "./lib/inflate": 40,
                "./lib/utils/common": 41,
                "./lib/zlib/constants": 44
            }
        ],
        39: [
            function(e, t, r) {
                "use strict";
                var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
                function p(e) {
                    if (!(this instanceof p)) return new p(e);
                    this.options = o.assign({
                        level: f,
                        method: d,
                        chunkSize: 16384,
                        windowBits: 15,
                        memLevel: 8,
                        strategy: c,
                        to: ""
                    }, e || {});
                    var t = this.options;
                    t.raw && 0 < t.windowBits ? t.windowBits = -t.windowBits : t.gzip && 0 < t.windowBits && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new s, this.strm.avail_out = 0;
                    var r = a.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
                    if (r !== l) throw new Error(i[r]);
                    if (t.header && a.deflateSetHeader(this.strm, t.header), t.dictionary) {
                        var n;
                        if (n = "string" == typeof t.dictionary ? h.string2buf(t.dictionary) : "[object ArrayBuffer]" === u.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, (r = a.deflateSetDictionary(this.strm, n)) !== l) throw new Error(i[r]);
                        this._dict_set = !0;
                    }
                }
                function n(e, t) {
                    var r = new p(t);
                    if (r.push(e, !0), r.err) throw r.msg || i[r.err];
                    return r.result;
                }
                p.prototype.push = function(e, t) {
                    var r, n, i = this.strm, s = this.options.chunkSize;
                    if (this.ended) return !1;
                    n = t === ~~t ? t : !0 === t ? 4 : 0, "string" == typeof e ? i.input = h.string2buf(e) : "[object ArrayBuffer]" === u.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length;
                    do {
                        if (0 === i.avail_out && (i.output = new o.Buf8(s), i.next_out = 0, i.avail_out = s), 1 !== (r = a.deflate(i, n)) && r !== l) return this.onEnd(r), this.ended = !0, false;
                        0 !== i.avail_out && (0 !== i.avail_in || 4 !== n && 2 !== n) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i.output, i.next_out))) : this.onData(o.shrinkBuf(i.output, i.next_out)));
                    }while ((0 < i.avail_in || 0 === i.avail_out) && 1 !== r);
                    return 4 === n ? (r = a.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === l) : 2 !== n || (this.onEnd(l), i.avail_out = 0, true);
                }, p.prototype.onData = function(e) {
                    this.chunks.push(e);
                }, p.prototype.onEnd = function(e) {
                    e === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
                }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e, t) {
                    return (t = t || {}).raw = !0, n(e, t);
                }, r.gzip = function(e, t) {
                    return (t = t || {}).gzip = !0, n(e, t);
                };
            },
            {
                "./utils/common": 41,
                "./utils/strings": 42,
                "./zlib/deflate": 46,
                "./zlib/messages": 51,
                "./zlib/zstream": 53
            }
        ],
        40: [
            function(e, t, r) {
                "use strict";
                var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
                function a(e) {
                    if (!(this instanceof a)) return new a(e);
                    this.options = d.assign({
                        chunkSize: 16384,
                        windowBits: 0,
                        to: ""
                    }, e || {});
                    var t = this.options;
                    t.raw && 0 <= t.windowBits && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(0 <= t.windowBits && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), 15 < t.windowBits && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new i, this.strm.avail_out = 0;
                    var r = c.inflateInit2(this.strm, t.windowBits);
                    if (r !== m.Z_OK) throw new Error(n[r]);
                    this.header = new s, c.inflateGetHeader(this.strm, this.header);
                }
                function o(e, t) {
                    var r = new a(t);
                    if (r.push(e, !0), r.err) throw r.msg || n[r.err];
                    return r.result;
                }
                a.prototype.push = function(e, t) {
                    var r, n, i, s, a, o, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = !1;
                    if (this.ended) return !1;
                    n = t === ~~t ? t : !0 === t ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e ? h.input = p.binstring2buf(e) : "[object ArrayBuffer]" === _.call(e) ? h.input = new Uint8Array(e) : h.input = e, h.next_in = 0, h.avail_in = h.input.length;
                    do {
                        if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r = c.inflateSetDictionary(this.strm, o)), r === m.Z_BUF_ERROR && !0 === f && (r = m.Z_OK, f = !1), r !== m.Z_STREAM_END && r !== m.Z_OK) return this.onEnd(r), this.ended = !0, false;
                        h.next_out && (0 !== h.avail_out && r !== m.Z_STREAM_END && (0 !== h.avail_in || n !== m.Z_FINISH && n !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i = p.utf8border(h.output, h.next_out), s = h.next_out - i, a = p.buf2string(h.output, i), h.next_out = s, h.avail_out = u - s, s && d.arraySet(h.output, h.output, i, s, 0), this.onData(a)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = !0);
                    }while ((0 < h.avail_in || 0 === h.avail_out) && r !== m.Z_STREAM_END);
                    return r === m.Z_STREAM_END && (n = m.Z_FINISH), n === m.Z_FINISH ? (r = c.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === m.Z_OK) : n !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), h.avail_out = 0, true);
                }, a.prototype.onData = function(e) {
                    this.chunks.push(e);
                }, a.prototype.onEnd = function(e) {
                    e === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
                }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e, t) {
                    return (t = t || {}).raw = !0, o(e, t);
                }, r.ungzip = o;
            },
            {
                "./utils/common": 41,
                "./utils/strings": 42,
                "./zlib/constants": 44,
                "./zlib/gzheader": 47,
                "./zlib/inflate": 49,
                "./zlib/messages": 51,
                "./zlib/zstream": 53
            }
        ],
        41: [
            function(e, t, r) {
                "use strict";
                var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
                r.assign = function(e) {
                    for(var t = Array.prototype.slice.call(arguments, 1); t.length;){
                        var r = t.shift();
                        if (r) {
                            if ("object" != typeof r) throw new TypeError(r + "must be non-object");
                            for(var n in r)r.hasOwnProperty(n) && (e[n] = r[n]);
                        }
                    }
                    return e;
                }, r.shrinkBuf = function(e, t) {
                    return e.length === t ? e : e.subarray ? e.subarray(0, t) : (e.length = t, e);
                };
                var i = {
                    arraySet: function(e, t, r, n, i) {
                        if (t.subarray && e.subarray) e.set(t.subarray(r, r + n), i);
                        else for(var s = 0; s < n; s++)e[i + s] = t[r + s];
                    },
                    flattenChunks: function(e) {
                        var t, r, n, i, s, a;
                        for(t = n = 0, r = e.length; t < r; t++)n += e[t].length;
                        for(a = new Uint8Array(n), t = i = 0, r = e.length; t < r; t++)s = e[t], a.set(s, i), i += s.length;
                        return a;
                    }
                }, s = {
                    arraySet: function(e, t, r, n, i) {
                        for(var s = 0; s < n; s++)e[i + s] = t[r + s];
                    },
                    flattenChunks: function(e) {
                        return [].concat.apply([], e);
                    }
                };
                r.setTyped = function(e) {
                    e ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
                }, r.setTyped(n);
            },
            {}
        ],
        42: [
            function(e, t, r) {
                "use strict";
                var h = e("./common"), i = !0, s = !0;
                try {
                    String.fromCharCode.apply(null, [
                        0
                    ]);
                } catch (e) {
                    i = !1;
                }
                try {
                    String.fromCharCode.apply(null, new Uint8Array(1));
                } catch (e) {
                    s = !1;
                }
                for(var u = new h.Buf8(256), n = 0; n < 256; n++)u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
                function l(e, t) {
                    if (t < 65537 && (e.subarray && s || !e.subarray && i)) return String.fromCharCode.apply(null, h.shrinkBuf(e, t));
                    for(var r = "", n = 0; n < t; n++)r += String.fromCharCode(e[n]);
                    return r;
                }
                u[254] = u[254] = 1, r.string2buf = function(e) {
                    var t, r, n, i, s, a = e.length, o = 0;
                    for(i = 0; i < a; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
                    for(t = new h.Buf8(o), i = s = 0; s < o; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), r < 128 ? t[s++] = r : (r < 2048 ? t[s++] = 192 | r >>> 6 : (r < 65536 ? t[s++] = 224 | r >>> 12 : (t[s++] = 240 | r >>> 18, t[s++] = 128 | r >>> 12 & 63), t[s++] = 128 | r >>> 6 & 63), t[s++] = 128 | 63 & r);
                    return t;
                }, r.buf2binstring = function(e) {
                    return l(e, e.length);
                }, r.binstring2buf = function(e) {
                    for(var t = new h.Buf8(e.length), r = 0, n = t.length; r < n; r++)t[r] = e.charCodeAt(r);
                    return t;
                }, r.buf2string = function(e, t) {
                    var r, n, i, s, a = t || e.length, o = new Array(2 * a);
                    for(r = n = 0; r < a;)if ((i = e[r++]) < 128) o[n++] = i;
                    else if (4 < (s = u[i])) o[n++] = 65533, r += s - 1;
                    else {
                        for(i &= 2 === s ? 31 : 3 === s ? 15 : 7; 1 < s && r < a;)i = i << 6 | 63 & e[r++], s--;
                        1 < s ? o[n++] = 65533 : i < 65536 ? o[n++] = i : (i -= 65536, o[n++] = 55296 | i >> 10 & 1023, o[n++] = 56320 | 1023 & i);
                    }
                    return l(o, n);
                }, r.utf8border = function(e, t) {
                    var r;
                    for((t = t || e.length) > e.length && (t = e.length), r = t - 1; 0 <= r && 128 == (192 & e[r]);)r--;
                    return r < 0 ? t : 0 === r ? t : r + u[e[r]] > t ? r : t;
                };
            },
            {
                "./common": 41
            }
        ],
        43: [
            function(e, t, r) {
                "use strict";
                t.exports = function(e, t, r, n) {
                    for(var i = 65535 & e | 0, s = e >>> 16 & 65535 | 0, a = 0; 0 !== r;){
                        for(r -= a = 2e3 < r ? 2e3 : r; s = s + (i = i + t[n++] | 0) | 0, --a;);
                        i %= 65521, s %= 65521;
                    }
                    return i | s << 16 | 0;
                };
            },
            {}
        ],
        44: [
            function(e, t, r) {
                "use strict";
                t.exports = {
                    Z_NO_FLUSH: 0,
                    Z_PARTIAL_FLUSH: 1,
                    Z_SYNC_FLUSH: 2,
                    Z_FULL_FLUSH: 3,
                    Z_FINISH: 4,
                    Z_BLOCK: 5,
                    Z_TREES: 6,
                    Z_OK: 0,
                    Z_STREAM_END: 1,
                    Z_NEED_DICT: 2,
                    Z_ERRNO: -1,
                    Z_STREAM_ERROR: -2,
                    Z_DATA_ERROR: -3,
                    Z_BUF_ERROR: -5,
                    Z_NO_COMPRESSION: 0,
                    Z_BEST_SPEED: 1,
                    Z_BEST_COMPRESSION: 9,
                    Z_DEFAULT_COMPRESSION: -1,
                    Z_FILTERED: 1,
                    Z_HUFFMAN_ONLY: 2,
                    Z_RLE: 3,
                    Z_FIXED: 4,
                    Z_DEFAULT_STRATEGY: 0,
                    Z_BINARY: 0,
                    Z_TEXT: 1,
                    Z_UNKNOWN: 2,
                    Z_DEFLATED: 8
                };
            },
            {}
        ],
        45: [
            function(e, t, r) {
                "use strict";
                var o = function() {
                    for(var e, t = [], r = 0; r < 256; r++){
                        e = r;
                        for(var n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                        t[r] = e;
                    }
                    return t;
                }();
                t.exports = function(e, t, r, n) {
                    var i = o, s = n + r;
                    e ^= -1;
                    for(var a = n; a < s; a++)e = e >>> 8 ^ i[255 & (e ^ t[a])];
                    return -1 ^ e;
                };
            },
            {}
        ],
        46: [
            function(e, t, r) {
                "use strict";
                var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
                function R(e, t) {
                    return e.msg = n[t], t;
                }
                function T(e) {
                    return (e << 1) - (4 < e ? 9 : 0);
                }
                function D(e) {
                    for(var t = e.length; 0 <= --t;)e[t] = 0;
                }
                function F(e) {
                    var t = e.state, r = t.pending;
                    r > e.avail_out && (r = e.avail_out), 0 !== r && (c.arraySet(e.output, t.pending_buf, t.pending_out, r, e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, 0 === t.pending && (t.pending_out = 0));
                }
                function N(e, t) {
                    u._tr_flush_block(e, 0 <= e.block_start ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, F(e.strm);
                }
                function U(e, t) {
                    e.pending_buf[e.pending++] = t;
                }
                function P(e, t) {
                    e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t;
                }
                function L(e, t) {
                    var r, n, i = e.max_chain_length, s = e.strstart, a = e.prev_length, o = e.nice_match, h = e.strstart > e.w_size - z ? e.strstart - (e.w_size - z) : 0, u = e.window, l = e.w_mask, f = e.prev, c = e.strstart + S, d = u[s + a - 1], p = u[s + a];
                    e.prev_length >= e.good_match && (i >>= 2), o > e.lookahead && (o = e.lookahead);
                    do if (u[(r = t) + a] === p && u[r + a - 1] === d && u[r] === u[s] && u[++r] === u[s + 1]) {
                        s += 2, r++;
                        do ;
                        while (u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && s < c);
                        if (n = S - (c - s), s = c - S, a < n) {
                            if (e.match_start = t, o <= (a = n)) break;
                            d = u[s + a - 1], p = u[s + a];
                        }
                    }
                    while ((t = f[t & l]) > h && 0 != --i);
                    return a <= e.lookahead ? a : e.lookahead;
                }
                function j(e) {
                    var t, r, n, i, s, a, o, h, u, l, f = e.w_size;
                    do {
                        if (i = e.window_size - e.lookahead - e.strstart, e.strstart >= f + (f - z)) {
                            for(c.arraySet(e.window, e.window, f, f, 0), e.match_start -= f, e.strstart -= f, e.block_start -= f, t = r = e.hash_size; n = e.head[--t], e.head[t] = f <= n ? n - f : 0, --r;);
                            for(t = r = f; n = e.prev[--t], e.prev[t] = f <= n ? n - f : 0, --r;);
                            i += f;
                        }
                        if (0 === e.strm.avail_in) break;
                        if (a = e.strm, o = e.window, h = e.strstart + e.lookahead, u = i, l = void 0, l = a.avail_in, u < l && (l = u), r = 0 === l ? 0 : (a.avail_in -= l, c.arraySet(o, a.input, a.next_in, l, h), 1 === a.state.wrap ? a.adler = d(a.adler, o, l, h) : 2 === a.state.wrap && (a.adler = p(a.adler, o, l, h)), a.next_in += l, a.total_in += l, l), e.lookahead += r, e.lookahead + e.insert >= x) for(s = e.strstart - e.insert, e.ins_h = e.window[s], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[s + 1]) & e.hash_mask; e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[s + x - 1]) & e.hash_mask, e.prev[s & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = s, s++, e.insert--, !(e.lookahead + e.insert < x)););
                    }while (e.lookahead < z && 0 !== e.strm.avail_in);
                }
                function Z(e, t) {
                    for(var r, n;;){
                        if (e.lookahead < z) {
                            if (j(e), e.lookahead < z && t === l) return A;
                            if (0 === e.lookahead) break;
                        }
                        if (r = 0, e.lookahead >= x && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== r && e.strstart - r <= e.w_size - z && (e.match_length = L(e, r)), e.match_length >= x) {
                            if (n = u._tr_tally(e, e.strstart - e.match_start, e.match_length - x), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= x) {
                                for(e.match_length--; e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart, 0 != --e.match_length;);
                                e.strstart++;
                            } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask;
                        } else n = u._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
                        if (n && (N(e, !1), 0 === e.strm.avail_out)) return A;
                    }
                    return e.insert = e.strstart < x - 1 ? e.strstart : x - 1, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I;
                }
                function W(e, t) {
                    for(var r, n, i;;){
                        if (e.lookahead < z) {
                            if (j(e), e.lookahead < z && t === l) return A;
                            if (0 === e.lookahead) break;
                        }
                        if (r = 0, e.lookahead >= x && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = x - 1, 0 !== r && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - z && (e.match_length = L(e, r), e.match_length <= 5 && (1 === e.strategy || e.match_length === x && 4096 < e.strstart - e.match_start) && (e.match_length = x - 1)), e.prev_length >= x && e.match_length <= e.prev_length) {
                            for(i = e.strstart + e.lookahead - x, n = u._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - x), e.lookahead -= e.prev_length - 1, e.prev_length -= 2; ++e.strstart <= i && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 != --e.prev_length;);
                            if (e.match_available = 0, e.match_length = x - 1, e.strstart++, n && (N(e, !1), 0 === e.strm.avail_out)) return A;
                        } else if (e.match_available) {
                            if ((n = u._tr_tally(e, 0, e.window[e.strstart - 1])) && N(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return A;
                        } else e.match_available = 1, e.strstart++, e.lookahead--;
                    }
                    return e.match_available && (n = u._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < x - 1 ? e.strstart : x - 1, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I;
                }
                function M(e, t, r, n, i) {
                    this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = n, this.func = i;
                }
                function H() {
                    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
                }
                function G(e) {
                    var t;
                    return e && e.state ? (e.total_in = e.total_out = 0, e.data_type = i, (t = e.state).pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? C : E, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = l, u._tr_init(t), m) : R(e, _);
                }
                function K(e) {
                    var t = G(e);
                    return t === m && function(e) {
                        e.window_size = 2 * e.w_size, D(e.head), e.max_lazy_match = h[e.level].max_lazy, e.good_match = h[e.level].good_length, e.nice_match = h[e.level].nice_length, e.max_chain_length = h[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = x - 1, e.match_available = 0, e.ins_h = 0;
                    }(e.state), t;
                }
                function Y(e, t, r, n, i, s) {
                    if (!e) return _;
                    var a = 1;
                    if (t === g && (t = 6), n < 0 ? (a = 0, n = -n) : 15 < n && (a = 2, n -= 16), i < 1 || y < i || r !== v || n < 8 || 15 < n || t < 0 || 9 < t || s < 0 || b < s) return R(e, _);
                    8 === n && (n = 9);
                    var o = new H;
                    return (e.state = o).strm = e, o.wrap = a, o.gzhead = null, o.w_bits = n, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = i + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + x - 1) / x), o.window = new c.Buf8(2 * o.w_size), o.head = new c.Buf16(o.hash_size), o.prev = new c.Buf16(o.w_size), o.lit_bufsize = 1 << i + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new c.Buf8(o.pending_buf_size), o.d_buf = 1 * o.lit_bufsize, o.l_buf = 3 * o.lit_bufsize, o.level = t, o.strategy = s, o.method = r, K(e);
                }
                h = [
                    new M(0, 0, 0, 0, function(e, t) {
                        var r = 65535;
                        for(r > e.pending_buf_size - 5 && (r = e.pending_buf_size - 5);;){
                            if (e.lookahead <= 1) {
                                if (j(e), 0 === e.lookahead && t === l) return A;
                                if (0 === e.lookahead) break;
                            }
                            e.strstart += e.lookahead, e.lookahead = 0;
                            var n = e.block_start + r;
                            if ((0 === e.strstart || e.strstart >= n) && (e.lookahead = e.strstart - n, e.strstart = n, N(e, !1), 0 === e.strm.avail_out)) return A;
                            if (e.strstart - e.block_start >= e.w_size - z && (N(e, !1), 0 === e.strm.avail_out)) return A;
                        }
                        return e.insert = 0, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : (e.strstart > e.block_start && (N(e, !1), e.strm.avail_out), A);
                    }),
                    new M(4, 4, 8, 4, Z),
                    new M(4, 5, 16, 8, Z),
                    new M(4, 6, 32, 32, Z),
                    new M(4, 4, 16, 16, W),
                    new M(8, 16, 32, 32, W),
                    new M(8, 16, 128, 128, W),
                    new M(8, 32, 128, 256, W),
                    new M(32, 128, 258, 1024, W),
                    new M(32, 258, 258, 4096, W)
                ], r.deflateInit = function(e, t) {
                    return Y(e, t, v, 15, 8, 0);
                }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e, t) {
                    return e && e.state ? 2 !== e.state.wrap ? _ : (e.state.gzhead = t, m) : _;
                }, r.deflate = function(e, t) {
                    var r, n, i, s;
                    if (!e || !e.state || 5 < t || t < 0) return e ? R(e, _) : _;
                    if (n = e.state, !e.output || !e.input && 0 !== e.avail_in || 666 === n.status && t !== f) return R(e, 0 === e.avail_out ? -5 : _);
                    if (n.strm = e, r = n.last_flush, n.last_flush = t, n.status === C) {
                        if (2 === n.wrap) e.adler = 0, U(n, 31), U(n, 139), U(n, 8), n.gzhead ? (U(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), U(n, 255 & n.gzhead.time), U(n, n.gzhead.time >> 8 & 255), U(n, n.gzhead.time >> 16 & 255), U(n, n.gzhead.time >> 24 & 255), U(n, 9 === n.level ? 2 : 2 <= n.strategy || n.level < 2 ? 4 : 0), U(n, 255 & n.gzhead.os), n.gzhead.extra && n.gzhead.extra.length && (U(n, 255 & n.gzhead.extra.length), U(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (e.adler = p(e.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = 69) : (U(n, 0), U(n, 0), U(n, 0), U(n, 0), U(n, 0), U(n, 9 === n.level ? 2 : 2 <= n.strategy || n.level < 2 ? 4 : 0), U(n, 3), n.status = E);
                        else {
                            var a = v + (n.w_bits - 8 << 4) << 8;
                            a |= (2 <= n.strategy || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3) << 6, 0 !== n.strstart && (a |= 32), a += 31 - a % 31, n.status = E, P(n, a), 0 !== n.strstart && (P(n, e.adler >>> 16), P(n, 65535 & e.adler)), e.adler = 1;
                        }
                    }
                    if (69 === n.status) {
                        if (n.gzhead.extra) {
                            for(i = n.pending; n.gzindex < (65535 & n.gzhead.extra.length) && (n.pending !== n.pending_buf_size || (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), F(e), i = n.pending, n.pending !== n.pending_buf_size));)U(n, 255 & n.gzhead.extra[n.gzindex]), n.gzindex++;
                            n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), n.gzindex === n.gzhead.extra.length && (n.gzindex = 0, n.status = 73);
                        } else n.status = 73;
                    }
                    if (73 === n.status) {
                        if (n.gzhead.name) {
                            i = n.pending;
                            do {
                                if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), F(e), i = n.pending, n.pending === n.pending_buf_size)) {
                                    s = 1;
                                    break;
                                }
                                s = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0, U(n, s);
                            }while (0 !== s);
                            n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), 0 === s && (n.gzindex = 0, n.status = 91);
                        } else n.status = 91;
                    }
                    if (91 === n.status) {
                        if (n.gzhead.comment) {
                            i = n.pending;
                            do {
                                if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), F(e), i = n.pending, n.pending === n.pending_buf_size)) {
                                    s = 1;
                                    break;
                                }
                                s = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0, U(n, s);
                            }while (0 !== s);
                            n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), 0 === s && (n.status = 103);
                        } else n.status = 103;
                    }
                    if (103 === n.status && (n.gzhead.hcrc ? (n.pending + 2 > n.pending_buf_size && F(e), n.pending + 2 <= n.pending_buf_size && (U(n, 255 & e.adler), U(n, e.adler >> 8 & 255), e.adler = 0, n.status = E)) : n.status = E), 0 !== n.pending) {
                        if (F(e), 0 === e.avail_out) return n.last_flush = -1, m;
                    } else if (0 === e.avail_in && T(t) <= T(r) && t !== f) return R(e, -5);
                    if (666 === n.status && 0 !== e.avail_in) return R(e, -5);
                    if (0 !== e.avail_in || 0 !== n.lookahead || t !== l && 666 !== n.status) {
                        var o = 2 === n.strategy ? function(e, t) {
                            for(var r;;){
                                if (0 === e.lookahead && (j(e), 0 === e.lookahead)) {
                                    if (t === l) return A;
                                    break;
                                }
                                if (e.match_length = 0, r = u._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (N(e, !1), 0 === e.strm.avail_out)) return A;
                            }
                            return e.insert = 0, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I;
                        }(n, t) : 3 === n.strategy ? function(e, t) {
                            for(var r, n, i, s, a = e.window;;){
                                if (e.lookahead <= S) {
                                    if (j(e), e.lookahead <= S && t === l) return A;
                                    if (0 === e.lookahead) break;
                                }
                                if (e.match_length = 0, e.lookahead >= x && 0 < e.strstart && (n = a[i = e.strstart - 1]) === a[++i] && n === a[++i] && n === a[++i]) {
                                    s = e.strstart + S;
                                    do ;
                                    while (n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && i < s);
                                    e.match_length = S - (s - i), e.match_length > e.lookahead && (e.match_length = e.lookahead);
                                }
                                if (e.match_length >= x ? (r = u._tr_tally(e, 1, e.match_length - x), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = u._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (N(e, !1), 0 === e.strm.avail_out)) return A;
                            }
                            return e.insert = 0, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I;
                        }(n, t) : h[n.level].func(n, t);
                        if (o !== O && o !== B || (n.status = 666), o === A || o === O) return 0 === e.avail_out && (n.last_flush = -1), m;
                        if (o === I && (1 === t ? u._tr_align(n) : 5 !== t && (u._tr_stored_block(n, 0, 0, !1), 3 === t && (D(n.head), 0 === n.lookahead && (n.strstart = 0, n.block_start = 0, n.insert = 0))), F(e), 0 === e.avail_out)) return n.last_flush = -1, m;
                    }
                    return t !== f ? m : n.wrap <= 0 ? 1 : (2 === n.wrap ? (U(n, 255 & e.adler), U(n, e.adler >> 8 & 255), U(n, e.adler >> 16 & 255), U(n, e.adler >> 24 & 255), U(n, 255 & e.total_in), U(n, e.total_in >> 8 & 255), U(n, e.total_in >> 16 & 255), U(n, e.total_in >> 24 & 255)) : (P(n, e.adler >>> 16), P(n, 65535 & e.adler)), F(e), 0 < n.wrap && (n.wrap = -n.wrap), 0 !== n.pending ? m : 1);
                }, r.deflateEnd = function(e) {
                    var t;
                    return e && e.state ? (t = e.state.status) !== C && 69 !== t && 73 !== t && 91 !== t && 103 !== t && t !== E && 666 !== t ? R(e, _) : (e.state = null, t === E ? R(e, -3) : m) : _;
                }, r.deflateSetDictionary = function(e, t) {
                    var r, n, i, s, a, o, h, u, l = t.length;
                    if (!e || !e.state) return _;
                    if (2 === (s = (r = e.state).wrap) || 1 === s && r.status !== C || r.lookahead) return _;
                    for(1 === s && (e.adler = d(e.adler, t, l, 0)), r.wrap = 0, l >= r.w_size && (0 === s && (D(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0), u = new c.Buf8(r.w_size), c.arraySet(u, t, l - r.w_size, r.w_size, 0), t = u, l = r.w_size), a = e.avail_in, o = e.next_in, h = e.input, e.avail_in = l, e.next_in = 0, e.input = t, j(r); r.lookahead >= x;){
                        for(n = r.strstart, i = r.lookahead - (x - 1); r.ins_h = (r.ins_h << r.hash_shift ^ r.window[n + x - 1]) & r.hash_mask, r.prev[n & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = n, n++, --i;);
                        r.strstart = n, r.lookahead = x - 1, j(r);
                    }
                    return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = x - 1, r.match_available = 0, e.next_in = o, e.input = h, e.avail_in = a, r.wrap = s, m;
                }, r.deflateInfo = "pako deflate (from Nodeca project)";
            },
            {
                "../utils/common": 41,
                "./adler32": 43,
                "./crc32": 45,
                "./messages": 51,
                "./trees": 52
            }
        ],
        47: [
            function(e, t, r) {
                "use strict";
                t.exports = function() {
                    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
                };
            },
            {}
        ],
        48: [
            function(e, t, r) {
                "use strict";
                t.exports = function(e, t) {
                    var r, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
                    r = e.state, n = e.next_in, z = e.input, i = n + (e.avail_in - 5), s = e.next_out, C = e.output, a = s - (t - e.avail_out), o = s + (e.avail_out - 257), h = r.dmax, u = r.wsize, l = r.whave, f = r.wnext, c = r.window, d = r.hold, p = r.bits, m = r.lencode, _ = r.distcode, g = (1 << r.lenbits) - 1, b = (1 << r.distbits) - 1;
                    e: do {
                        p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
                        t: for(;;){
                            if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;
                            else {
                                if (!(16 & y)) {
                                    if (0 == (64 & y)) {
                                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                                        continue t;
                                    }
                                    if (32 & y) {
                                        r.mode = 12;
                                        break e;
                                    }
                                    e.msg = "invalid literal/length code", r.mode = 30;
                                    break e;
                                }
                                w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                                r: for(;;){
                                    if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                                        if (0 == (64 & y)) {
                                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                                            continue r;
                                        }
                                        e.msg = "invalid distance code", r.mode = 30;
                                        break e;
                                    }
                                    if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                                        e.msg = "invalid distance too far back", r.mode = 30;
                                        break e;
                                    }
                                    if (d >>>= y, p -= y, (y = s - a) < k) {
                                        if (l < (y = k - y) && r.sane) {
                                            e.msg = "invalid distance too far back", r.mode = 30;
                                            break e;
                                        }
                                        if (S = c, (x = 0) === f) {
                                            if (x += u - y, y < w) {
                                                for(w -= y; C[s++] = c[x++], --y;);
                                                x = s - k, S = C;
                                            }
                                        } else if (f < y) {
                                            if (x += u + f - y, (y -= f) < w) {
                                                for(w -= y; C[s++] = c[x++], --y;);
                                                if (x = 0, f < w) {
                                                    for(w -= y = f; C[s++] = c[x++], --y;);
                                                    x = s - k, S = C;
                                                }
                                            }
                                        } else if (x += f - y, y < w) {
                                            for(w -= y; C[s++] = c[x++], --y;);
                                            x = s - k, S = C;
                                        }
                                        for(; 2 < w;)C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                                        w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                                    } else {
                                        for(x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3););
                                        w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                                    }
                                    break;
                                }
                            }
                            break;
                        }
                    }while (n < i && s < o);
                    n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e.next_in = n, e.next_out = s, e.avail_in = n < i ? i - n + 5 : 5 - (n - i), e.avail_out = s < o ? o - s + 257 : 257 - (s - o), r.hold = d, r.bits = p;
                };
            },
            {}
        ],
        49: [
            function(e, t, r) {
                "use strict";
                var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
                function L(e) {
                    return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
                }
                function s() {
                    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
                }
                function a(e) {
                    var t;
                    return e && e.state ? (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = P, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new I.Buf32(n), t.distcode = t.distdyn = new I.Buf32(i), t.sane = 1, t.back = -1, N) : U;
                }
                function o(e) {
                    var t;
                    return e && e.state ? ((t = e.state).wsize = 0, t.whave = 0, t.wnext = 0, a(e)) : U;
                }
                function h(e, t) {
                    var r, n;
                    return e && e.state ? (n = e.state, t < 0 ? (r = 0, t = -t) : (r = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || 15 < t) ? U : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = r, n.wbits = t, o(e))) : U;
                }
                function u(e, t) {
                    var r, n;
                    return e ? (n = new s, (e.state = n).window = null, (r = h(e, t)) !== N && (e.state = null), r) : U;
                }
                var l, f, c = !0;
                function j(e) {
                    if (c) {
                        var t;
                        for(l = new I.Buf32(512), f = new I.Buf32(32), t = 0; t < 144;)e.lens[t++] = 8;
                        for(; t < 256;)e.lens[t++] = 9;
                        for(; t < 280;)e.lens[t++] = 7;
                        for(; t < 288;)e.lens[t++] = 8;
                        for(T(D, e.lens, 0, 288, l, 0, e.work, {
                            bits: 9
                        }), t = 0; t < 32;)e.lens[t++] = 5;
                        T(F, e.lens, 0, 32, f, 0, e.work, {
                            bits: 5
                        }), c = !1;
                    }
                    e.lencode = l, e.lenbits = 9, e.distcode = f, e.distbits = 5;
                }
                function Z(e, t, r, n) {
                    var i, s = e.state;
                    return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new I.Buf8(s.wsize)), n >= s.wsize ? (I.arraySet(s.window, t, r - s.wsize, s.wsize, 0), s.wnext = 0, s.whave = s.wsize) : (n < (i = s.wsize - s.wnext) && (i = n), I.arraySet(s.window, t, r - n, i, s.wnext), (n -= i) ? (I.arraySet(s.window, t, r - n, n, 0), s.wnext = n, s.whave = s.wsize) : (s.wnext += i, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += i))), 0;
                }
                r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e) {
                    return u(e, 15);
                }, r.inflateInit2 = u, r.inflate = function(e, t) {
                    var r, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [
                        16,
                        17,
                        18,
                        0,
                        8,
                        7,
                        9,
                        6,
                        10,
                        5,
                        11,
                        4,
                        12,
                        3,
                        13,
                        2,
                        14,
                        1,
                        15
                    ];
                    if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return U;
                    12 === (r = e.state).mode && (r.mode = 13), a = e.next_out, i = e.output, h = e.avail_out, s = e.next_in, n = e.input, o = e.avail_in, u = r.hold, l = r.bits, f = o, c = h, x = N;
                    e: for(;;)switch(r.mode){
                        case P:
                            if (0 === r.wrap) {
                                r.mode = 13;
                                break;
                            }
                            for(; l < 16;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if (2 & r.wrap && 35615 === u) {
                                E[r.check = 0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0), l = u = 0, r.mode = 2;
                                break;
                            }
                            if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & u) << 8) + (u >> 8)) % 31) {
                                e.msg = "incorrect header check", r.mode = 30;
                                break;
                            }
                            if (8 != (15 & u)) {
                                e.msg = "unknown compression method", r.mode = 30;
                                break;
                            }
                            if (l -= 4, k = 8 + (15 & (u >>>= 4)), 0 === r.wbits) r.wbits = k;
                            else if (k > r.wbits) {
                                e.msg = "invalid window size", r.mode = 30;
                                break;
                            }
                            r.dmax = 1 << k, e.adler = r.check = 1, r.mode = 512 & u ? 10 : 12, l = u = 0;
                            break;
                        case 2:
                            for(; l < 16;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if (r.flags = u, 8 != (255 & r.flags)) {
                                e.msg = "unknown compression method", r.mode = 30;
                                break;
                            }
                            if (57344 & r.flags) {
                                e.msg = "unknown header flags set", r.mode = 30;
                                break;
                            }
                            r.head && (r.head.text = u >> 8 & 1), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0, r.mode = 3;
                        case 3:
                            for(; l < 32;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            r.head && (r.head.time = u), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, E[2] = u >>> 16 & 255, E[3] = u >>> 24 & 255, r.check = B(r.check, E, 4, 0)), l = u = 0, r.mode = 4;
                        case 4:
                            for(; l < 16;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            r.head && (r.head.xflags = 255 & u, r.head.os = u >> 8), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0, r.mode = 5;
                        case 5:
                            if (1024 & r.flags) {
                                for(; l < 16;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                r.length = u, r.head && (r.head.extra_len = u), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0;
                            } else r.head && (r.head.extra = null);
                            r.mode = 6;
                        case 6:
                            if (1024 & r.flags && (o < (d = r.length) && (d = o), d && (r.head && (k = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), I.arraySet(r.head.extra, n, s, d, k)), 512 & r.flags && (r.check = B(r.check, n, d, s)), o -= d, s += d, r.length -= d), r.length)) break e;
                            r.length = 0, r.mode = 7;
                        case 7:
                            if (2048 & r.flags) {
                                if (0 === o) break e;
                                for(d = 0; k = n[s + d++], r.head && k && r.length < 65536 && (r.head.name += String.fromCharCode(k)), k && d < o;);
                                if (512 & r.flags && (r.check = B(r.check, n, d, s)), o -= d, s += d, k) break e;
                            } else r.head && (r.head.name = null);
                            r.length = 0, r.mode = 8;
                        case 8:
                            if (4096 & r.flags) {
                                if (0 === o) break e;
                                for(d = 0; k = n[s + d++], r.head && k && r.length < 65536 && (r.head.comment += String.fromCharCode(k)), k && d < o;);
                                if (512 & r.flags && (r.check = B(r.check, n, d, s)), o -= d, s += d, k) break e;
                            } else r.head && (r.head.comment = null);
                            r.mode = 9;
                        case 9:
                            if (512 & r.flags) {
                                for(; l < 16;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                if (u !== (65535 & r.check)) {
                                    e.msg = "header crc mismatch", r.mode = 30;
                                    break;
                                }
                                l = u = 0;
                            }
                            r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = 12;
                            break;
                        case 10:
                            for(; l < 32;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            e.adler = r.check = L(u), l = u = 0, r.mode = 11;
                        case 11:
                            if (0 === r.havedict) return e.next_out = a, e.avail_out = h, e.next_in = s, e.avail_in = o, r.hold = u, r.bits = l, 2;
                            e.adler = r.check = 1, r.mode = 12;
                        case 12:
                            if (5 === t || 6 === t) break e;
                        case 13:
                            if (r.last) {
                                u >>>= 7 & l, l -= 7 & l, r.mode = 27;
                                break;
                            }
                            for(; l < 3;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            switch(r.last = 1 & u, l -= 1, 3 & (u >>>= 1)){
                                case 0:
                                    r.mode = 14;
                                    break;
                                case 1:
                                    if (j(r), r.mode = 20, 6 !== t) break;
                                    u >>>= 2, l -= 2;
                                    break e;
                                case 2:
                                    r.mode = 17;
                                    break;
                                case 3:
                                    e.msg = "invalid block type", r.mode = 30;
                            }
                            u >>>= 2, l -= 2;
                            break;
                        case 14:
                            for(u >>>= 7 & l, l -= 7 & l; l < 32;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if ((65535 & u) != (u >>> 16 ^ 65535)) {
                                e.msg = "invalid stored block lengths", r.mode = 30;
                                break;
                            }
                            if (r.length = 65535 & u, l = u = 0, r.mode = 15, 6 === t) break e;
                        case 15:
                            r.mode = 16;
                        case 16:
                            if (d = r.length) {
                                if (o < d && (d = o), h < d && (d = h), 0 === d) break e;
                                I.arraySet(i, n, s, d, a), o -= d, s += d, h -= d, a += d, r.length -= d;
                                break;
                            }
                            r.mode = 12;
                            break;
                        case 17:
                            for(; l < 14;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if (r.nlen = 257 + (31 & u), u >>>= 5, l -= 5, r.ndist = 1 + (31 & u), u >>>= 5, l -= 5, r.ncode = 4 + (15 & u), u >>>= 4, l -= 4, 286 < r.nlen || 30 < r.ndist) {
                                e.msg = "too many length or distance symbols", r.mode = 30;
                                break;
                            }
                            r.have = 0, r.mode = 18;
                        case 18:
                            for(; r.have < r.ncode;){
                                for(; l < 3;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                r.lens[A[r.have++]] = 7 & u, u >>>= 3, l -= 3;
                            }
                            for(; r.have < 19;)r.lens[A[r.have++]] = 0;
                            if (r.lencode = r.lendyn, r.lenbits = 7, S = {
                                bits: r.lenbits
                            }, x = T(0, r.lens, 0, 19, r.lencode, 0, r.work, S), r.lenbits = S.bits, x) {
                                e.msg = "invalid code lengths set", r.mode = 30;
                                break;
                            }
                            r.have = 0, r.mode = 19;
                        case 19:
                            for(; r.have < r.nlen + r.ndist;){
                                for(; g = (C = r.lencode[u & (1 << r.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                if (b < 16) u >>>= _, l -= _, r.lens[r.have++] = b;
                                else {
                                    if (16 === b) {
                                        for(z = _ + 2; l < z;){
                                            if (0 === o) break e;
                                            o--, u += n[s++] << l, l += 8;
                                        }
                                        if (u >>>= _, l -= _, 0 === r.have) {
                                            e.msg = "invalid bit length repeat", r.mode = 30;
                                            break;
                                        }
                                        k = r.lens[r.have - 1], d = 3 + (3 & u), u >>>= 2, l -= 2;
                                    } else if (17 === b) {
                                        for(z = _ + 3; l < z;){
                                            if (0 === o) break e;
                                            o--, u += n[s++] << l, l += 8;
                                        }
                                        l -= _, k = 0, d = 3 + (7 & (u >>>= _)), u >>>= 3, l -= 3;
                                    } else {
                                        for(z = _ + 7; l < z;){
                                            if (0 === o) break e;
                                            o--, u += n[s++] << l, l += 8;
                                        }
                                        l -= _, k = 0, d = 11 + (127 & (u >>>= _)), u >>>= 7, l -= 7;
                                    }
                                    if (r.have + d > r.nlen + r.ndist) {
                                        e.msg = "invalid bit length repeat", r.mode = 30;
                                        break;
                                    }
                                    for(; d--;)r.lens[r.have++] = k;
                                }
                            }
                            if (30 === r.mode) break;
                            if (0 === r.lens[256]) {
                                e.msg = "invalid code -- missing end-of-block", r.mode = 30;
                                break;
                            }
                            if (r.lenbits = 9, S = {
                                bits: r.lenbits
                            }, x = T(D, r.lens, 0, r.nlen, r.lencode, 0, r.work, S), r.lenbits = S.bits, x) {
                                e.msg = "invalid literal/lengths set", r.mode = 30;
                                break;
                            }
                            if (r.distbits = 6, r.distcode = r.distdyn, S = {
                                bits: r.distbits
                            }, x = T(F, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, S), r.distbits = S.bits, x) {
                                e.msg = "invalid distances set", r.mode = 30;
                                break;
                            }
                            if (r.mode = 20, 6 === t) break e;
                        case 20:
                            r.mode = 21;
                        case 21:
                            if (6 <= o && 258 <= h) {
                                e.next_out = a, e.avail_out = h, e.next_in = s, e.avail_in = o, r.hold = u, r.bits = l, R(e, c), a = e.next_out, i = e.output, h = e.avail_out, s = e.next_in, n = e.input, o = e.avail_in, u = r.hold, l = r.bits, 12 === r.mode && (r.back = -1);
                                break;
                            }
                            for(r.back = 0; g = (C = r.lencode[u & (1 << r.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if (g && 0 == (240 & g)) {
                                for(v = _, y = g, w = b; g = (C = r.lencode[w + ((u & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l);){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                u >>>= v, l -= v, r.back += v;
                            }
                            if (u >>>= _, l -= _, r.back += _, r.length = b, 0 === g) {
                                r.mode = 26;
                                break;
                            }
                            if (32 & g) {
                                r.back = -1, r.mode = 12;
                                break;
                            }
                            if (64 & g) {
                                e.msg = "invalid literal/length code", r.mode = 30;
                                break;
                            }
                            r.extra = 15 & g, r.mode = 22;
                        case 22:
                            if (r.extra) {
                                for(z = r.extra; l < z;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                r.length += u & (1 << r.extra) - 1, u >>>= r.extra, l -= r.extra, r.back += r.extra;
                            }
                            r.was = r.length, r.mode = 23;
                        case 23:
                            for(; g = (C = r.distcode[u & (1 << r.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if (0 == (240 & g)) {
                                for(v = _, y = g, w = b; g = (C = r.distcode[w + ((u & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l);){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                u >>>= v, l -= v, r.back += v;
                            }
                            if (u >>>= _, l -= _, r.back += _, 64 & g) {
                                e.msg = "invalid distance code", r.mode = 30;
                                break;
                            }
                            r.offset = b, r.extra = 15 & g, r.mode = 24;
                        case 24:
                            if (r.extra) {
                                for(z = r.extra; l < z;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                r.offset += u & (1 << r.extra) - 1, u >>>= r.extra, l -= r.extra, r.back += r.extra;
                            }
                            if (r.offset > r.dmax) {
                                e.msg = "invalid distance too far back", r.mode = 30;
                                break;
                            }
                            r.mode = 25;
                        case 25:
                            if (0 === h) break e;
                            if (d = c - h, r.offset > d) {
                                if ((d = r.offset - d) > r.whave && r.sane) {
                                    e.msg = "invalid distance too far back", r.mode = 30;
                                    break;
                                }
                                p = d > r.wnext ? (d -= r.wnext, r.wsize - d) : r.wnext - d, d > r.length && (d = r.length), m = r.window;
                            } else m = i, p = a - r.offset, d = r.length;
                            for(h < d && (d = h), h -= d, r.length -= d; i[a++] = m[p++], --d;);
                            0 === r.length && (r.mode = 21);
                            break;
                        case 26:
                            if (0 === h) break e;
                            i[a++] = r.length, h--, r.mode = 21;
                            break;
                        case 27:
                            if (r.wrap) {
                                for(; l < 32;){
                                    if (0 === o) break e;
                                    o--, u |= n[s++] << l, l += 8;
                                }
                                if (c -= h, e.total_out += c, r.total += c, c && (e.adler = r.check = r.flags ? B(r.check, i, c, a - c) : O(r.check, i, c, a - c)), c = h, (r.flags ? u : L(u)) !== r.check) {
                                    e.msg = "incorrect data check", r.mode = 30;
                                    break;
                                }
                                l = u = 0;
                            }
                            r.mode = 28;
                        case 28:
                            if (r.wrap && r.flags) {
                                for(; l < 32;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                if (u !== (4294967295 & r.total)) {
                                    e.msg = "incorrect length check", r.mode = 30;
                                    break;
                                }
                                l = u = 0;
                            }
                            r.mode = 29;
                        case 29:
                            x = 1;
                            break e;
                        case 30:
                            x = -3;
                            break e;
                        case 31:
                            return -4;
                        case 32:
                        default:
                            return U;
                    }
                    return e.next_out = a, e.avail_out = h, e.next_in = s, e.avail_in = o, r.hold = u, r.bits = l, (r.wsize || c !== e.avail_out && r.mode < 30 && (r.mode < 27 || 4 !== t)) && Z(e, e.output, e.next_out, c - e.avail_out) ? (r.mode = 31, -4) : (f -= e.avail_in, c -= e.avail_out, e.total_in += f, e.total_out += c, r.total += c, r.wrap && c && (e.adler = r.check = r.flags ? B(r.check, i, c, e.next_out - c) : O(r.check, i, c, e.next_out - c)), e.data_type = r.bits + (r.last ? 64 : 0) + (12 === r.mode ? 128 : 0) + (20 === r.mode || 15 === r.mode ? 256 : 0), (0 == f && 0 === c || 4 === t) && x === N && (x = -5), x);
                }, r.inflateEnd = function(e) {
                    if (!e || !e.state) return U;
                    var t = e.state;
                    return t.window && (t.window = null), e.state = null, N;
                }, r.inflateGetHeader = function(e, t) {
                    var r;
                    return e && e.state ? 0 == (2 & (r = e.state).wrap) ? U : ((r.head = t).done = !1, N) : U;
                }, r.inflateSetDictionary = function(e, t) {
                    var r, n = t.length;
                    return e && e.state ? 0 !== (r = e.state).wrap && 11 !== r.mode ? U : 11 === r.mode && O(1, t, n, 0) !== r.check ? -3 : Z(e, t, n, n) ? (r.mode = 31, -4) : (r.havedict = 1, N) : U;
                }, r.inflateInfo = "pako inflate (from Nodeca project)";
            },
            {
                "../utils/common": 41,
                "./adler32": 43,
                "./crc32": 45,
                "./inffast": 48,
                "./inftrees": 50
            }
        ],
        50: [
            function(e, t, r) {
                "use strict";
                var D = e("../utils/common"), F = [
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    13,
                    15,
                    17,
                    19,
                    23,
                    27,
                    31,
                    35,
                    43,
                    51,
                    59,
                    67,
                    83,
                    99,
                    115,
                    131,
                    163,
                    195,
                    227,
                    258,
                    0,
                    0
                ], N = [
                    16,
                    16,
                    16,
                    16,
                    16,
                    16,
                    16,
                    16,
                    17,
                    17,
                    17,
                    17,
                    18,
                    18,
                    18,
                    18,
                    19,
                    19,
                    19,
                    19,
                    20,
                    20,
                    20,
                    20,
                    21,
                    21,
                    21,
                    21,
                    16,
                    72,
                    78
                ], U = [
                    1,
                    2,
                    3,
                    4,
                    5,
                    7,
                    9,
                    13,
                    17,
                    25,
                    33,
                    49,
                    65,
                    97,
                    129,
                    193,
                    257,
                    385,
                    513,
                    769,
                    1025,
                    1537,
                    2049,
                    3073,
                    4097,
                    6145,
                    8193,
                    12289,
                    16385,
                    24577,
                    0,
                    0
                ], P = [
                    16,
                    16,
                    16,
                    16,
                    17,
                    17,
                    18,
                    18,
                    19,
                    19,
                    20,
                    20,
                    21,
                    21,
                    22,
                    22,
                    23,
                    23,
                    24,
                    24,
                    25,
                    25,
                    26,
                    26,
                    27,
                    27,
                    28,
                    28,
                    29,
                    29,
                    64,
                    64
                ];
                t.exports = function(e, t, r, n, i, s, a, o) {
                    var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
                    for(b = 0; b <= 15; b++)O[b] = 0;
                    for(v = 0; v < n; v++)O[t[r + v]]++;
                    for(k = g, w = 15; 1 <= w && 0 === O[w]; w--);
                    if (w < k && (k = w), 0 === w) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
                    for(y = 1; y < w && 0 === O[y]; y++);
                    for(k < y && (k = y), b = z = 1; b <= 15; b++)if (z <<= 1, (z -= O[b]) < 0) return -1;
                    if (0 < z && (0 === e || 1 !== w)) return -1;
                    for(B[1] = 0, b = 1; b < 15; b++)B[b + 1] = B[b] + O[b];
                    for(v = 0; v < n; v++)0 !== t[r + v] && (a[B[t[r + v]]++] = v);
                    if (d = 0 === e ? (A = R = a, 19) : 1 === e ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e && 852 < C || 2 === e && 592 < C) return 1;
                    for(;;){
                        for(p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u;);
                        for(h = 1 << b - 1; E & h;)h >>= 1;
                        if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
                            if (b === w) break;
                            b = t[r + a[v]];
                        }
                        if (k < b && (E & f) !== l) {
                            for(0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0);)x++, z <<= 1;
                            if (C += 1 << x, 1 === e && 852 < C || 2 === e && 592 < C) return 1;
                            i[l = E & f] = k << 24 | x << 16 | c - s | 0;
                        }
                    }
                    return 0 !== E && (i[c + E] = b - S << 24 | 4194304), o.bits = k, 0;
                };
            },
            {
                "../utils/common": 41
            }
        ],
        51: [
            function(e, t, r) {
                "use strict";
                t.exports = {
                    2: "need dictionary",
                    1: "stream end",
                    0: "",
                    "-1": "file error",
                    "-2": "stream error",
                    "-3": "data error",
                    "-4": "insufficient memory",
                    "-5": "buffer error",
                    "-6": "incompatible version"
                };
            },
            {}
        ],
        52: [
            function(e, t, r) {
                "use strict";
                var i = e("../utils/common"), o = 0, h = 1;
                function n(e) {
                    for(var t = e.length; 0 <= --t;)e[t] = 0;
                }
                var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2,
                    3,
                    3,
                    3,
                    3,
                    4,
                    4,
                    4,
                    4,
                    5,
                    5,
                    5,
                    5,
                    0
                ], k = [
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5,
                    6,
                    6,
                    7,
                    7,
                    8,
                    8,
                    9,
                    9,
                    10,
                    10,
                    11,
                    11,
                    12,
                    12,
                    13,
                    13
                ], x = [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    2,
                    3,
                    7
                ], S = [
                    16,
                    17,
                    18,
                    0,
                    8,
                    7,
                    9,
                    6,
                    10,
                    5,
                    11,
                    4,
                    12,
                    3,
                    13,
                    2,
                    14,
                    1,
                    15
                ], z = new Array(2 * (l + 2));
                n(z);
                var C = new Array(2 * f);
                n(C);
                var E = new Array(512);
                n(E);
                var A = new Array(256);
                n(A);
                var I = new Array(a);
                n(I);
                var O, B, R, T = new Array(f);
                function D(e, t, r, n, i) {
                    this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = e && e.length;
                }
                function F(e, t) {
                    this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
                }
                function N(e) {
                    return e < 256 ? E[e] : E[256 + (e >>> 7)];
                }
                function U(e, t) {
                    e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255;
                }
                function P(e, t, r) {
                    e.bi_valid > d - r ? (e.bi_buf |= t << e.bi_valid & 65535, U(e, e.bi_buf), e.bi_buf = t >> d - e.bi_valid, e.bi_valid += r - d) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r);
                }
                function L(e, t, r) {
                    P(e, r[2 * t], r[2 * t + 1]);
                }
                function j(e, t) {
                    for(var r = 0; r |= 1 & e, e >>>= 1, r <<= 1, 0 < --t;);
                    return r >>> 1;
                }
                function Z(e, t, r) {
                    var n, i, s = new Array(g + 1), a = 0;
                    for(n = 1; n <= g; n++)s[n] = a = a + r[n - 1] << 1;
                    for(i = 0; i <= t; i++){
                        var o = e[2 * i + 1];
                        0 !== o && (e[2 * i] = j(s[o]++, o));
                    }
                }
                function W(e) {
                    var t;
                    for(t = 0; t < l; t++)e.dyn_ltree[2 * t] = 0;
                    for(t = 0; t < f; t++)e.dyn_dtree[2 * t] = 0;
                    for(t = 0; t < c; t++)e.bl_tree[2 * t] = 0;
                    e.dyn_ltree[2 * m] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0;
                }
                function M(e) {
                    8 < e.bi_valid ? U(e, e.bi_buf) : 0 < e.bi_valid && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
                }
                function H(e, t, r, n) {
                    var i = 2 * t, s = 2 * r;
                    return e[i] < e[s] || e[i] === e[s] && n[t] <= n[r];
                }
                function G(e, t, r) {
                    for(var n = e.heap[r], i = r << 1; i <= e.heap_len && (i < e.heap_len && H(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !H(t, n, e.heap[i], e.depth));)e.heap[r] = e.heap[i], r = i, i <<= 1;
                    e.heap[r] = n;
                }
                function K(e, t, r) {
                    var n, i, s, a, o = 0;
                    if (0 !== e.last_lit) for(; n = e.pending_buf[e.d_buf + 2 * o] << 8 | e.pending_buf[e.d_buf + 2 * o + 1], i = e.pending_buf[e.l_buf + o], o++, 0 === n ? L(e, i, t) : (L(e, (s = A[i]) + u + 1, t), 0 !== (a = w[s]) && P(e, i -= I[s], a), L(e, s = N(--n), r), 0 !== (a = k[s]) && P(e, n -= T[s], a)), o < e.last_lit;);
                    L(e, m, t);
                }
                function Y(e, t) {
                    var r, n, i, s = t.dyn_tree, a = t.stat_desc.static_tree, o = t.stat_desc.has_stree, h = t.stat_desc.elems, u = -1;
                    for(e.heap_len = 0, e.heap_max = _, r = 0; r < h; r++)0 !== s[2 * r] ? (e.heap[++e.heap_len] = u = r, e.depth[r] = 0) : s[2 * r + 1] = 0;
                    for(; e.heap_len < 2;)s[2 * (i = e.heap[++e.heap_len] = u < 2 ? ++u : 0)] = 1, e.depth[i] = 0, e.opt_len--, o && (e.static_len -= a[2 * i + 1]);
                    for(t.max_code = u, r = e.heap_len >> 1; 1 <= r; r--)G(e, s, r);
                    for(i = h; r = e.heap[1], e.heap[1] = e.heap[e.heap_len--], G(e, s, 1), n = e.heap[1], e.heap[--e.heap_max] = r, e.heap[--e.heap_max] = n, s[2 * i] = s[2 * r] + s[2 * n], e.depth[i] = (e.depth[r] >= e.depth[n] ? e.depth[r] : e.depth[n]) + 1, s[2 * r + 1] = s[2 * n + 1] = i, e.heap[1] = i++, G(e, s, 1), 2 <= e.heap_len;);
                    e.heap[--e.heap_max] = e.heap[1], function(e, t) {
                        var r, n, i, s, a, o, h = t.dyn_tree, u = t.max_code, l = t.stat_desc.static_tree, f = t.stat_desc.has_stree, c = t.stat_desc.extra_bits, d = t.stat_desc.extra_base, p = t.stat_desc.max_length, m = 0;
                        for(s = 0; s <= g; s++)e.bl_count[s] = 0;
                        for(h[2 * e.heap[e.heap_max] + 1] = 0, r = e.heap_max + 1; r < _; r++)p < (s = h[2 * h[2 * (n = e.heap[r]) + 1] + 1] + 1) && (s = p, m++), h[2 * n + 1] = s, u < n || (e.bl_count[s]++, a = 0, d <= n && (a = c[n - d]), o = h[2 * n], e.opt_len += o * (s + a), f && (e.static_len += o * (l[2 * n + 1] + a)));
                        if (0 !== m) {
                            do {
                                for(s = p - 1; 0 === e.bl_count[s];)s--;
                                e.bl_count[s]--, e.bl_count[s + 1] += 2, e.bl_count[p]--, m -= 2;
                            }while (0 < m);
                            for(s = p; 0 !== s; s--)for(n = e.bl_count[s]; 0 !== n;)u < (i = e.heap[--r]) || (h[2 * i + 1] !== s && (e.opt_len += (s - h[2 * i + 1]) * h[2 * i], h[2 * i + 1] = s), n--);
                        }
                    }(e, t), Z(s, u, e.bl_count);
                }
                function X(e, t, r) {
                    var n, i, s = -1, a = t[1], o = 0, h = 7, u = 4;
                    for(0 === a && (h = 138, u = 3), t[2 * (r + 1) + 1] = 65535, n = 0; n <= r; n++)i = a, a = t[2 * (n + 1) + 1], ++o < h && i === a || (o < u ? e.bl_tree[2 * i] += o : 0 !== i ? (i !== s && e.bl_tree[2 * i]++, e.bl_tree[2 * b]++) : o <= 10 ? e.bl_tree[2 * v]++ : e.bl_tree[2 * y]++, s = i, u = (o = 0) === a ? (h = 138, 3) : i === a ? (h = 6, 3) : (h = 7, 4));
                }
                function V(e, t, r) {
                    var n, i, s = -1, a = t[1], o = 0, h = 7, u = 4;
                    for(0 === a && (h = 138, u = 3), n = 0; n <= r; n++)if (i = a, a = t[2 * (n + 1) + 1], !(++o < h && i === a)) {
                        if (o < u) for(; L(e, i, e.bl_tree), 0 != --o;);
                        else 0 !== i ? (i !== s && (L(e, i, e.bl_tree), o--), L(e, b, e.bl_tree), P(e, o - 3, 2)) : o <= 10 ? (L(e, v, e.bl_tree), P(e, o - 3, 3)) : (L(e, y, e.bl_tree), P(e, o - 11, 7));
                        s = i, u = (o = 0) === a ? (h = 138, 3) : i === a ? (h = 6, 3) : (h = 7, 4);
                    }
                }
                n(T);
                var q = !1;
                function J(e, t, r, n) {
                    P(e, (s << 1) + (n ? 1 : 0), 3), function(e, t, r, n) {
                        M(e), n && (U(e, r), U(e, ~r)), i.arraySet(e.pending_buf, e.window, t, r, e.pending), e.pending += r;
                    }(e, t, r, !0);
                }
                r._tr_init = function(e) {
                    q || (function() {
                        var e, t, r, n, i, s = new Array(g + 1);
                        for(n = r = 0; n < a - 1; n++)for(I[n] = r, e = 0; e < 1 << w[n]; e++)A[r++] = n;
                        for(A[r - 1] = n, n = i = 0; n < 16; n++)for(T[n] = i, e = 0; e < 1 << k[n]; e++)E[i++] = n;
                        for(i >>= 7; n < f; n++)for(T[n] = i << 7, e = 0; e < 1 << k[n] - 7; e++)E[256 + i++] = n;
                        for(t = 0; t <= g; t++)s[t] = 0;
                        for(e = 0; e <= 143;)z[2 * e + 1] = 8, e++, s[8]++;
                        for(; e <= 255;)z[2 * e + 1] = 9, e++, s[9]++;
                        for(; e <= 279;)z[2 * e + 1] = 7, e++, s[7]++;
                        for(; e <= 287;)z[2 * e + 1] = 8, e++, s[8]++;
                        for(Z(z, l + 1, s), e = 0; e < f; e++)C[2 * e + 1] = 5, C[2 * e] = j(e, 5);
                        O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
                    }(), q = !0), e.l_desc = new F(e.dyn_ltree, O), e.d_desc = new F(e.dyn_dtree, B), e.bl_desc = new F(e.bl_tree, R), e.bi_buf = 0, e.bi_valid = 0, W(e);
                }, r._tr_stored_block = J, r._tr_flush_block = function(e, t, r, n) {
                    var i, s, a = 0;
                    0 < e.level ? (2 === e.strm.data_type && (e.strm.data_type = function(e) {
                        var t, r = 4093624447;
                        for(t = 0; t <= 31; t++, r >>>= 1)if (1 & r && 0 !== e.dyn_ltree[2 * t]) return o;
                        if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return h;
                        for(t = 32; t < u; t++)if (0 !== e.dyn_ltree[2 * t]) return h;
                        return o;
                    }(e)), Y(e, e.l_desc), Y(e, e.d_desc), a = function(e) {
                        var t;
                        for(X(e, e.dyn_ltree, e.l_desc.max_code), X(e, e.dyn_dtree, e.d_desc.max_code), Y(e, e.bl_desc), t = c - 1; 3 <= t && 0 === e.bl_tree[2 * S[t] + 1]; t--);
                        return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
                    }(e), i = e.opt_len + 3 + 7 >>> 3, (s = e.static_len + 3 + 7 >>> 3) <= i && (i = s)) : i = s = r + 5, r + 4 <= i && -1 !== t ? J(e, t, r, n) : 4 === e.strategy || s === i ? (P(e, 2 + (n ? 1 : 0), 3), K(e, z, C)) : (P(e, 4 + (n ? 1 : 0), 3), function(e, t, r, n) {
                        var i;
                        for(P(e, t - 257, 5), P(e, r - 1, 5), P(e, n - 4, 4), i = 0; i < n; i++)P(e, e.bl_tree[2 * S[i] + 1], 3);
                        V(e, e.dyn_ltree, t - 1), V(e, e.dyn_dtree, r - 1);
                    }(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, a + 1), K(e, e.dyn_ltree, e.dyn_dtree)), W(e), n && M(e);
                }, r._tr_tally = function(e, t, r) {
                    return e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & r, e.last_lit++, 0 === t ? e.dyn_ltree[2 * r]++ : (e.matches++, t--, e.dyn_ltree[2 * (A[r] + u + 1)]++, e.dyn_dtree[2 * N(t)]++), e.last_lit === e.lit_bufsize - 1;
                }, r._tr_align = function(e) {
                    P(e, 2, 3), L(e, m, z), function(e) {
                        16 === e.bi_valid ? (U(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : 8 <= e.bi_valid && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8);
                    }(e);
                };
            },
            {
                "../utils/common": 41
            }
        ],
        53: [
            function(e, t, r) {
                "use strict";
                t.exports = function() {
                    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
                };
            },
            {}
        ],
        54: [
            function(e, t, r) {
                (function(e) {
                    !function(r, n) {
                        "use strict";
                        if (!r.setImmediate) {
                            var i, s, t, a, o = 1, h = {}, u = !1, l = r.document, e = Object.getPrototypeOf && Object.getPrototypeOf(r);
                            e = e && e.setTimeout ? e : r, i = "[object process]" === ({}).toString.call(r.process) ? function(e) {
                                process.nextTick(function() {
                                    c(e);
                                });
                            } : function() {
                                if (r.postMessage && !r.importScripts) {
                                    var e = !0, t = r.onmessage;
                                    return r.onmessage = function() {
                                        e = !1;
                                    }, r.postMessage("", "*"), r.onmessage = t, e;
                                }
                            }() ? (a = "setImmediate$" + Math.random() + "$", r.addEventListener ? r.addEventListener("message", d, !1) : r.attachEvent("onmessage", d), function(e) {
                                r.postMessage(a + e, "*");
                            }) : r.MessageChannel ? ((t = new MessageChannel).port1.onmessage = function(e) {
                                c(e.data);
                            }, function(e) {
                                t.port2.postMessage(e);
                            }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e) {
                                var t = l.createElement("script");
                                t.onreadystatechange = function() {
                                    c(e), t.onreadystatechange = null, s.removeChild(t), t = null;
                                }, s.appendChild(t);
                            }) : function(e) {
                                setTimeout(c, 0, e);
                            }, e.setImmediate = function(e) {
                                "function" != typeof e && (e = new Function("" + e));
                                for(var t = new Array(arguments.length - 1), r = 0; r < t.length; r++)t[r] = arguments[r + 1];
                                var n = {
                                    callback: e,
                                    args: t
                                };
                                return h[o] = n, i(o), o++;
                            }, e.clearImmediate = f;
                        }
                        function f(e) {
                            delete h[e];
                        }
                        function c(e) {
                            if (u) setTimeout(c, 0, e);
                            else {
                                var t = h[e];
                                if (t) {
                                    u = !0;
                                    try {
                                        !function(e) {
                                            var t = e.callback, r = e.args;
                                            switch(r.length){
                                                case 0:
                                                    t();
                                                    break;
                                                case 1:
                                                    t(r[0]);
                                                    break;
                                                case 2:
                                                    t(r[0], r[1]);
                                                    break;
                                                case 3:
                                                    t(r[0], r[1], r[2]);
                                                    break;
                                                default:
                                                    t.apply(n, r);
                                            }
                                        }(t);
                                    } finally{
                                        f(e), u = !1;
                                    }
                                }
                            }
                        }
                        function d(e) {
                            e.source === r && "string" == typeof e.data && 0 === e.data.indexOf(a) && c(+e.data.slice(a.length));
                        }
                    }("undefined" == typeof self ? void 0 === e ? this : e : self);
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
            },
            {}
        ]
    }, {}, [
        10
    ])(10);
});

},{"f7295d6075386111":"i2v7G","cf30dbb97a1d82ba":"euskh"}]},["5PTPR","lhpGb"], "lhpGb", "parcelRequire06a2", {})

//# sourceMappingURL=vanilla.b828852a.js.map
